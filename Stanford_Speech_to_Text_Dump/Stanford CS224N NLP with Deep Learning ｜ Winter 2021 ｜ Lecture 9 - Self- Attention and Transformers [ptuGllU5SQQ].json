{"text": " Hi everyone. Welcome to CS224N, Lecture 9, Self-Attention and Transformers. If I am not able to be heard right now, please send a message in the chat because I can't see anyone. But I'm excited to get into the content for today. We'll be talking about self-attention and transformers. Let us dive into the lecture plan and we'll talk about some sort of to-do's for the course as well. So we'll start with where we were back last week with recurrence, recurrent neural networks. And we'll talk about a movement from recurrence to attention based on LP models. We talked about attention and we're going to just go all in on attention. We'll introduce the transformer model, which is a particular type of attention based model. It's very popular. You need to know it. You're going to learn it. We'll talk about some great results with transformers and then some drawbacks and variance and sort of very recent work on improving them. So some reminders before we jump in. Assignment 4 is due. The mid-quarter feedback survey is due Tuesday, February 16th. You get some small number of points for doing that and we really appreciate your feedback on what we've done well, what we can improve on. And then, final project proposal is also due. One note on the proposals. Part of the goal of the proposal is to, you know, or let's say the main part of the goal of the proposal is to give you feedback on the idea that you have presented and make sure that it is a viable option for a final project and make sure we kind of recenter if not. And so we want to get feedback to you very quickly on that. Okay. All right. So with that, let's start in on the content of this week's lecture. So we were in this place in MLP as of last week where we had recurrent neural networks sort of for a lot of things that you wanted to do. So it's around 2016 and the strategy if you want to build a strong MLP model is you have, you know, sentences that you need to encode and you have like a bidirectional LSTM say. And, you know, maybe it looks a little bit like this pictographically. And maybe it's a source sentence in a translation, for example. We saw machine translation and then you define your output which is maybe a sequence of words which is the target, you know, translation that you're trying to predict or maybe it's a parse tree or it's a summary. And you use an LSTM with one direction to generate it. And this works really well. We did, we used these architectures to do all kinds of interesting things. But one thing that we said, we talked about this information sort of bottleneck that you're trying to encode maybe a very long sequence and sort of the very last vector in your or in one vector in your encoder. And so we used attention as this mechanism to take, you know, a representation of from our decoder and sort of look back and treat the encoded representations as a memory that we can back with that we can reference and sort of pick out what's important to any given time. And that was attention. And this week we're going to do something slightly different. So we learned about sequence to sequence models, the encoder, decoder way of thinking about problems more or less in order to deal with this idea of, you know, building a machine translation system that's end to end differentiable, right? And so this is sort of a really interesting way of thinking about problems. What we'll do this week is different. We're not trying to motivate sort of an entirely new way of thinking about problems like machine translation. Instead, we're going to take the building blocks that we were using, you know, recurrent neural networks. And we're going to spend a lot of trial and error in the field trying to figure out if there are building blocks that just work better across a broad range of problems. So we'll just slot the new thing in for recurrent neural networks and say, you know, voila, maybe it works better. And so I want to take us on this sort of journey to self attention networks. And we'll start with some problems with recurrent neural networks. So we spent a bit of time trying to convince you that recurrent neural networks were very useful. Now I'm going to talk about reasons why they can be improved. So we know that recurrent neural networks are enrolled left to right, quote, in air quotes, it could be right to left as well. So what does this mean? Or recurrent neural network encodes linear locality, right? So once I'm looking at tasty in this phrase, I'm about to look at pizza, or if I'm going in the other direction, once I look at pizza, I'm about to look at tasty. And so it's very easy for their meanings, for their presence in the sentence, to affect the meaning, to affect the representation of the other word. And this is actually quite useful because nearby words frequently do influence each other. That's practically one of the things we talked about with the distributional hypothesis as encoded by something like word-to-vec. But if words are distant linearly, they can still interact with each other. This is something that we saw in dependency parsing. So if I have, say, the phrase, the chef, notice chef bolded here, I'm running a recurrent neural network over this. And then the chef who, then I have this long sequence that I'm going to encode. And then the word was, right? Maybe it is the chef who was. But in between I have O of sequence length, many steps of the computation that I need to get to before chef and was can interact. Right? And so in the middle, things might go wrong. Maybe it's hard to learn things where they should interact. So in particular, it might be hard to learn long distance dependencies because we have gradient problems. We saw the LSTMs propagate gradients better than simple RNNs, but not perfectly. And so if chef and was are very far, it becomes hard to learn that they should interact. And the linear order of words is sort of baked into the model. You have to unroll the RNN throughout the sequence. And it's not really the right way to think about sentences necessarily, at least linear order isn't really how sentences are kind of structured. And so here you have chef. And then you've got all this sort of computation in the middle, all those applications of the recurrent weight matrix before you allow it to interact with was. And again, sort of dependence is O of sequence length. And then you got the word was. Okay? A second problem is very related. This is the lack of parallelizability. So this is going to be a huge refrain now that we've gotten to the transformer's lectures is parallelizability. It's what you get from your GPU and it's what you want to exploit. So when you run an RNN, you have O of sequence length many unparallelizable operations. And so while you have a GPU that can kind of chunk through a bunch of independent operations at once, you're unable to sort of do them all at once because you have this explicit time dependence in the recurrent equations. In particular, you know, a future RNN state down the line can't be computed until you've computed one that's earlier on. And this inhibits training on very large data sets. So let's take a look at this, unrolling an RNN. If this is, say, the first later layer of an RNN or an LSTM, maybe it doesn't depend on effectively anything. You can just compute it immediately. And then the second layer, so this is a, you know, a stacked set of two LSTMs. The second layer depends on the first layer here. In the time dimension though, this cell here depends on this. So you've got a one. And then, you know, this depends on this. So you've got a one. So you have, you know, at most, sorry, at least two things that you need to compute here before you can compute the value of this cell, likewise three here. And with the sequence length, it grows with O of the sequence length. So, so here, I have been unable to even try to compute this value when I get here because I had to sort of do all of this first. So I can't parallelize over the time dimension. And this inhibits training on very large data sets. Okay. So, and then, I guess, crystal TAs, you'll be able to stop me with the question if it feels like that's the right thing to do. Okay. So, and you can see how it's a related problem, right? It's really directly related to the recurrence of the model. The thing that we thought was really useful now is being problematic. Okay. So, so what I'm trying to say with that is we seemingly want to replace recurrence as the building block itself. So, let's go through some alternatives. And we've seen each of these alternatives in the class so far. We'll start with WordWindow, sort of building blocks for our NLP models. If we wanted to replace our encoders and our decoders with something that sort of fit the same goal, but had different properties. So, a WordWindow model will aggregate local context, right? We saw this with our sort of WordWindow classifiers that we've built already. You take a local context of words, you use it to represent information about the center word. This is also known as one-dimensional convolution. We'll go over this in depth later in the course. Right now, we'll consider it as WordWindow context. So, the number of unparallelizable operations with these WordWindow building blocks does not grow with the sequence length. And here's a picture of that. You have the embedding layer, say, so you can embed every word independently. Right? So, you don't need to know the other words surrounding it in order to pick the right embedding dimension out. And so, these all have sort of zero dependence in this sort of hand-wavy notion of how much parallelizability is there is. Now, you can walk a WordWindow classifier on top of each one to build a representation of the word that takes into account its local context. But in order to apply it to this word, h1, I don't need to know anything. Sorry, I don't need to have applied it to h1 in order to apply it to h2. Likewise, in order to apply a WordWindow contextualizer to ht, I can just look at its local window independently. And so, again, none of these have a dependence in time. I can keep stacking layers like this. Right? So, this can look like an encoder, right? And encoder like our LSTM encoders. If I didn't allow you to look at the future by just cutting off the window, it could look like a decoder for language models. And this is nice. And we get this beautiful, you know, o of 1 dependence in time, right? No dependence at all in the time dimension. That's an improvement. But there are some problems. So, what about long distance dependencies, right? This is why we said we wanted to use recurrent neural networks because they would do better at encoding long distance dependencies. It's a problem, just like it was a problem before. But by stacking WordWindow layers, we can get to wider, longer contexts. So, if you have some sort of window size, and then you stack two layers, so red states here are state kind of how you can look, how far away you can look in order to encode hk, right? So, in the embedding layer, we have these sort of words here. So, this is the last layer, this top layer of the WordWindow classifier. Here's the embedding of hk at the output of your encoder. And so, it looks at, you know, the local five words, because that's the window size. And then, as well, you know, the farthest word over here has also looked a couple of words away, right? So, if you stack these, and stack these, and stack these without growing the window size at all at any given layer, you can look pretty far. And actually there are tricks you can use to look even farther. But you still have this sort of, at least in principle, problem, where you've got a word like this h1. And you can see how it's in blue. And, you know, with these two layers of the network, I don't know anything about h1 at all when I'm building up the representation of hk over here. I could solve that by adding another layer in depth, but, you know, in principle, you always have some finite field. So, this is, you know, actually pretty useful. These, you know, word window kind of contextualizers, and we will learn more about them later. And there was sort of a lot of this effort that I talked about at the beginning of the class, was actually sort of partly deciding which of, when you know, word window stuff, convolutional, it's called stuff, or attention, and attention has won out for the time being. And so, yeah, what about attention? So, what, why could it be useful as, like, as a fundamental building block instead of sort of sugar on top of our LSTMs? So, just to recall some of the intuitions of attention, it treats a words representation as a query, and it looks somewhere and tries to sort of access information from a set of values, right? So, we had a word representation in our decoder in our machine translation systems. The set of values were all of the encoder states for the source sentence. And today we'll think about, instead of attention from the decoder to the encoder, we will think about attention within a single sentence. So, just a very quick picture of it, you've got your embedding layer again, I'm putting the computational dependence counts here, so all of these sort of can be done in parallel for the embedding layer again. And now you're doing attention, right? So, you're kind of looking at every single word in the embedding layer to attend to this word. And I'm omitting a bunch of arrows here, so these are all arrows. All words interact with all words, and we'll get deep into this today, I promise, but I just wanted to sort of make this a little bit less dense looking of a graph. And then, so, in the second layer, again, all pairs of words interact, and this is all parallelizable. So, you can't parallelize in depth, right? Because you need to encode this layer before you can do that layer, but in time, it is parallelizable. So, it checks that box. So, again, we have O of one sort of computational dependence, you know, a number of unparallizable operations as a function of sequence length, and as an added benefit, right? The interaction distance between words is O of one as well. So, whereas before, we had recurrent networks where if you are far, so T is the last word in the sentence, you could have O of T operations between you and a far away word, with attention, you interact immediately. That's very first layer, you get to see your far away word, and so that's O of one. And this ends up being seemingly fascinatingly powerful, and we'll get into a lot of details today. Okay. So, this is sort of why attention solves the two problems that we brought up with recurrent neural networks, but with our empiricist hats on, it shouldn't be proof yet that, you know, it should be a good building block. And in fact, it takes a little bit of thinking to think about how to turn attention into a building block like RNNs were. So, let's start by digging right into just the equations for self-attention, which again is attention to, or the, everything is looking within itself, we'll formalize this for you. So, we're going to be talking all lecture today about queries, keys, and values. Our queries are going to be a set of T queries, each query is a vector in dimension D. You can just think of them as just those vectors right now, not worrying necessarily about where they came from. We have a set of keys, K1 to KT. Again, each vector K is in dimension L. So, we have a value D, and we have some values. Each value is going to be also in dimension L D. And for now, we're going to assume that we have the same number of all of them, that's not necessarily the case later. So, in self-attention, the keys, queries, and values come from the same source of information, the same sentence, for example. And so, yeah, in practice, when they all come from the same sentence, right, this is going to be the same number of all of them. It's all going to be T. In practice, you can have the numbers differ. So, where do these come from? We'll get into the specifics of this later, but for now, think about the output of the previous layer. So, imagine the output is, you know, you have like the embedding layer, right, and that's the input to something that's going to do self-attention. Think of all of these outputs of the embeddings as some vectors x i. And now, we can just say that the value is equal to the key, is equal to the query, is equal to that x i. So, we're just going to use the same vectors for all of them. But labeling them as keys, queries, and values, I promise, will be very useful in how we sort of think about what's going on and how we look at the equations that implement this. So, self-attention pretty generally, but with this dot product, so, dot product self-attention, here's just the math. Math is, you compute key query affinities, and the dot product bit is the fact that you're using the dot product function here. So, you take a dot product for all pairs i and j of qi dotted with kj. So, that is a t by t matrix, capital T, right, by t matrix of affinities. Those are scalar values not bounded in size. Next, you compute the attention weights we saw this as well, using the softmax function. I've just written out the softmax function here. So, you know, you exponentiate the affinity, and then you sum over, in this case, right, you're summing over all of the keys. So, you've got a given query, and you're summing over all the keys for the normalization. So, where should this query be looking? Remember, you've got t different queries that we're doing this for here. And so, for a given query, you sum over all the keys to get your normalization constant. Normalizing by that gives you a distribution over the sequence length t. So, now you have sort of a weight on all of the sequence indices. And again, we do our weighted average. So, we've got our weights for our average, and then the output, right, there's going to be one output per query. The output is the weights for that multiplied by the value vectors, right? So, again, if you set the keys, the queries, the values to all be x, this makes sense, but it's nice to have the keys and the keys to know sort of which thing is doing what. You can think of the query as being sort of looking for information somewhere, the key as, you know, interacting with the query, and then the value is the thing, you know, that you're actually going to, you know, weight in your average and output. So, question you might like to answer is, so if now we're connecting everything to everything, how is this different to using a fully connected layer? That's a great question. A couple of reasons. One is that, unlike a fully connected layer, you get to learn the interaction weights. Well, the interaction weights are dynamic as a function of what the actual values here are, right? So, in a fully connected layer, you have these weights that you're learning slowly over the course of the training your network that allow you to say sort of which hidden units you should be looking at. In attention, it's the actual interactions between the key and the query vectors, which are dependent on the actual content that are allowed to vary by time. And so, the actual strengths of all the interactions of all the sort of attention weights, which you could think of as, you know, connected to the weights in the fully connected layer, are allowed to change as a function of the input. A separate thing is that the parameterization is much different. So, you're not learning an independent connection weight for all pairs of things. Instead, you have, you're allowed to parameterize the attention as, you know, these sort of dot product functions between vectors that are representations. And you end up having, you know, the parameters work out more nicely, which we'll see later. We haven't gone into how we're parameterizing these functions yet. So, those are the two answers, I'd say, is one is you have this sort of dynamic connectivity. And two is, you know, you don't have just, it has this inductive bias that's not just connect everything to everything feed forward. Great. Okay, I think that's a very interesting question. Yeah, so I'm glad you asked it. Okay, so, we've talked about self-attention now. The equations are going to self-attention. But, can we just like use this as a building block? I mean, you know, take all of your LSTMs, throw them out. Use the self-attention that we've just defined instead. Why not? Well, here's a couple of reasons why. So, look at self-attention as a building block. So, we have some words in the sentence, the chef who, some stuff, long sentence, food is the last word of the sentence. Okay. And, you know, they have an embedding. And from that, you get your key query in value. We've said so far, right, there's the same vector actually, but, you know, key query value, key query value, key query value. And, you know, we might stack them like LSTM layers. So, you have key query value, perform self-attention on the key queries and values. As we said, self-attention is a function on key queries and values. So, perform self-attention now that you have these, get new key queries values, and then perform self-attention again. Look, you know, this looks a lot like, a lot like stacking LSTMs. But, it actually has a few issues as it stands. So, we're going to need to go on a journey to determine what's missing from our self-attention. And the first thing is that self-attention is an operation on sets. Okay. So, for the equations that we had before, the self-attention equation never referred to the indices of K, Q, or V, except to sort of say which pairs we're interacting with each other. It doesn't know what the order of your sentence is. When it's computing, though, the weights, it has no idea. And so, if I were to input this sentence, the chef who food, it would be the same as if I just swapped the with chef and then swapped who with the, and it just had, would have no idea. So, already this is not going to work because the order in which words appear in sentences matters. So, here's the first problem that we need to work with. So, I'm going to have a list of barriers. This is just the first, I had a whole journey ahead of us. And then we're going to have a list of solutions. So, we need to represent the sequence order somehow. We can't just lose that information entirely because we wouldn't know what order the words showed up in. So, somehow, if we're not going to change the self-attention equations themselves, we need to encode the order in the keys, queries, and values, and let the network sort of figure it out on its own. So, think about this. We have T sequence indices. And we're going to bound T to some finite constant. So, T is never going to be bigger than something for us. And we call it T. And now we're going to represent the sequence index as a vector. So, PI is going to be the vector representing index I. And it's going to be in dimensionality D just like our keys, queries, and values. And so, we're going to have one of these for one to T. So, don't worry yet about what the PI are like, how they're constructed. We'll get right into that. But think about this. It's easy to incorporate this information into our attention building blocks. At the first layer, if you let tilde V tilde K tilde Q be our old values keys and queries, we can just add. We could do other stuff too. But in practice, we just add. So, VI is equal to V tilde I, our orderless value vector plus PI. So, this might be your embedding vector. And then you add the index that it's at to its vector. And you might only do this at the first layer of the network, for example. So you do the same thing for the query and the key. So, this is something that you could do. In practice, you do something slightly different. But this is something that, you know, now it knows the order of the sequence. Because if these PI's, you've set properly somehow, then now the network is able to figure out what to do with it. So, what's one way of actually making this happen? One way of making this happen is through the concatenation of synosoids. And this was an interesting take when the first transformer's paper came out, they used this method. So, let's dig into it. So, you have varying wavelengths of sinusoidal functions in each of your dimensions. So, in the first dimension, if you have this sine function with a given period, and then this cosine function with a given period, and then sort of dot, dot, dot, you sort of change the periods until you get to much, different periods. And what does it look like? It looks like that. So, imagine here, in the vertical axis, we've got the dimensionality of the network. So, this is D, and then this is sequence length. And by just specifying, you know, in each row, is sort of one of these signs with different frequencies. Right? And you can sort of see how this is encoding position. These things have different values at different indices, and that's pretty cool. I don't really know how they thought of it immediately. But one cool thing about it is this periodicity notion. Right? The fact that the synosoids have periods that might be less than the sequence length indicates that maybe the absolute position of a word isn't so important. Right? Because if the period is less than the sequence length, you lose information, maybe about where you are. Of course, you have the concatenation of many of them. So, that's a pro. Maybe it can extrapolate to longer sequences, because again, you sort of have this repetition of values, right? Because the periods will, when they, when they complete, you'll see that value again. The cons are that it's not learnable. I mean, this is cool, but you can't, there's no learnable parameters in any of this. And also, the extrapolation doesn't really work. So, this is an interesting and definitely still done. But what's done more frequently now is we, you know, what do we do? We learn the position of representations from scratch. So, we have, we're going to learn them from scratch. So, let all the PI just be learnable parameters. So, what we're going to do is we're going to have a matrix P. That's going to be in dimensionality D, dimensionality of our network again, by the sequence length. So, this is just a big matrix, right? Of the size here, of this size effectively, D by sequence length. But every single value in that matrix is just a learnable parameter. Proves flexibility. Now, you get to learn what positions is sort of supposed to mean, according to your data, end to end. So, that's cool. Cons, you definitely can't extrapolate to indices outside 1 to T, right? Because you set the size of this parameter matrix at the beginning, and you learned them all. Now, if you want to go beyond position T, you know, you just, you have no way to represent it effectively. But most systems use this. This is super useful. And sometimes people try more flexible representations of position, because again, the absolute index of a word is not sort of its natural representation of its position in the sentence. And so, people have looked at the kind of the relative position between words, as well as position representations that depend on syntax. But we're not going to be able to go too far into those today. Okay, so that was problem 1, right? We just, no matter what we did, if we didn't have representation of position, there was no way we could use self-attention as our new building block. And we've solved it with position representations that we just sort of add to the inputs. Next, we're going to see this problem that you don't have non-linearities. You know, even saying non-linearities, abstract features, they're great deep learning, end to end learning of representations is awesome. But right now, we're just doing weighted averages. And so, what is our solution going to be? I mean, it's not going to be all that complex. So, all we're doing right now is re-averaging vectors, right? So, you've got sort of the self-attention here. And if you just stacked another one, you just keep sort of averaging projections of vectors. But what if we just add a feed-forward network for every individual word? So, within this layer, each of these feed-forward neural networks shares parameters. But it gets in just the output of self-attention for this word as we defined it, processes it, and emits something else. And so, you know, you have output i from self-attention, which we saw slides ago. Apply, you know, a feed-forward layer where you take the output, multiply by matrix, you know, non-linearity, other matrix. And the intuition here, you can think of at least is, well, you know, something like the feed-forward network processes the result of the attention for each thing. But more fundamentally, right, you needed some kind of non-linearity there. And, you know, a feed-forward network will do a good job. Okay, so that's another problem solved. Easy fix. Add a feed-forward network, get your non-linearity. Now, your self-attention output, you can sort of process it, have that sort of depth increasing as the layers of the network increase, which we know is useful. Another problem. Okay, so bear with me on this one. We don't want to look at the future when we're doing language modeling. Right, so language modeling, you're trying to predict words in the future. And with the recurrent model, it's very natural, right? Like, you just don't unroll it further. Once you've unrolled a word to unrolled your LSTM to a given word, the sort of no way to have given it to the next word as well. But in self-attention, we'll see that this is a little bit trickier. So, we can't cheat and look at the stuff we're trying to be predicting, because then we would train networks that were totally useless. So what are we going to do? We're going to mask, masking is a word that's going to keep coming up. We're going to mask the future in self-attention. So, in particular, this is important when we have decoters. Right, one of the reasons why we could use bidirectional LSTMs in our encoters was that we could see the whole source sentence in neural machine translation. But when we're predicting the output sentence, right, we can't see the future if we want to train the model to do the actual prediction. So, to use self-attention in a decoder, you can mask the future. One thing that you could do is you could just every time you compute attention, you change the set of keys and values this should be. Keys and values to only include past words. So, you're sort of dynamically changing the stuff that you're attending over. But that doesn't let us do stuff with tensors as well as as pre-melizably as we will see. So, we don't want to do that. Instead, we're going to mask out the future words through the attention weights themselves. So, in math, don't worry, we'll get to the sort of diagram. But in math, we had these attention scores and they were equal to just this dot product before for all pairs. Right, but now, only if the key is strictly less than the key index is strictly less than the key index. So, this would be j less than i. Should we let the network look at the word and it should be negative infinity otherwise. So, we don't let you look at the output. So, let's go to the picture. For encoding the words that we'll see here, so maybe we have a start token. You want to decide, this is your whole sentence now. You want to decide which words in the sentence you're allowed to look at when making your predictions. So, you're allowed to look at the first word and in order to predict the, I'm not allowed to look at the word the, I'm also not allowed to look at any of the future words, I am allowed to look at the word start. So, this kind of block is not shaded here. In order to predict the word chef, I can look at start and the, right, start the, but not chef naturally or the word that comes after it. So, we're allowed to look at the word chef naturally or the word that comes after it. Likewise for the other words. So, you can see this sort of, this matrix here, right. So, we just want to make sure that our attention weights are zero everywhere here. So, in the affinities calculation, we add negative infinity to all of these in this big matrix. And that guarantees that we can't look to the future. Okay, so now we can do big matrix multiplications to compute our attention as we will see. And we sort of don't worry about looking at the future because we've added these negative infinities. And that's the last, that's the last problem with self-attention sort of that comes up fundamentally as like what do we need for this building block. You have, you didn't have an inherent notion of order. Now you have a good notion of order or at least something of a notion of order. You didn't have nonlinearities, add feed forward networks. And then you didn't want to look at the future. You add the masks for the decoders. So, you know, self-attention is the basis of any self-attention based building block. Hello. Position representations are useful. Nonlinearities are good. You don't have to use a feed forward network. Right? Like you could have just done other stuff, I guess. But, you know, in practice actually it's really easy to parallelize these feed forward networks as well. So we end up doing that. And then the masking, you know, yeah, you don't want information to leak from the future to the past in your decoder. So, so let me be clear. We haven't talked about the transformer yet. But this is all you would need if you were thinking like, gosh, what do I need in order to build my self-attention building block. We'll see that there are a lot more details in the transformer that we're going to spend, the rest of the lecture going through. But I want you to sort of at least, as you're thinking about what's going to come next after the transformer and how you're going to invent it, think about the fact that these are the things that were necessary. And then the other things end up being very, very important to turns out. But, you know, there's a lot of design space here that hasn't been explored yet. Okay, so let's talk about the transformer model. And I'm going to pause. There are any, this is a good question. I can take it now. Okay. So, transformers. Let's get to it. Let's look at the transformer encoder decoder blocks at a high level first. This should look a lot like the encoder decoders that we saw with the recurrent neural network machine translation systems that we saw. Okay, so we have our word embeddings. We're going to add in our position representations. We saw that. And that's from our input sequence. We'll have a sequence of encoder blocks. Each of them is called a transformer encoder. And then, you know, we have our output sequence, word embeddings, position representation again. We have a transformer decoder. Each end, the last layer of encoders is going to be used in each layer of the transformer decoder. And then we get some outputs, some predictions. Okay, so this looks pretty much the same at a very high level. Maybe minus the fact that now we need to do the position representation addition at the very beginning. So now let's look at these blocks themselves. So the encoder and decoder blocks, what's left that we haven't covered, right? Because we could just put the building blocks that we just came up with in the first part of class in these things, right? In coders, we need our self attention, our feed forward networks. We have our position representations. We get the masking for the decoders. Right, we can just slot these in. But it turns out they wouldn't work all that well compared to transformers. So what's left? So the first thing is key query value attention. This is a specific way of getting the K, Q, and V vectors from the single word embedding. Right? So instead of letting K, Q, and V equal to X, like the output from the last layer, we're going to do something a little bit more. Next is multi-headed attention. We're going to attend to multiple places in a single layer. And we'll see that that gets us sort of kind of interesting properties in the homework later on. But we'll talk a little bit about it today. And then there's a bunch of things that just help with training. These seemed like they were very hard to train at first. A lot of these tricks are very useful. So we'll talk about residual connections, layer normalization, and scaling the dot product. Everything in bullet point three here, tricks to help with training. Don't improve with the model is able to do. But they're crucial in that they improve the training process. So modeling improvements of both kinds are really, really important. So it's good that we're using self attention, which is this cool thing that had these properties. But if we couldn't train it, it wouldn't be useful. OK, so here's how the transformer builds the key query and value vectors. We have X1 to Xt. The input vector is to our transformer layer. And we're going to find the transformer encoder here. So we have one of these vectors per word, you can say. And again, each XI is going to be a vector in dimensionality D. And here's how we compute the keys, queries, and values. We're going to let each key, KI, which we saw before, be equal to some matrix K times XI, where K is D by D. So this is a transformation from dimensionality D to dimensionality D. We're going to call this the key matrix K. And we're going to do the same thing for the queries. So we're going to take the XI, multiply by matrix, get the query vector, and we'll do the same thing for V. OK, so you can just plug this in. Now instead of saying that all the K, Q, and the V are all the same as X, they all are slightly different because you apply a linear transformation. What does this do? Well, you can think about it as like, well, the matrices K, Q, and V can be very different from each other. And so they sort of emphasize or allow different aspects of the X vectors to be used in each of the three roles. So we wrote out the self-attentioned equations with the three roles to indicate the different things are being done with each of them. So maybe K and Q are helping you figure out where to look. And so they should be a certain way. They should look at different parts of X. And then V, the value, maybe you want to pass along a different information than the thing that actually helps you access that information. So this is important. How do we do this? In practice, we compute it with really big tensors. So we had our X vectors, which we've been talking about sort of word by words. We had the sequence XI, X1 to XT. So we actually represent them all as a matrix X, which is in our sequence length by dimensionality. So sequence length by D, capital T by D. And now if we have the matrix for each of our key query and value, right, we're going to apply, like we're going to look at these things XK, XQ, and XV, which are all of the same dimensionality as X because of the D by D transformations. So how do we compute self-attention? We have our output tensor, which is the same dimensionality as the input X. This is going to be equal to softmax, or as a softmax, of this matrix multiplication, which we'll get into, times the value vectors. So the matrix multiplication here is computing affinities between keys and queries we'll see. And then here's our averaging. What does that look like pictorially? So you take the key query dot products. So this term here, XQ, XK transpose. It's giving you all dot products, all T by T pairs of attention scores. So our Eij are in this matrix right here. It's T by T. And this is just a big matrix multiplication. So you do the matrix multiplication, XQ, and then XK, and then you get all of the dot products by through this. So now you have this big T by T set of scores. That's what we wanted. And now you can softmax that directly as a matrix. And then do a matrix multiplication here with XV in order to give your output vector. So this is actually doing the weighted average that we saw at the beginning of the class. And this, you know, there's no for loops here. It's really beautifully, which is a vectorized. And it gives us our output, which again, remember same dimensionality T by D. Okay, so all periods of attention scores then compute the averages by applying the score, the softmax of the scores to the XV matrix. So that's it. That's it for key query value attention. That's how, you know, we implemented with tensors. Next we'll look at the kind of the next thing that ends up being quite important for training transformers in practice, which is multi-headed attention. So transfer encoder multi-headed attention. So the question is what, what we want to look at multiple places in the sentence at once? It's possible to do that, you know, with self attention, with normal self attention. But think about this. Where do you end up looking in self attention? You end up looking where the dot products of XI, your q matrix transpose your key matrix XJ is high. So those are sort of the XIJ pairs, those are the IJ pairs that end up interacting with each other. But maybe for some query, for some word in the out, in, in, for some word you want to focus on different other words in the sentence for different reasons. The way that you can encode this is by having multiple query key and value matrices, which all encode different things about the XI. They all trans, are learned different transformations. So instead of a single q, a single K, and a single V, what we get are a Q sub L, K sub L, V sub L, all of a different dimensionality now. So by their dimensionality D by D over H, where H is the number of heads. So they're going to still apply to the X matrix, but they're going to transform it to a smaller dimensionality D by H. And then each attention head is going to perform attention independently. It's like you just did it a whole bunch of times. Right? So output L is equal to softmax of, you know, here's your QK, but now it's in L form. So now you have X, VL, and now you have sort of these indexed outputs. And in order to sort of have the output dimensionality be equal to the input dimensionality and sort of mixed things around, combine all the information from the different heads, you concatenate the heads. And then through output H, stack them together. Now the dimensionality of this is equal to the dimensionality of X again. And then we use a learned matrix Y, in order to sort of do the mixing Y is D by D. And that's the output of multi headed attention, multi headed self attention. And so because different, so each head gets to look at different things, right? Because they can all sort of the linear transformations can you can say focus on different parts of the X vectors. And the value vectors also get to be different as well. So pictorially, this is what we had before single headed attention. You had X multiplied by Q in order to get XQ. And what's interesting, and you can see this, you know, you can see this from this diagram, I think, is that multi headed attention doesn't necessarily have to be more, more work. And we saw that the QK and V matrices in multi headed attention have a lower output dimensionality. So here's two of them right here. Here's Q1 and Q2. The same size is Q. And then you get outputs XQ1 and XQ2. And so you're effectively doing the same amount of computation as before. But now you're sort of doing, you have different attention distributions for each of the different heads. This is pretty cool. So those are the main modeling differences, right? We did key query value attention. That's how that's how we got the key queries and values from the X vectors. And we saw how to implement that in the matrices that we're looking at. And then we looked at the multi headed attention, which allows us to look in different places in the sequence to in order to have more flexibility within a given layer. Now we're going to talk about our training tricks. These are really important. It turns out. And so, yeah, maybe thinking about them, I think, is something that we don't do enough in the field. And so let's really walk through them. So residual connections residual connections have been around residual connections. You can think of them as helping the model train better for number number of reasons. Let's look at what they're doing first. Our residual connection looks like this. So you have a normal layer. X in some layer, IIs representing sort of the layer in depth in the network. So X i is equal to some layer of X i minus one. So you had, right, you had, I don't know what this layer is doing necessarily, but this layer is a function of the previous layer. Okay. And so you got this. So again, I want to abstract over what the layer is doing, but you just pass it through. So the actual connection is doing something very simple. It's saying, okay, I'm going to take the function I was computing at my previous layer before, and then I'm going to add it to the previous layer. So now, X i is not equal to layer of X i minus one. It's equal to X i minus one plus layer of X i minus one. This is it. These are residual connections. And the intuition, right, is that like before you started learning anything sort of, you have this notion that you should be learning only how layer i should be different from layer i minus one. And instead of learning from scratch, what it should look like. So this value here, layer of X i minus one, should be something in some sense. And you have to learn how it's different from the previous layer. This is sort of a nice inducted bias. So here, you can kind of represent it as you have this layer. X i minus one goes to the layer. It also goes around and just gets added in. Now, think about the gradients, right. We talk about vanishing gradients. There are problem. The gradient of this connection here is beautiful, right. Even if everything is saturating, all of your sigmoids are saturating or your ray loos are all negative. So the gradients are all zero. You get gradients propagating back through the rest of the network anyway through this connection here. That's pretty cool. Turns out to be massively useful. And just to take a quick visualization, this plot just never ceases to look really, really interesting. Here is sort of a visualization of a loss landscape. So each sort of point in the 2D plane is like a, is a sort of a setting of a parameters of your network. And then sort of the z-axis is the loss of the network that is being optimized for, right. And here's a network with no residuals. And you have to have to gradient descent. And you sort of have to find a local minimum. And it's really hard to find the nice local minimum. And then with the residual network, you know, it's much smoother. So you can imagine how is the cast of gradient descent is sort of walking down here to this nice, very low local minimum. This is a paper that was trying to explain why residual connections are so useful. So this might be an intuition that might be useful for you. So this is, you know, this is a so called loss landscape. So those are residual connections. And it's, they seem simple, but a lot of simple ideas end up being super useful in deep learning. So in layer normalization, we're doing something sort of similar. We're trying to help the network train better. But we're doing it via a pretty different intuition. So layer normalization is thought to say, at different times in my network, when I'm training it, I'm doing the forward pass. There's a lot of variation in what the forward pass looks like. And a lot of is uninformative. And that can harm training. But if we normalize within a layer to a single to unit mean and standard deviation, then that sort of cuts down on all this sort of uninformative variation. And the informative variation sort of how the units were different from each other is maintained. So it's also thought that the successive layer norm, and there's been a lot of successive layer norm has been due actually to helping normalize the gradients of each layer. This is recent work. So let's talk about how it's implemented. So we're going to go back to X and not going to index it here. So just X is some vector, some word vector in in our transformer. We're going to compute an estimate of the mean. Just by summing the hidden units, we're going to compute an estimate of the standard deviation. Similarly, so like you've taken a single RDE vector, you just sum them, you compute the mean, you estimate the mean, you estimate the standard deviation. Now, you also, potentially, and this is optional, learn element wise, gain and bias parameters to try to sort of rescale things if certain hidden units sort of should have larger value in general, or should be multiplicatively larger in general. So these are vectors in RDE, just like X was a vector in RDE. And then here's what layer normalization computes. You have your output, which is going to be in RDE, just like your input. And you take your vector X, you subtract the mean from all of them, you divide by standard deviation. So you add an epsilon that's small in order if the standard deviation becomes very small, you don't want this to denominator to become too, too, too small because then you get huge numbers and then your network goes to NAN and doesn't train. So you have some sort of tolerance there. And then so you normalize there, and then our element wise gain and bias, now remember this fraction, X is a vector, everything is being done sort of element wise here, right? So this is our D, and then you have this element wise multiplication, this how to mark product with your gain, then you add the bias. Whether the gain and bias are necessary is unclear, this paper here suggests that they're not helpful, but they're frequently used. So this is sort of an engineering question at this point, and a science question, whether we can figure out why in general. But yes, that's layer normalization, and it ends up being very important in transformers, you remove it, and they really don't train very well. Okay, so that's our second trick. The third trick is probably the simplest one, but it's useful to know, and it's just, you can call it scaled dot product attention, because we're going to scale the dot products, like so. Okay, so what we're going to do is we're going to have this intuition that our dimensionality D, and really big neural networks, is going to become very large. So maybe our hidden layer in our transformer is a thousand or 2000 or 3000 anyway, it gets big. And when the dimensionality becomes large, the dot products between vectors tend to become large. So for example, if you take the dot product between two random vectors in RD, it grows quite quickly, their dot product grows quite quickly. Now, are the vectors random in transformers? Well, they're not uniform random, but you can imagine there's sort of a lot of variation, and in general, as the dimensionality is growing, all these dot products are getting pretty big. And this can become a problem for the following reason, right? We're taking all these dot products directly, and taking them putting them into the softmax. So if there's variation in the dot products, and some of them are very large, then the softmax can become very peaky, putting most of its probability mass on a small number of things, which makes the gradient small for everything else, effectively, right? Because the softmax is trying to be, well, it's a soft arg max, right? So it's sort of saying, which one of these is like the max, or, you know, weight these sort of relative to how close they are to the max of the function. And so if some of them are very, very large, you sort of just zero out the connections to everything that's not being attended to that has low probability distribution, and then they don't get gradients. And so here is the sil<|ar|><|translate|> And so here's the sil<|ar|><|translate|> And all I'm going to do is, well, the things that I'm going to dot together are vectors of dimensionality D over H, because of the multi-headed attention again. again. And in order to stop them from growing the doc products from growing too large, I'm just going to divide all of my scores. So remember up here, xq, k top, x top is a t by t matrix of scores. I'm going to divide them all by d over h. And as d grows, d over h grows, right? And so your doc products don't grow and this ends up being helpful as well. Okay. Any questions? Yeah. John, could you go through interesting questions? When you're doing the decoder attention, do you only do the maximum in the first layer or do you do the maximum in the decoder? Yeah, nice. So if we were to only do masking in the first layer, we would get information leakage in the later layers. So if we look at this, if we were to look at this diagram again, right? So here's the first layer of the decoder. And we said that there's masking, right? And you're able to look at any of the encoder states and you're only able to look at the previous words in the decoder. In the second layer, if I'm suddenly allowed to look at all of the future words now, hey, even though I didn't in the first layer, it's just as good that I can in the second layer. And so I can just learn to look right at what my word is supposed to be. So every single layer of the decoder has to have that masking or it's sort of moot. Like it says if you didn't mask it at all effectively. Thanks. Okay, so scaled dot product in the bag. We've got it. So let's look back at our full transformer encoder decoder framework. We've looked at the encoder blocks themselves. So let's sort of expand one of these zoom in enhance. And we've got our word embedding position representations. And first we put it through a multi-headed attention. So we've seen that. We put it through a residual layer and layer norm. So, right? So you have the word embedding to the piston representations going through the residual connection here. And also going through multi-headed attention. Add them layer norm. Next, you put the result of that through a feed forward network. There should be an error between the feed forward and the next residual layer. But the output of this residual layer norm is added into that residual in layer norm along with the output of the feed forward. And then the output of this residual in layer norm is the output of the transformer encoder block. So when we had each of these encoders here internally each one of them was just this. And we've seen all these building blocks before. And this is multi-headed scaled dot product attention. I admit the scaled word. So this is the block. And notice interestingly how you're doing residual layer norm after the initial multi-headed attention as well as after the feed forward. So each one of these is just identical, right? Different parameters for the different layers. But the same things that we've seen. Now let's look at the transformer decoder block. So this is actually more complex. In particular you've got that masked multi-head self-attention. And now remember this is not just for the first one. This is for all of the transformer blocks. So you've got masked multi-headed self-attention where we can't look at the future because we've added negative infinity to the negative infinity to the affinity scores. Residual in layer norm like we did for the encoder. Now we've got multi-head cross-attention. So this connection to the transformer encoder. This is actually a lot like what we saw in attention so far, right? We're attending from the decoder to the encoder. So we actually in each transformer decoder block we've got two different attention functions going on. So we do the cross-attention. We add the result to the residual in layer norm. Two the next residual in layer norm along with that of the multi-head cross-attention. And only after both of those applications of attention. Next we do the feed forward and residual and layer norm where the residual is coming. So the xi minus 1 is the residual in layer norm here goes into this one along with the feed forward. And so you can think of the residual in layer norm is coming after each of the interesting things we're doing. We're doing one interesting thing here. Multi-head masked self-attention. We've got cross-attention after each one. Do residual in layer norm. Help the gradients pass, et cetera, et cetera. And then the output of this residual in layer norm is the output of the transformer decoder. And so the only thing so far that we really haven't seen in this lecture is the multi-head cross-attention. And I want to go over it. It is the same equations as the multi-headed self-attention, but the inputs are coming from different places. And so I want to be precise about it. Let's take a look. Cross-attention details. So right, self-attention recall is that when we're taking the keys, the queries, and the values of attention from the same information source like the same sentence, for example. And we saw last week attention from the decoder to the encoder. So this is going to look similar. Let's use some different notation. So we're going to have h1 to ht, the output vectors from the transformer encoder, which are all x i and r d. Now remember, this is the last transformer encoder here. You never attend to the middle encoder blocks. It's the output of the last encoder block. So those are the output vectors from the last transformer encoder block. And now we have z1 to zt, the input vectors from the transformer decoder. So here maybe that is, you know, the input is the word embedding is plus the position of representations. Or, right, it's actually the output of the previous transformer decoder. We're going to be the inputs for the next one. So, yeah, we've got our z1 to zt. And we're letting them be the same sequence like the nt and t, just for simplicity. These are also vectors z i and r d. And then the keys and the queries, sorry, the keys and the values are all drawn from the encoder. So when we're talking about attention, as allowing us to sort of access a memory, right, the memory is sort of what the value vectors are encoding. And the way that the values are sort of indexed or able to be accessed is through the keys. And then the queries are, you know, what you're, what you're using to try to look for something. Right, so we're looking into the encoder as a memory. And we're using keys from the decoder to figure out where to look for each one. So, pictorially, again, we can look at how cross-attention is computed in matrices like we did for self-attention. So we've got the same thing here before we had x. Now we have h. These are the encoder vectors. These are going to be rt by d. Likewise, we have z. Notice we have two of these before. Before we just had x, right, we had x because x was going to be for the keys, the queries, and the values. Now we have h and z. Both are in rt by d. And the output is going to be, well, you take your z for the queries, right, z is being multiplied by the queries. You take your h for the keys and your h for the v's. So you are trying to take the query, the query, key dot products, all t squared of them, in one matrix multiplication. So the purple is saying this is coming from the d-coder. The brown is saying, or is saying it's coming from the encoder. Now you've got your dot products, softmax them as you did before, and now your values are also coming from the encoder. So, again, same operation, different sources for the inputs. And now you've got your output, which again is just an average of the value vectors from the encoder hv, the average is determined by your weights. Okay, so results with transformers. First off was machine translation. So we built our entire encoder, decoder, transformer block, and how does it work? It works really well. So these are a bunch of machine translation systems that were out when the original attention is all you need, transformers paper came out. And first, you saw that transformers were getting really good blue scores. So this is on the workshop on machine translation 2014, English German and English French test sets. You get higher blue scores, which means better translations, right? Notice how our blue scores in this are higher than for assignment four, lots more training data here, for example. But then also not only do you get better blue scores, you also had more efficient training, right? And we had a lot of tricks that went into getting training to work better, right? So you have more efficient training here. Okay, so that's a nice result. That was in the original paper. You know, past that, there are a number of interesting results. Summarization is one of them. So because here's the result on summarization. These are sort of part of a larger summarization system. But you know, you have, I like this table because you have sort of seek to seek with attention, which we saw before. And it got perplexity lower, it's better with perplexity, higher is better with rouge on this wiki sum data set. And then sort of like a bunch of transformer models they tried. And sort of at a certain point it becomes transformers all the way down. And sort of the old standard of R&N sort of falls out of practice. And actually before too long, right, transformers became dominant for an entirely different reason, which was related more to their parallelizability. Because they're allowed you to pre-train on just a ton of data very quickly. And this has made them the de facto standard. So there's a lot of results recently with transformers include pre-training. And I'm sort of intentionally sort of excluding them from this lecture so that you come to the next lecture and learn about pre-training. But there's a popular aggregate benchmark. This took a bunch of very difficult tasks and said, you know, do well on all of them if you want to score highly on our leaderboard. And you know, the names of these models you can look up if you're interested, but all of them are transformer based after a certain point. The benchmarks call it glue. It has a successor called super glue. Everything is just transformers after a certain sort of time period. Partly because of their pre-training ability. Okay. Great. So we'll discuss pre-training more on Thursday. And so our transformers it. Like the way that we described the attention is all you need paper. So the transformer encoder to coder we saw was from that paper. And at some point, you know, we want to build new systems. What are some drawbacks? And we've already started. People have already started to build variants of transformers that will go into today. And you know, it definitely has issues that we can try to work on. So I can also take a question if anyone wants to ask one. I mean, is that a bit that something that there were several questions on was the scale dot product? And the questions included why square root of d divided by h as opposed to just d divided by h or any other function of d divided by h. And another one was that why do you need that at all given that later on? You're going to use lay and all. The second question is really interesting and not one that I had thought of before. Well, right. So even if the individual components are small, so let's start with the second question. Why does this matter even if you're going to use layer norm? You know, if layer norm is averaging everything out, say, making it unit standard deviation and mean, then actually, right, nothing is going to get too small in those vectors either. So when you have a very, very large vector, all with things aren't too small. Yeah. You're still going to have the norm of the dot products increase, I think. I think it's a good question. I hadn't thought about it too much. That's my off the cuff answer, but it's what I think about more. I think the answer is that the effect you get of kind of losing dynamic range as things get longer, but that's going to happen anyway and lay an norm. Can't fix that. It's sort of coming along too late. And therefore you gain by doing this scaling. I think so. But I think it's worth. Yeah. I think it's worth thinking about more. Why square root? Well, let's see. The norms of the dot product grows with O of D. And so when you square root one, no, I guess it's square scales with O of root D, I can't remember. There's a little note in the attention is all you need paper about why it's root D, but I actually can't take it off the top of my head here. So, but it is in that paper. Okay. Anything else before you go on? Great. All right. So what would you like to fix? You know, the thing that that shows up most frequently as a pain point in transformers is actually the quadratic compute in the self attention itself. So we're having all pairs of interactions. We had that T by T matrix that was computed by taking these dot products between all pairs of word vectors. And so even though we argue at the beginning of the class that we don't have this sort of temporal dependence in the computation graph that stops us from parallelizing things, we still need to do all that computation and that grows quadratically. For recurrent models, right, it only grew linearly. Every time you applied the RNN cell, you did sort of more work, but you're not adding quadratically to the amount of work you have to do as you get to longer sequences. Separately, position representations. I mean, the absolute position of a word is just not, maybe not the best way to represent the structure of a sentence. And so there have been these two, you know, among other advancements in that that I won't be able to get into today, but you can take a look at these papers and the papers that cite them. There are other ways to represent position. People are working on it. But I want to focus more today on the problem of the quadratic compute. So how do we get, like, how do we reason about this? Why is this a problem? Right, so it's highly parallelizable, but we still have to do these operations. We have t squared, that's the sequence length, and then d is the dimensionality. And so in computing this matrix, we have o of t squared d computations that our GPU needs to chunk through. If we think of d is at the round of thousand, or two, or three thousand, if we had sort of single, shortish sentences, then maybe t is like 30-ish, and then t squared is 900, so it's like, yeah, it's actually not that big a deal. And in practice, for a lot of models, we'll set an actual bound like 512. So if your document is longer than 512 words, you're out of luck. You're chunked it or something. But what if we want to work on documents that are 10,000 words or greater, 10,000 squared is not feasible. So we have to somehow remove the dependence on t squared if we're going to work with these. There are a couple of ways that have been taught to do this. This is all very, very recent work, and it's only a smattering of the efforts that have come up. So the question is, can we build models like transformers that get away without the o of t squared, all pairs interactions cost? One example is the linformer. And the idea here is that you're going to actually map the sequence length dimension to a lower dimensional space for values and keys. So you had values, keys and queries, and you had your normal linear layers. Now you're going to project to a much lower dimension than the sequence length. And in doing so, you're sort of getting rid of that t by mapping it to something smaller, you're just saying, combine all the information from all these time steps into something that's lower dimensional. And so in this plot from the paper, as the sequence length goes from 512, the batch size of 128 to the sequence length being 65,000 with the batch size of 1, you get the transformer inference time growing very large, and then the linformer with various bottleneck dimensionalities, keys 128, 256, and doing much, much better. A separate option has been to take a totally different take on can we get away without these all pairs interactions, which is the following. Do we need to even try to compute all pairs of interactions if we can do sort of a bunch of other stuff that's going to be more efficient to compute? So like looking at local windows, we know that's useful, but not sufficient in some sense. Looking at everything, so if you were to just take like an average of vectors, just all the averaging of vectors, you don't need to compute interactions for that. And if you look at sort of random pairs, you don't need to take all that much time to compute that as well. And so what this paper did is they did all of them. So you have random attention, you have a word window attention where you're looking at your local neighbors, and you have sort of global attention where you're sort of, you know, attending without interacting with stuff, attending broadly over the whole sequence, you do a whole bunch of it, right, and you end up being able to approximate a lot of good things. These are not, you know, necessarily the answer, the normal transformer variant is by far the most popular currently, but it's a fascinating question to look into. So now as the time, more or less expires, I'll say we're working on pre-training on Thursday, good luck on assignment four, and I remember to work on your project proposal. I think we have time for a final question if anyone wants to. Are you a user or a member of the Santa Fe performance? It's a good question. Yeah, I, I mean, I believe still places in reinforcement learning. I mean, places where the recurrent inducted bias is, is clearly well specified or useful. It was a conversation like, I don't know of places in, in NLP where people are still broadly using RNNs. It was thought for a while that transformers took a lot more data to train than RNNs, and so you sort of should use RNNs on smaller data problems, but with pre-training, I'm not sure that that's the case. I think the answer is yes, there are still use cases, but it should be where the recurrent seems to really be the thing that is winning you something as opposed to like maybe needing more data or for transformers, because it seems like that might not actually be the case even though we thought so back in like 2017.", "segments": [{"id": 0, "seek": 0, "start": 0.0, "end": 15.200000000000001, "text": " Hi everyone. Welcome to CS224N, Lecture 9, Self-Attention and Transformers. If I am not", "tokens": [2421, 1518, 13, 4027, 281, 9460, 7490, 19, 45, 11, 37196, 540, 1722, 11, 16348, 12, 38151, 1251, 293, 27938, 433, 13, 759, 286, 669, 406], "temperature": 0.0, "avg_logprob": -0.22184459786666066, "compression_ratio": 1.3641025641025641, "no_speech_prob": 0.10436317324638367}, {"id": 1, "seek": 0, "start": 15.200000000000001, "end": 21.48, "text": " able to be heard right now, please send a message in the chat because I can't see anyone.", "tokens": [1075, 281, 312, 2198, 558, 586, 11, 1767, 2845, 257, 3636, 294, 264, 5081, 570, 286, 393, 380, 536, 2878, 13], "temperature": 0.0, "avg_logprob": -0.22184459786666066, "compression_ratio": 1.3641025641025641, "no_speech_prob": 0.10436317324638367}, {"id": 2, "seek": 0, "start": 21.48, "end": 28.240000000000002, "text": " But I'm excited to get into the content for today. We'll be talking about self-attention", "tokens": [583, 286, 478, 2919, 281, 483, 666, 264, 2701, 337, 965, 13, 492, 603, 312, 1417, 466, 2698, 12, 1591, 1251], "temperature": 0.0, "avg_logprob": -0.22184459786666066, "compression_ratio": 1.3641025641025641, "no_speech_prob": 0.10436317324638367}, {"id": 3, "seek": 2824, "start": 28.24, "end": 36.64, "text": " and transformers. Let us dive into the lecture plan and we'll talk about some sort of to-do's", "tokens": [293, 4088, 433, 13, 961, 505, 9192, 666, 264, 7991, 1393, 293, 321, 603, 751, 466, 512, 1333, 295, 281, 12, 2595, 311], "temperature": 0.0, "avg_logprob": -0.16785296149875806, "compression_ratio": 1.6820276497695852, "no_speech_prob": 5.139675340615213e-05}, {"id": 4, "seek": 2824, "start": 36.64, "end": 43.68, "text": " for the course as well. So we'll start with where we were back last week with recurrence,", "tokens": [337, 264, 1164, 382, 731, 13, 407, 321, 603, 722, 365, 689, 321, 645, 646, 1036, 1243, 365, 18680, 10760, 11], "temperature": 0.0, "avg_logprob": -0.16785296149875806, "compression_ratio": 1.6820276497695852, "no_speech_prob": 5.139675340615213e-05}, {"id": 5, "seek": 2824, "start": 43.68, "end": 48.08, "text": " recurrent neural networks. And we'll talk about a movement from recurrence to attention", "tokens": [18680, 1753, 18161, 9590, 13, 400, 321, 603, 751, 466, 257, 3963, 490, 18680, 10760, 281, 3202], "temperature": 0.0, "avg_logprob": -0.16785296149875806, "compression_ratio": 1.6820276497695852, "no_speech_prob": 5.139675340615213e-05}, {"id": 6, "seek": 2824, "start": 48.08, "end": 54.0, "text": " based on LP models. We talked about attention and we're going to just go all in on attention.", "tokens": [2361, 322, 38095, 5245, 13, 492, 2825, 466, 3202, 293, 321, 434, 516, 281, 445, 352, 439, 294, 322, 3202, 13], "temperature": 0.0, "avg_logprob": -0.16785296149875806, "compression_ratio": 1.6820276497695852, "no_speech_prob": 5.139675340615213e-05}, {"id": 7, "seek": 5400, "start": 54.0, "end": 58.480000000000004, "text": " We'll introduce the transformer model, which is a particular type of attention based model.", "tokens": [492, 603, 5366, 264, 31782, 2316, 11, 597, 307, 257, 1729, 2010, 295, 3202, 2361, 2316, 13], "temperature": 0.0, "avg_logprob": -0.1503951159390536, "compression_ratio": 1.5650684931506849, "no_speech_prob": 0.00020327497622929513}, {"id": 8, "seek": 5400, "start": 58.480000000000004, "end": 63.24, "text": " It's very popular. You need to know it. You're going to learn it. We'll talk about some great", "tokens": [467, 311, 588, 3743, 13, 509, 643, 281, 458, 309, 13, 509, 434, 516, 281, 1466, 309, 13, 492, 603, 751, 466, 512, 869], "temperature": 0.0, "avg_logprob": -0.1503951159390536, "compression_ratio": 1.5650684931506849, "no_speech_prob": 0.00020327497622929513}, {"id": 9, "seek": 5400, "start": 63.24, "end": 69.24, "text": " results with transformers and then some drawbacks and variance and sort of very recent work", "tokens": [3542, 365, 4088, 433, 293, 550, 512, 2642, 17758, 293, 21977, 293, 1333, 295, 588, 5162, 589], "temperature": 0.0, "avg_logprob": -0.1503951159390536, "compression_ratio": 1.5650684931506849, "no_speech_prob": 0.00020327497622929513}, {"id": 10, "seek": 5400, "start": 69.24, "end": 76.92, "text": " on improving them. So some reminders before we jump in. Assignment 4 is due. The mid-quarter", "tokens": [322, 11470, 552, 13, 407, 512, 43458, 949, 321, 3012, 294, 13, 6281, 41134, 1017, 307, 3462, 13, 440, 2062, 12, 43363], "temperature": 0.0, "avg_logprob": -0.1503951159390536, "compression_ratio": 1.5650684931506849, "no_speech_prob": 0.00020327497622929513}, {"id": 11, "seek": 5400, "start": 76.92, "end": 83.16, "text": " feedback survey is due Tuesday, February 16th. You get some small number of points for", "tokens": [5824, 8984, 307, 3462, 10017, 11, 8711, 3165, 392, 13, 509, 483, 512, 1359, 1230, 295, 2793, 337], "temperature": 0.0, "avg_logprob": -0.1503951159390536, "compression_ratio": 1.5650684931506849, "no_speech_prob": 0.00020327497622929513}, {"id": 12, "seek": 8316, "start": 83.16, "end": 87.08, "text": " doing that and we really appreciate your feedback on what we've done well, what we can improve", "tokens": [884, 300, 293, 321, 534, 4449, 428, 5824, 322, 437, 321, 600, 1096, 731, 11, 437, 321, 393, 3470], "temperature": 0.0, "avg_logprob": -0.15034812755799026, "compression_ratio": 1.792929292929293, "no_speech_prob": 0.00023033670731820166}, {"id": 13, "seek": 8316, "start": 87.08, "end": 95.24, "text": " on. And then, final project proposal is also due. One note on the proposals. Part of", "tokens": [322, 13, 400, 550, 11, 2572, 1716, 11494, 307, 611, 3462, 13, 1485, 3637, 322, 264, 20198, 13, 4100, 295], "temperature": 0.0, "avg_logprob": -0.15034812755799026, "compression_ratio": 1.792929292929293, "no_speech_prob": 0.00023033670731820166}, {"id": 14, "seek": 8316, "start": 95.24, "end": 101.96, "text": " the goal of the proposal is to, you know, or let's say the main part of the goal of the", "tokens": [264, 3387, 295, 264, 11494, 307, 281, 11, 291, 458, 11, 420, 718, 311, 584, 264, 2135, 644, 295, 264, 3387, 295, 264], "temperature": 0.0, "avg_logprob": -0.15034812755799026, "compression_ratio": 1.792929292929293, "no_speech_prob": 0.00023033670731820166}, {"id": 15, "seek": 8316, "start": 101.96, "end": 108.24, "text": " proposal is to give you feedback on the idea that you have presented and make sure that", "tokens": [11494, 307, 281, 976, 291, 5824, 322, 264, 1558, 300, 291, 362, 8212, 293, 652, 988, 300], "temperature": 0.0, "avg_logprob": -0.15034812755799026, "compression_ratio": 1.792929292929293, "no_speech_prob": 0.00023033670731820166}, {"id": 16, "seek": 10824, "start": 108.24, "end": 117.47999999999999, "text": " it is a viable option for a final project and make sure we kind of recenter if not. And", "tokens": [309, 307, 257, 22024, 3614, 337, 257, 2572, 1716, 293, 652, 988, 321, 733, 295, 5162, 260, 498, 406, 13, 400], "temperature": 0.0, "avg_logprob": -0.15940708915392557, "compression_ratio": 1.5814977973568283, "no_speech_prob": 4.983738836017437e-05}, {"id": 17, "seek": 10824, "start": 117.47999999999999, "end": 123.75999999999999, "text": " so we want to get feedback to you very quickly on that. Okay. All right. So with that, let's", "tokens": [370, 321, 528, 281, 483, 5824, 281, 291, 588, 2661, 322, 300, 13, 1033, 13, 1057, 558, 13, 407, 365, 300, 11, 718, 311], "temperature": 0.0, "avg_logprob": -0.15940708915392557, "compression_ratio": 1.5814977973568283, "no_speech_prob": 4.983738836017437e-05}, {"id": 18, "seek": 10824, "start": 123.75999999999999, "end": 133.0, "text": " start in on the content of this week's lecture. So we were in this place in MLP as of last", "tokens": [722, 294, 322, 264, 2701, 295, 341, 1243, 311, 7991, 13, 407, 321, 645, 294, 341, 1081, 294, 21601, 47, 382, 295, 1036], "temperature": 0.0, "avg_logprob": -0.15940708915392557, "compression_ratio": 1.5814977973568283, "no_speech_prob": 4.983738836017437e-05}, {"id": 19, "seek": 10824, "start": 133.0, "end": 137.4, "text": " week where we had recurrent neural networks sort of for a lot of things that you wanted", "tokens": [1243, 689, 321, 632, 18680, 1753, 18161, 9590, 1333, 295, 337, 257, 688, 295, 721, 300, 291, 1415], "temperature": 0.0, "avg_logprob": -0.15940708915392557, "compression_ratio": 1.5814977973568283, "no_speech_prob": 4.983738836017437e-05}, {"id": 20, "seek": 13740, "start": 137.4, "end": 144.44, "text": " to do. So it's around 2016 and the strategy if you want to build a strong MLP model is", "tokens": [281, 360, 13, 407, 309, 311, 926, 6549, 293, 264, 5206, 498, 291, 528, 281, 1322, 257, 2068, 21601, 47, 2316, 307], "temperature": 0.0, "avg_logprob": -0.16067985066196375, "compression_ratio": 1.6717557251908397, "no_speech_prob": 0.00011059274402214214}, {"id": 21, "seek": 13740, "start": 144.44, "end": 148.64000000000001, "text": " you have, you know, sentences that you need to encode and you have like a bidirectional", "tokens": [291, 362, 11, 291, 458, 11, 16579, 300, 291, 643, 281, 2058, 1429, 293, 291, 362, 411, 257, 12957, 621, 41048], "temperature": 0.0, "avg_logprob": -0.16067985066196375, "compression_ratio": 1.6717557251908397, "no_speech_prob": 0.00011059274402214214}, {"id": 22, "seek": 13740, "start": 148.64000000000001, "end": 155.28, "text": " LSTM say. And, you know, maybe it looks a little bit like this pictographically. And maybe", "tokens": [441, 6840, 44, 584, 13, 400, 11, 291, 458, 11, 1310, 309, 1542, 257, 707, 857, 411, 341, 2317, 3108, 984, 13, 400, 1310], "temperature": 0.0, "avg_logprob": -0.16067985066196375, "compression_ratio": 1.6717557251908397, "no_speech_prob": 0.00011059274402214214}, {"id": 23, "seek": 13740, "start": 155.28, "end": 158.72, "text": " it's a source sentence in a translation, for example. We saw machine translation and", "tokens": [309, 311, 257, 4009, 8174, 294, 257, 12853, 11, 337, 1365, 13, 492, 1866, 3479, 12853, 293], "temperature": 0.0, "avg_logprob": -0.16067985066196375, "compression_ratio": 1.6717557251908397, "no_speech_prob": 0.00011059274402214214}, {"id": 24, "seek": 13740, "start": 158.72, "end": 163.32, "text": " then you define your output which is maybe a sequence of words which is the target, you", "tokens": [550, 291, 6964, 428, 5598, 597, 307, 1310, 257, 8310, 295, 2283, 597, 307, 264, 3779, 11, 291], "temperature": 0.0, "avg_logprob": -0.16067985066196375, "compression_ratio": 1.6717557251908397, "no_speech_prob": 0.00011059274402214214}, {"id": 25, "seek": 16332, "start": 163.32, "end": 168.6, "text": " know, translation that you're trying to predict or maybe it's a parse tree or it's a summary.", "tokens": [458, 11, 12853, 300, 291, 434, 1382, 281, 6069, 420, 1310, 309, 311, 257, 48377, 4230, 420, 309, 311, 257, 12691, 13], "temperature": 0.0, "avg_logprob": -0.15135897908891952, "compression_ratio": 1.75, "no_speech_prob": 2.3183982193586417e-05}, {"id": 26, "seek": 16332, "start": 168.6, "end": 176.79999999999998, "text": " And you use an LSTM with one direction to generate it. And this works really well. We", "tokens": [400, 291, 764, 364, 441, 6840, 44, 365, 472, 3513, 281, 8460, 309, 13, 400, 341, 1985, 534, 731, 13, 492], "temperature": 0.0, "avg_logprob": -0.15135897908891952, "compression_ratio": 1.75, "no_speech_prob": 2.3183982193586417e-05}, {"id": 27, "seek": 16332, "start": 176.79999999999998, "end": 181.16, "text": " did, we used these architectures to do all kinds of interesting things. But one thing", "tokens": [630, 11, 321, 1143, 613, 6331, 1303, 281, 360, 439, 3685, 295, 1880, 721, 13, 583, 472, 551], "temperature": 0.0, "avg_logprob": -0.15135897908891952, "compression_ratio": 1.75, "no_speech_prob": 2.3183982193586417e-05}, {"id": 28, "seek": 16332, "start": 181.16, "end": 185.51999999999998, "text": " that we said, we talked about this information sort of bottleneck that you're trying to encode", "tokens": [300, 321, 848, 11, 321, 2825, 466, 341, 1589, 1333, 295, 44641, 547, 300, 291, 434, 1382, 281, 2058, 1429], "temperature": 0.0, "avg_logprob": -0.15135897908891952, "compression_ratio": 1.75, "no_speech_prob": 2.3183982193586417e-05}, {"id": 29, "seek": 16332, "start": 185.51999999999998, "end": 190.24, "text": " maybe a very long sequence and sort of the very last vector in your or in one vector in", "tokens": [1310, 257, 588, 938, 8310, 293, 1333, 295, 264, 588, 1036, 8062, 294, 428, 420, 294, 472, 8062, 294], "temperature": 0.0, "avg_logprob": -0.15135897908891952, "compression_ratio": 1.75, "no_speech_prob": 2.3183982193586417e-05}, {"id": 30, "seek": 19024, "start": 190.24, "end": 196.52, "text": " your encoder. And so we used attention as this mechanism to take, you know, a representation", "tokens": [428, 2058, 19866, 13, 400, 370, 321, 1143, 3202, 382, 341, 7513, 281, 747, 11, 291, 458, 11, 257, 10290], "temperature": 0.0, "avg_logprob": -0.15317711740169884, "compression_ratio": 1.8089430894308942, "no_speech_prob": 4.9076676077675074e-05}, {"id": 31, "seek": 19024, "start": 196.52, "end": 201.48000000000002, "text": " of from our decoder and sort of look back and treat the encoded representations as a", "tokens": [295, 490, 527, 979, 19866, 293, 1333, 295, 574, 646, 293, 2387, 264, 2058, 12340, 33358, 382, 257], "temperature": 0.0, "avg_logprob": -0.15317711740169884, "compression_ratio": 1.8089430894308942, "no_speech_prob": 4.9076676077675074e-05}, {"id": 32, "seek": 19024, "start": 201.48000000000002, "end": 205.60000000000002, "text": " memory that we can back with that we can reference and sort of pick out what's important", "tokens": [4675, 300, 321, 393, 646, 365, 300, 321, 393, 6408, 293, 1333, 295, 1888, 484, 437, 311, 1021], "temperature": 0.0, "avg_logprob": -0.15317711740169884, "compression_ratio": 1.8089430894308942, "no_speech_prob": 4.9076676077675074e-05}, {"id": 33, "seek": 19024, "start": 205.60000000000002, "end": 212.68, "text": " to any given time. And that was attention. And this week we're going to do something slightly", "tokens": [281, 604, 2212, 565, 13, 400, 300, 390, 3202, 13, 400, 341, 1243, 321, 434, 516, 281, 360, 746, 4748], "temperature": 0.0, "avg_logprob": -0.15317711740169884, "compression_ratio": 1.8089430894308942, "no_speech_prob": 4.9076676077675074e-05}, {"id": 34, "seek": 19024, "start": 212.68, "end": 218.4, "text": " different. So we learned about sequence to sequence models, the encoder, decoder way", "tokens": [819, 13, 407, 321, 3264, 466, 8310, 281, 8310, 5245, 11, 264, 2058, 19866, 11, 979, 19866, 636], "temperature": 0.0, "avg_logprob": -0.15317711740169884, "compression_ratio": 1.8089430894308942, "no_speech_prob": 4.9076676077675074e-05}, {"id": 35, "seek": 21840, "start": 218.4, "end": 224.56, "text": " of thinking about problems more or less in order to deal with this idea of, you know, building", "tokens": [295, 1953, 466, 2740, 544, 420, 1570, 294, 1668, 281, 2028, 365, 341, 1558, 295, 11, 291, 458, 11, 2390], "temperature": 0.0, "avg_logprob": -0.1473753051002427, "compression_ratio": 1.8571428571428572, "no_speech_prob": 6.301787652773783e-05}, {"id": 36, "seek": 21840, "start": 224.56, "end": 229.56, "text": " a machine translation system that's end to end differentiable, right? And so this", "tokens": [257, 3479, 12853, 1185, 300, 311, 917, 281, 917, 819, 9364, 11, 558, 30, 400, 370, 341], "temperature": 0.0, "avg_logprob": -0.1473753051002427, "compression_ratio": 1.8571428571428572, "no_speech_prob": 6.301787652773783e-05}, {"id": 37, "seek": 21840, "start": 229.56, "end": 233.96, "text": " is sort of a really interesting way of thinking about problems. What we'll do this week is", "tokens": [307, 1333, 295, 257, 534, 1880, 636, 295, 1953, 466, 2740, 13, 708, 321, 603, 360, 341, 1243, 307], "temperature": 0.0, "avg_logprob": -0.1473753051002427, "compression_ratio": 1.8571428571428572, "no_speech_prob": 6.301787652773783e-05}, {"id": 38, "seek": 21840, "start": 233.96, "end": 239.36, "text": " different. We're not trying to motivate sort of an entirely new way of thinking about", "tokens": [819, 13, 492, 434, 406, 1382, 281, 28497, 1333, 295, 364, 7696, 777, 636, 295, 1953, 466], "temperature": 0.0, "avg_logprob": -0.1473753051002427, "compression_ratio": 1.8571428571428572, "no_speech_prob": 6.301787652773783e-05}, {"id": 39, "seek": 21840, "start": 239.36, "end": 243.76, "text": " problems like machine translation. Instead, we're going to take the building blocks that", "tokens": [2740, 411, 3479, 12853, 13, 7156, 11, 321, 434, 516, 281, 747, 264, 2390, 8474, 300], "temperature": 0.0, "avg_logprob": -0.1473753051002427, "compression_ratio": 1.8571428571428572, "no_speech_prob": 6.301787652773783e-05}, {"id": 40, "seek": 24376, "start": 243.76, "end": 249.39999999999998, "text": " we were using, you know, recurrent neural networks. And we're going to spend a lot of trial", "tokens": [321, 645, 1228, 11, 291, 458, 11, 18680, 1753, 18161, 9590, 13, 400, 321, 434, 516, 281, 3496, 257, 688, 295, 7308], "temperature": 0.0, "avg_logprob": -0.13321633295181695, "compression_ratio": 1.745019920318725, "no_speech_prob": 1.0284781637892593e-05}, {"id": 41, "seek": 24376, "start": 249.39999999999998, "end": 253.67999999999998, "text": " and error in the field trying to figure out if there are building blocks that just work", "tokens": [293, 6713, 294, 264, 2519, 1382, 281, 2573, 484, 498, 456, 366, 2390, 8474, 300, 445, 589], "temperature": 0.0, "avg_logprob": -0.13321633295181695, "compression_ratio": 1.745019920318725, "no_speech_prob": 1.0284781637892593e-05}, {"id": 42, "seek": 24376, "start": 253.67999999999998, "end": 261.28, "text": " better across a broad range of problems. So we'll just slot the new thing in for recurrent", "tokens": [1101, 2108, 257, 4152, 3613, 295, 2740, 13, 407, 321, 603, 445, 14747, 264, 777, 551, 294, 337, 18680, 1753], "temperature": 0.0, "avg_logprob": -0.13321633295181695, "compression_ratio": 1.745019920318725, "no_speech_prob": 1.0284781637892593e-05}, {"id": 43, "seek": 24376, "start": 261.28, "end": 267.52, "text": " neural networks and say, you know, voila, maybe it works better. And so I want to take", "tokens": [18161, 9590, 293, 584, 11, 291, 458, 11, 45565, 11, 1310, 309, 1985, 1101, 13, 400, 370, 286, 528, 281, 747], "temperature": 0.0, "avg_logprob": -0.13321633295181695, "compression_ratio": 1.745019920318725, "no_speech_prob": 1.0284781637892593e-05}, {"id": 44, "seek": 24376, "start": 267.52, "end": 273.48, "text": " us on this sort of journey to self attention networks. And we'll start with some", "tokens": [505, 322, 341, 1333, 295, 4671, 281, 2698, 3202, 9590, 13, 400, 321, 603, 722, 365, 512], "temperature": 0.0, "avg_logprob": -0.13321633295181695, "compression_ratio": 1.745019920318725, "no_speech_prob": 1.0284781637892593e-05}, {"id": 45, "seek": 27348, "start": 273.48, "end": 277.28000000000003, "text": " problems with recurrent neural networks. So we spent a bit of time trying to convince", "tokens": [2740, 365, 18680, 1753, 18161, 9590, 13, 407, 321, 4418, 257, 857, 295, 565, 1382, 281, 13447], "temperature": 0.0, "avg_logprob": -0.14877098660136379, "compression_ratio": 1.7205882352941178, "no_speech_prob": 3.119650864391588e-05}, {"id": 46, "seek": 27348, "start": 277.28000000000003, "end": 285.08000000000004, "text": " you that recurrent neural networks were very useful. Now I'm going to talk about reasons", "tokens": [291, 300, 18680, 1753, 18161, 9590, 645, 588, 4420, 13, 823, 286, 478, 516, 281, 751, 466, 4112], "temperature": 0.0, "avg_logprob": -0.14877098660136379, "compression_ratio": 1.7205882352941178, "no_speech_prob": 3.119650864391588e-05}, {"id": 47, "seek": 27348, "start": 285.08000000000004, "end": 291.88, "text": " why they can be improved. So we know that recurrent neural networks are enrolled left to", "tokens": [983, 436, 393, 312, 9689, 13, 407, 321, 458, 300, 18680, 1753, 18161, 9590, 366, 25896, 1411, 281], "temperature": 0.0, "avg_logprob": -0.14877098660136379, "compression_ratio": 1.7205882352941178, "no_speech_prob": 3.119650864391588e-05}, {"id": 48, "seek": 27348, "start": 291.88, "end": 298.36, "text": " right, quote, in air quotes, it could be right to left as well. So what does this mean?", "tokens": [558, 11, 6513, 11, 294, 1988, 19963, 11, 309, 727, 312, 558, 281, 1411, 382, 731, 13, 407, 437, 775, 341, 914, 30], "temperature": 0.0, "avg_logprob": -0.14877098660136379, "compression_ratio": 1.7205882352941178, "no_speech_prob": 3.119650864391588e-05}, {"id": 49, "seek": 29836, "start": 298.36, "end": 306.08000000000004, "text": " Or recurrent neural network encodes linear locality, right? So once I'm looking at tasty", "tokens": [1610, 18680, 1753, 18161, 3209, 2058, 4789, 8213, 1628, 1860, 11, 558, 30, 407, 1564, 286, 478, 1237, 412, 11535], "temperature": 0.0, "avg_logprob": -0.15185415744781494, "compression_ratio": 1.8385964912280701, "no_speech_prob": 5.560107820201665e-05}, {"id": 50, "seek": 29836, "start": 306.08000000000004, "end": 310.32, "text": " in this phrase, I'm about to look at pizza, or if I'm going in the other direction,", "tokens": [294, 341, 9535, 11, 286, 478, 466, 281, 574, 412, 8298, 11, 420, 498, 286, 478, 516, 294, 264, 661, 3513, 11], "temperature": 0.0, "avg_logprob": -0.15185415744781494, "compression_ratio": 1.8385964912280701, "no_speech_prob": 5.560107820201665e-05}, {"id": 51, "seek": 29836, "start": 310.32, "end": 314.24, "text": " once I look at pizza, I'm about to look at tasty. And so it's very easy for their", "tokens": [1564, 286, 574, 412, 8298, 11, 286, 478, 466, 281, 574, 412, 11535, 13, 400, 370, 309, 311, 588, 1858, 337, 641], "temperature": 0.0, "avg_logprob": -0.15185415744781494, "compression_ratio": 1.8385964912280701, "no_speech_prob": 5.560107820201665e-05}, {"id": 52, "seek": 29836, "start": 314.24, "end": 318.56, "text": " meanings, for their presence in the sentence, to affect the meaning, to affect the representation", "tokens": [28138, 11, 337, 641, 6814, 294, 264, 8174, 11, 281, 3345, 264, 3620, 11, 281, 3345, 264, 10290], "temperature": 0.0, "avg_logprob": -0.15185415744781494, "compression_ratio": 1.8385964912280701, "no_speech_prob": 5.560107820201665e-05}, {"id": 53, "seek": 29836, "start": 318.56, "end": 323.56, "text": " of the other word. And this is actually quite useful because nearby words frequently", "tokens": [295, 264, 661, 1349, 13, 400, 341, 307, 767, 1596, 4420, 570, 11184, 2283, 10374], "temperature": 0.0, "avg_logprob": -0.15185415744781494, "compression_ratio": 1.8385964912280701, "no_speech_prob": 5.560107820201665e-05}, {"id": 54, "seek": 29836, "start": 323.56, "end": 327.76, "text": " do influence each other. That's practically one of the things we talked about with the", "tokens": [360, 6503, 1184, 661, 13, 663, 311, 15667, 472, 295, 264, 721, 321, 2825, 466, 365, 264], "temperature": 0.0, "avg_logprob": -0.15185415744781494, "compression_ratio": 1.8385964912280701, "no_speech_prob": 5.560107820201665e-05}, {"id": 55, "seek": 32776, "start": 327.76, "end": 333.59999999999997, "text": " distributional hypothesis as encoded by something like word-to-vec. But if words are", "tokens": [7316, 304, 17291, 382, 2058, 12340, 538, 746, 411, 1349, 12, 1353, 12, 303, 66, 13, 583, 498, 2283, 366], "temperature": 0.0, "avg_logprob": -0.1756017311759617, "compression_ratio": 1.5644444444444445, "no_speech_prob": 3.5906279663322493e-05}, {"id": 56, "seek": 32776, "start": 333.59999999999997, "end": 338.92, "text": " distant linearly, they can still interact with each other. This is something that we saw", "tokens": [17275, 43586, 11, 436, 393, 920, 4648, 365, 1184, 661, 13, 639, 307, 746, 300, 321, 1866], "temperature": 0.0, "avg_logprob": -0.1756017311759617, "compression_ratio": 1.5644444444444445, "no_speech_prob": 3.5906279663322493e-05}, {"id": 57, "seek": 32776, "start": 338.92, "end": 345.48, "text": " in dependency parsing. So if I have, say, the phrase, the chef, notice chef bolded here,", "tokens": [294, 33621, 21156, 278, 13, 407, 498, 286, 362, 11, 584, 11, 264, 9535, 11, 264, 10530, 11, 3449, 10530, 11928, 292, 510, 11], "temperature": 0.0, "avg_logprob": -0.1756017311759617, "compression_ratio": 1.5644444444444445, "no_speech_prob": 3.5906279663322493e-05}, {"id": 58, "seek": 32776, "start": 345.48, "end": 350.44, "text": " I'm running a recurrent neural network over this. And then the chef who, then I have this", "tokens": [286, 478, 2614, 257, 18680, 1753, 18161, 3209, 670, 341, 13, 400, 550, 264, 10530, 567, 11, 550, 286, 362, 341], "temperature": 0.0, "avg_logprob": -0.1756017311759617, "compression_ratio": 1.5644444444444445, "no_speech_prob": 3.5906279663322493e-05}, {"id": 59, "seek": 35044, "start": 350.44, "end": 359.0, "text": " long sequence that I'm going to encode. And then the word was, right? Maybe it is the", "tokens": [938, 8310, 300, 286, 478, 516, 281, 2058, 1429, 13, 400, 550, 264, 1349, 390, 11, 558, 30, 2704, 309, 307, 264], "temperature": 0.0, "avg_logprob": -0.1811197598775228, "compression_ratio": 1.4728260869565217, "no_speech_prob": 3.704249320435338e-05}, {"id": 60, "seek": 35044, "start": 359.0, "end": 366.2, "text": " chef who was. But in between I have O of sequence length, many steps of the computation that", "tokens": [10530, 567, 390, 13, 583, 294, 1296, 286, 362, 422, 295, 8310, 4641, 11, 867, 4439, 295, 264, 24903, 300], "temperature": 0.0, "avg_logprob": -0.1811197598775228, "compression_ratio": 1.4728260869565217, "no_speech_prob": 3.704249320435338e-05}, {"id": 61, "seek": 35044, "start": 366.2, "end": 375.04, "text": " I need to get to before chef and was can interact. Right? And so in the middle, things might", "tokens": [286, 643, 281, 483, 281, 949, 10530, 293, 390, 393, 4648, 13, 1779, 30, 400, 370, 294, 264, 2808, 11, 721, 1062], "temperature": 0.0, "avg_logprob": -0.1811197598775228, "compression_ratio": 1.4728260869565217, "no_speech_prob": 3.704249320435338e-05}, {"id": 62, "seek": 37504, "start": 375.04, "end": 385.20000000000005, "text": " go wrong. Maybe it's hard to learn things where they should interact. So in particular,", "tokens": [352, 2085, 13, 2704, 309, 311, 1152, 281, 1466, 721, 689, 436, 820, 4648, 13, 407, 294, 1729, 11], "temperature": 0.0, "avg_logprob": -0.1495267911390825, "compression_ratio": 1.641255605381166, "no_speech_prob": 2.6677855203161016e-05}, {"id": 63, "seek": 37504, "start": 385.20000000000005, "end": 389.12, "text": " it might be hard to learn long distance dependencies because we have gradient problems. We saw", "tokens": [309, 1062, 312, 1152, 281, 1466, 938, 4560, 36606, 570, 321, 362, 16235, 2740, 13, 492, 1866], "temperature": 0.0, "avg_logprob": -0.1495267911390825, "compression_ratio": 1.641255605381166, "no_speech_prob": 2.6677855203161016e-05}, {"id": 64, "seek": 37504, "start": 389.12, "end": 395.44, "text": " the LSTMs propagate gradients better than simple RNNs, but not perfectly. And so if chef and", "tokens": [264, 441, 6840, 26386, 48256, 2771, 2448, 1101, 813, 2199, 45702, 45, 82, 11, 457, 406, 6239, 13, 400, 370, 498, 10530, 293], "temperature": 0.0, "avg_logprob": -0.1495267911390825, "compression_ratio": 1.641255605381166, "no_speech_prob": 2.6677855203161016e-05}, {"id": 65, "seek": 37504, "start": 395.44, "end": 400.44, "text": " was are very far, it becomes hard to learn that they should interact. And the linear order", "tokens": [390, 366, 588, 1400, 11, 309, 3643, 1152, 281, 1466, 300, 436, 820, 4648, 13, 400, 264, 8213, 1668], "temperature": 0.0, "avg_logprob": -0.1495267911390825, "compression_ratio": 1.641255605381166, "no_speech_prob": 2.6677855203161016e-05}, {"id": 66, "seek": 40044, "start": 400.44, "end": 406.84, "text": " of words is sort of baked into the model. You have to unroll the RNN throughout the sequence.", "tokens": [295, 2283, 307, 1333, 295, 19453, 666, 264, 2316, 13, 509, 362, 281, 517, 3970, 264, 45702, 45, 3710, 264, 8310, 13], "temperature": 0.0, "avg_logprob": -0.1693778592486714, "compression_ratio": 1.6318181818181818, "no_speech_prob": 4.399169483804144e-05}, {"id": 67, "seek": 40044, "start": 406.84, "end": 412.28, "text": " And it's not really the right way to think about sentences necessarily, at least linear", "tokens": [400, 309, 311, 406, 534, 264, 558, 636, 281, 519, 466, 16579, 4725, 11, 412, 1935, 8213], "temperature": 0.0, "avg_logprob": -0.1693778592486714, "compression_ratio": 1.6318181818181818, "no_speech_prob": 4.399169483804144e-05}, {"id": 68, "seek": 40044, "start": 412.28, "end": 421.88, "text": " order isn't really how sentences are kind of structured. And so here you have chef. And", "tokens": [1668, 1943, 380, 534, 577, 16579, 366, 733, 295, 18519, 13, 400, 370, 510, 291, 362, 10530, 13, 400], "temperature": 0.0, "avg_logprob": -0.1693778592486714, "compression_ratio": 1.6318181818181818, "no_speech_prob": 4.399169483804144e-05}, {"id": 69, "seek": 40044, "start": 421.88, "end": 425.44, "text": " then you've got all this sort of computation in the middle, all those applications of the", "tokens": [550, 291, 600, 658, 439, 341, 1333, 295, 24903, 294, 264, 2808, 11, 439, 729, 5821, 295, 264], "temperature": 0.0, "avg_logprob": -0.1693778592486714, "compression_ratio": 1.6318181818181818, "no_speech_prob": 4.399169483804144e-05}, {"id": 70, "seek": 42544, "start": 425.44, "end": 430.76, "text": " recurrent weight matrix before you allow it to interact with was. And again, sort of", "tokens": [18680, 1753, 3364, 8141, 949, 291, 2089, 309, 281, 4648, 365, 390, 13, 400, 797, 11, 1333, 295], "temperature": 0.0, "avg_logprob": -0.13987389477816495, "compression_ratio": 1.5575221238938053, "no_speech_prob": 9.817433237913065e-06}, {"id": 71, "seek": 42544, "start": 430.76, "end": 437.8, "text": " dependence is O of sequence length. And then you got the word was. Okay? A second problem", "tokens": [31704, 307, 422, 295, 8310, 4641, 13, 400, 550, 291, 658, 264, 1349, 390, 13, 1033, 30, 316, 1150, 1154], "temperature": 0.0, "avg_logprob": -0.13987389477816495, "compression_ratio": 1.5575221238938053, "no_speech_prob": 9.817433237913065e-06}, {"id": 72, "seek": 42544, "start": 437.8, "end": 444.6, "text": " is very related. This is the lack of parallelizability. So this is going to be a huge refrain", "tokens": [307, 588, 4077, 13, 639, 307, 264, 5011, 295, 8952, 590, 2310, 13, 407, 341, 307, 516, 281, 312, 257, 2603, 46177], "temperature": 0.0, "avg_logprob": -0.13987389477816495, "compression_ratio": 1.5575221238938053, "no_speech_prob": 9.817433237913065e-06}, {"id": 73, "seek": 42544, "start": 444.6, "end": 449.2, "text": " now that we've gotten to the transformer's lectures is parallelizability. It's what", "tokens": [586, 300, 321, 600, 5768, 281, 264, 31782, 311, 16564, 307, 8952, 590, 2310, 13, 467, 311, 437], "temperature": 0.0, "avg_logprob": -0.13987389477816495, "compression_ratio": 1.5575221238938053, "no_speech_prob": 9.817433237913065e-06}, {"id": 74, "seek": 44920, "start": 449.2, "end": 458.4, "text": " you get from your GPU and it's what you want to exploit. So when you run an RNN, you have", "tokens": [291, 483, 490, 428, 18407, 293, 309, 311, 437, 291, 528, 281, 25924, 13, 407, 562, 291, 1190, 364, 45702, 45, 11, 291, 362], "temperature": 0.0, "avg_logprob": -0.15466264660438794, "compression_ratio": 1.5777777777777777, "no_speech_prob": 1.805527244869154e-05}, {"id": 75, "seek": 44920, "start": 458.4, "end": 465.38, "text": " O of sequence length many unparallelizable operations. And so while you have a GPU that", "tokens": [422, 295, 8310, 4641, 867, 517, 2181, 336, 338, 22395, 7705, 13, 400, 370, 1339, 291, 362, 257, 18407, 300], "temperature": 0.0, "avg_logprob": -0.15466264660438794, "compression_ratio": 1.5777777777777777, "no_speech_prob": 1.805527244869154e-05}, {"id": 76, "seek": 44920, "start": 465.38, "end": 470.48, "text": " can kind of chunk through a bunch of independent operations at once, you're unable to sort", "tokens": [393, 733, 295, 16635, 807, 257, 3840, 295, 6695, 7705, 412, 1564, 11, 291, 434, 11299, 281, 1333], "temperature": 0.0, "avg_logprob": -0.15466264660438794, "compression_ratio": 1.5777777777777777, "no_speech_prob": 1.805527244869154e-05}, {"id": 77, "seek": 44920, "start": 470.48, "end": 474.96, "text": " of do them all at once because you have this explicit time dependence in the recurrent", "tokens": [295, 360, 552, 439, 412, 1564, 570, 291, 362, 341, 13691, 565, 31704, 294, 264, 18680, 1753], "temperature": 0.0, "avg_logprob": -0.15466264660438794, "compression_ratio": 1.5777777777777777, "no_speech_prob": 1.805527244869154e-05}, {"id": 78, "seek": 47496, "start": 474.96, "end": 481.71999999999997, "text": " equations. In particular, you know, a future RNN state down the line can't be computed", "tokens": [11787, 13, 682, 1729, 11, 291, 458, 11, 257, 2027, 45702, 45, 1785, 760, 264, 1622, 393, 380, 312, 40610], "temperature": 0.0, "avg_logprob": -0.13656121246085678, "compression_ratio": 1.6167883211678833, "no_speech_prob": 1.6440617400803603e-05}, {"id": 79, "seek": 47496, "start": 481.71999999999997, "end": 485.91999999999996, "text": " until you've computed one that's earlier on. And this inhibits training on very large", "tokens": [1826, 291, 600, 40610, 472, 300, 311, 3071, 322, 13, 400, 341, 20406, 1208, 3097, 322, 588, 2416], "temperature": 0.0, "avg_logprob": -0.13656121246085678, "compression_ratio": 1.6167883211678833, "no_speech_prob": 1.6440617400803603e-05}, {"id": 80, "seek": 47496, "start": 485.91999999999996, "end": 492.64, "text": " data sets. So let's take a look at this, unrolling an RNN. If this is, say, the first later", "tokens": [1412, 6352, 13, 407, 718, 311, 747, 257, 574, 412, 341, 11, 517, 18688, 364, 45702, 45, 13, 759, 341, 307, 11, 584, 11, 264, 700, 1780], "temperature": 0.0, "avg_logprob": -0.13656121246085678, "compression_ratio": 1.6167883211678833, "no_speech_prob": 1.6440617400803603e-05}, {"id": 81, "seek": 47496, "start": 492.64, "end": 497.76, "text": " layer of an RNN or an LSTM, maybe it doesn't depend on effectively anything. You can just", "tokens": [4583, 295, 364, 45702, 45, 420, 364, 441, 6840, 44, 11, 1310, 309, 1177, 380, 5672, 322, 8659, 1340, 13, 509, 393, 445], "temperature": 0.0, "avg_logprob": -0.13656121246085678, "compression_ratio": 1.6167883211678833, "no_speech_prob": 1.6440617400803603e-05}, {"id": 82, "seek": 47496, "start": 497.76, "end": 502.96, "text": " compute it immediately. And then the second layer, so this is a, you know, a stacked set", "tokens": [14722, 309, 4258, 13, 400, 550, 264, 1150, 4583, 11, 370, 341, 307, 257, 11, 291, 458, 11, 257, 28867, 992], "temperature": 0.0, "avg_logprob": -0.13656121246085678, "compression_ratio": 1.6167883211678833, "no_speech_prob": 1.6440617400803603e-05}, {"id": 83, "seek": 50296, "start": 502.96, "end": 510.03999999999996, "text": " of two LSTMs. The second layer depends on the first layer here. In the time dimension", "tokens": [295, 732, 441, 6840, 26386, 13, 440, 1150, 4583, 5946, 322, 264, 700, 4583, 510, 13, 682, 264, 565, 10139], "temperature": 0.0, "avg_logprob": -0.17293583978082716, "compression_ratio": 1.7969543147208122, "no_speech_prob": 2.1442221623146906e-05}, {"id": 84, "seek": 50296, "start": 510.03999999999996, "end": 518.24, "text": " though, this cell here depends on this. So you've got a one. And then, you know, this", "tokens": [1673, 11, 341, 2815, 510, 5946, 322, 341, 13, 407, 291, 600, 658, 257, 472, 13, 400, 550, 11, 291, 458, 11, 341], "temperature": 0.0, "avg_logprob": -0.17293583978082716, "compression_ratio": 1.7969543147208122, "no_speech_prob": 2.1442221623146906e-05}, {"id": 85, "seek": 50296, "start": 518.24, "end": 522.56, "text": " depends on this. So you've got a one. So you have, you know, at most, sorry, at least two", "tokens": [5946, 322, 341, 13, 407, 291, 600, 658, 257, 472, 13, 407, 291, 362, 11, 291, 458, 11, 412, 881, 11, 2597, 11, 412, 1935, 732], "temperature": 0.0, "avg_logprob": -0.17293583978082716, "compression_ratio": 1.7969543147208122, "no_speech_prob": 2.1442221623146906e-05}, {"id": 86, "seek": 50296, "start": 522.56, "end": 528.24, "text": " things that you need to compute here before you can compute the value of this cell, likewise", "tokens": [721, 300, 291, 643, 281, 14722, 510, 949, 291, 393, 14722, 264, 2158, 295, 341, 2815, 11, 32407], "temperature": 0.0, "avg_logprob": -0.17293583978082716, "compression_ratio": 1.7969543147208122, "no_speech_prob": 2.1442221623146906e-05}, {"id": 87, "seek": 52824, "start": 528.24, "end": 533.52, "text": " three here. And with the sequence length, it grows with O of the sequence length. So,", "tokens": [1045, 510, 13, 400, 365, 264, 8310, 4641, 11, 309, 13156, 365, 422, 295, 264, 8310, 4641, 13, 407, 11], "temperature": 0.0, "avg_logprob": -0.18014276155861475, "compression_ratio": 1.599078341013825, "no_speech_prob": 4.331250238465145e-05}, {"id": 88, "seek": 52824, "start": 533.52, "end": 540.04, "text": " so here, I have been unable to even try to compute this value when I get here because", "tokens": [370, 510, 11, 286, 362, 668, 11299, 281, 754, 853, 281, 14722, 341, 2158, 562, 286, 483, 510, 570], "temperature": 0.0, "avg_logprob": -0.18014276155861475, "compression_ratio": 1.599078341013825, "no_speech_prob": 4.331250238465145e-05}, {"id": 89, "seek": 52824, "start": 540.04, "end": 545.44, "text": " I had to sort of do all of this first. So I can't parallelize over the time dimension.", "tokens": [286, 632, 281, 1333, 295, 360, 439, 295, 341, 700, 13, 407, 286, 393, 380, 8952, 1125, 670, 264, 565, 10139, 13], "temperature": 0.0, "avg_logprob": -0.18014276155861475, "compression_ratio": 1.599078341013825, "no_speech_prob": 4.331250238465145e-05}, {"id": 90, "seek": 52824, "start": 545.44, "end": 556.16, "text": " And this inhibits training on very large data sets. Okay. So, and then, I guess, crystal", "tokens": [400, 341, 20406, 1208, 3097, 322, 588, 2416, 1412, 6352, 13, 1033, 13, 407, 11, 293, 550, 11, 286, 2041, 11, 13662], "temperature": 0.0, "avg_logprob": -0.18014276155861475, "compression_ratio": 1.599078341013825, "no_speech_prob": 4.331250238465145e-05}, {"id": 91, "seek": 55616, "start": 556.16, "end": 560.3199999999999, "text": " TAs, you'll be able to stop me with the question if it feels like that's the right thing to", "tokens": [314, 10884, 11, 291, 603, 312, 1075, 281, 1590, 385, 365, 264, 1168, 498, 309, 3417, 411, 300, 311, 264, 558, 551, 281], "temperature": 0.0, "avg_logprob": -0.17157554626464844, "compression_ratio": 1.6150442477876106, "no_speech_prob": 7.965225086081773e-05}, {"id": 92, "seek": 55616, "start": 560.3199999999999, "end": 567.48, "text": " do. Okay. So, and you can see how it's a related problem, right? It's really directly related", "tokens": [360, 13, 1033, 13, 407, 11, 293, 291, 393, 536, 577, 309, 311, 257, 4077, 1154, 11, 558, 30, 467, 311, 534, 3838, 4077], "temperature": 0.0, "avg_logprob": -0.17157554626464844, "compression_ratio": 1.6150442477876106, "no_speech_prob": 7.965225086081773e-05}, {"id": 93, "seek": 55616, "start": 567.48, "end": 573.0, "text": " to the recurrence of the model. The thing that we thought was really useful now is being", "tokens": [281, 264, 18680, 10760, 295, 264, 2316, 13, 440, 551, 300, 321, 1194, 390, 534, 4420, 586, 307, 885], "temperature": 0.0, "avg_logprob": -0.17157554626464844, "compression_ratio": 1.6150442477876106, "no_speech_prob": 7.965225086081773e-05}, {"id": 94, "seek": 55616, "start": 573.0, "end": 581.8399999999999, "text": " problematic. Okay. So, so what I'm trying to say with that is we seemingly want to replace", "tokens": [19011, 13, 1033, 13, 407, 11, 370, 437, 286, 478, 1382, 281, 584, 365, 300, 307, 321, 18709, 528, 281, 7406], "temperature": 0.0, "avg_logprob": -0.17157554626464844, "compression_ratio": 1.6150442477876106, "no_speech_prob": 7.965225086081773e-05}, {"id": 95, "seek": 58184, "start": 581.84, "end": 586.36, "text": " recurrence as the building block itself. So, let's go through some alternatives. And we've", "tokens": [18680, 10760, 382, 264, 2390, 3461, 2564, 13, 407, 11, 718, 311, 352, 807, 512, 20478, 13, 400, 321, 600], "temperature": 0.0, "avg_logprob": -0.13358930883736447, "compression_ratio": 1.7, "no_speech_prob": 9.913984831655398e-05}, {"id": 96, "seek": 58184, "start": 586.36, "end": 591.5600000000001, "text": " seen each of these alternatives in the class so far. We'll start with WordWindow, sort", "tokens": [1612, 1184, 295, 613, 20478, 294, 264, 1508, 370, 1400, 13, 492, 603, 722, 365, 8725, 45813, 305, 11, 1333], "temperature": 0.0, "avg_logprob": -0.13358930883736447, "compression_ratio": 1.7, "no_speech_prob": 9.913984831655398e-05}, {"id": 97, "seek": 58184, "start": 591.5600000000001, "end": 596.9200000000001, "text": " of building blocks for our NLP models. If we wanted to replace our encoders and our decoders", "tokens": [295, 2390, 8474, 337, 527, 426, 45196, 5245, 13, 759, 321, 1415, 281, 7406, 527, 2058, 378, 433, 293, 527, 979, 378, 433], "temperature": 0.0, "avg_logprob": -0.13358930883736447, "compression_ratio": 1.7, "no_speech_prob": 9.913984831655398e-05}, {"id": 98, "seek": 58184, "start": 596.9200000000001, "end": 604.5600000000001, "text": " with something that sort of fit the same goal, but had different properties. So, a WordWindow", "tokens": [365, 746, 300, 1333, 295, 3318, 264, 912, 3387, 11, 457, 632, 819, 7221, 13, 407, 11, 257, 8725, 45813, 305], "temperature": 0.0, "avg_logprob": -0.13358930883736447, "compression_ratio": 1.7, "no_speech_prob": 9.913984831655398e-05}, {"id": 99, "seek": 58184, "start": 604.5600000000001, "end": 609.48, "text": " model will aggregate local context, right? We saw this with our sort of WordWindow classifiers", "tokens": [2316, 486, 26118, 2654, 4319, 11, 558, 30, 492, 1866, 341, 365, 527, 1333, 295, 8725, 45813, 305, 1508, 23463], "temperature": 0.0, "avg_logprob": -0.13358930883736447, "compression_ratio": 1.7, "no_speech_prob": 9.913984831655398e-05}, {"id": 100, "seek": 60948, "start": 609.48, "end": 615.64, "text": " that we've built already. You take a local context of words, you use it to represent", "tokens": [300, 321, 600, 3094, 1217, 13, 509, 747, 257, 2654, 4319, 295, 2283, 11, 291, 764, 309, 281, 2906], "temperature": 0.0, "avg_logprob": -0.15833075987089665, "compression_ratio": 1.5869565217391304, "no_speech_prob": 2.930648588517215e-05}, {"id": 101, "seek": 60948, "start": 615.64, "end": 619.9200000000001, "text": " information about the center word. This is also known as one-dimensional convolution.", "tokens": [1589, 466, 264, 3056, 1349, 13, 639, 307, 611, 2570, 382, 472, 12, 18759, 45216, 13], "temperature": 0.0, "avg_logprob": -0.15833075987089665, "compression_ratio": 1.5869565217391304, "no_speech_prob": 2.930648588517215e-05}, {"id": 102, "seek": 60948, "start": 619.9200000000001, "end": 625.36, "text": " We'll go over this in depth later in the course. Right now, we'll consider it as WordWindow", "tokens": [492, 603, 352, 670, 341, 294, 7161, 1780, 294, 264, 1164, 13, 1779, 586, 11, 321, 603, 1949, 309, 382, 8725, 45813, 305], "temperature": 0.0, "avg_logprob": -0.15833075987089665, "compression_ratio": 1.5869565217391304, "no_speech_prob": 2.930648588517215e-05}, {"id": 103, "seek": 60948, "start": 625.36, "end": 632.2, "text": " context. So, the number of unparallelizable operations with these WordWindow building", "tokens": [4319, 13, 407, 11, 264, 1230, 295, 517, 2181, 336, 338, 22395, 7705, 365, 613, 8725, 45813, 305, 2390], "temperature": 0.0, "avg_logprob": -0.15833075987089665, "compression_ratio": 1.5869565217391304, "no_speech_prob": 2.930648588517215e-05}, {"id": 104, "seek": 60948, "start": 632.2, "end": 637.12, "text": " blocks does not grow with the sequence length. And here's a picture of that. You have the", "tokens": [8474, 775, 406, 1852, 365, 264, 8310, 4641, 13, 400, 510, 311, 257, 3036, 295, 300, 13, 509, 362, 264], "temperature": 0.0, "avg_logprob": -0.15833075987089665, "compression_ratio": 1.5869565217391304, "no_speech_prob": 2.930648588517215e-05}, {"id": 105, "seek": 63712, "start": 637.12, "end": 642.5600000000001, "text": " embedding layer, say, so you can embed every word independently. Right? So, you don't", "tokens": [12240, 3584, 4583, 11, 584, 11, 370, 291, 393, 12240, 633, 1349, 21761, 13, 1779, 30, 407, 11, 291, 500, 380], "temperature": 0.0, "avg_logprob": -0.15246471336909703, "compression_ratio": 1.6218181818181818, "no_speech_prob": 5.389995203586295e-05}, {"id": 106, "seek": 63712, "start": 642.5600000000001, "end": 646.2, "text": " need to know the other words surrounding it in order to pick the right embedding dimension", "tokens": [643, 281, 458, 264, 661, 2283, 11498, 309, 294, 1668, 281, 1888, 264, 558, 12240, 3584, 10139], "temperature": 0.0, "avg_logprob": -0.15246471336909703, "compression_ratio": 1.6218181818181818, "no_speech_prob": 5.389995203586295e-05}, {"id": 107, "seek": 63712, "start": 646.2, "end": 652.72, "text": " out. And so, these all have sort of zero dependence in this sort of hand-wavy notion of how", "tokens": [484, 13, 400, 370, 11, 613, 439, 362, 1333, 295, 4018, 31704, 294, 341, 1333, 295, 1011, 12, 86, 15498, 10710, 295, 577], "temperature": 0.0, "avg_logprob": -0.15246471336909703, "compression_ratio": 1.6218181818181818, "no_speech_prob": 5.389995203586295e-05}, {"id": 108, "seek": 63712, "start": 652.72, "end": 659.08, "text": " much parallelizability is there is. Now, you can walk a WordWindow classifier on top of", "tokens": [709, 8952, 590, 2310, 307, 456, 307, 13, 823, 11, 291, 393, 1792, 257, 8725, 45813, 305, 1508, 9902, 322, 1192, 295], "temperature": 0.0, "avg_logprob": -0.15246471336909703, "compression_ratio": 1.6218181818181818, "no_speech_prob": 5.389995203586295e-05}, {"id": 109, "seek": 63712, "start": 659.08, "end": 666.0, "text": " each one to build a representation of the word that takes into account its local context.", "tokens": [1184, 472, 281, 1322, 257, 10290, 295, 264, 1349, 300, 2516, 666, 2696, 1080, 2654, 4319, 13], "temperature": 0.0, "avg_logprob": -0.15246471336909703, "compression_ratio": 1.6218181818181818, "no_speech_prob": 5.389995203586295e-05}, {"id": 110, "seek": 66600, "start": 666.0, "end": 671.88, "text": " But in order to apply it to this word, h1, I don't need to know anything. Sorry, I don't", "tokens": [583, 294, 1668, 281, 3079, 309, 281, 341, 1349, 11, 276, 16, 11, 286, 500, 380, 643, 281, 458, 1340, 13, 4919, 11, 286, 500, 380], "temperature": 0.0, "avg_logprob": -0.1657475779827376, "compression_ratio": 1.76171875, "no_speech_prob": 6.107418448664248e-05}, {"id": 111, "seek": 66600, "start": 671.88, "end": 676.88, "text": " need to have applied it to h1 in order to apply it to h2. Likewise, in order to apply a Word", "tokens": [643, 281, 362, 6456, 309, 281, 276, 16, 294, 1668, 281, 3079, 309, 281, 276, 17, 13, 30269, 11, 294, 1668, 281, 3079, 257, 8725], "temperature": 0.0, "avg_logprob": -0.1657475779827376, "compression_ratio": 1.76171875, "no_speech_prob": 6.107418448664248e-05}, {"id": 112, "seek": 66600, "start": 676.88, "end": 682.6, "text": "Window contextualizer to ht, I can just look at its local window independently. And so,", "tokens": [45813, 305, 35526, 6545, 281, 276, 83, 11, 286, 393, 445, 574, 412, 1080, 2654, 4910, 21761, 13, 400, 370, 11], "temperature": 0.0, "avg_logprob": -0.1657475779827376, "compression_ratio": 1.76171875, "no_speech_prob": 6.107418448664248e-05}, {"id": 113, "seek": 66600, "start": 682.6, "end": 689.28, "text": " again, none of these have a dependence in time. I can keep stacking layers like this. Right?", "tokens": [797, 11, 6022, 295, 613, 362, 257, 31704, 294, 565, 13, 286, 393, 1066, 41376, 7914, 411, 341, 13, 1779, 30], "temperature": 0.0, "avg_logprob": -0.1657475779827376, "compression_ratio": 1.76171875, "no_speech_prob": 6.107418448664248e-05}, {"id": 114, "seek": 66600, "start": 689.28, "end": 695.28, "text": " So, this can look like an encoder, right? And encoder like our LSTM encoders. If I didn't", "tokens": [407, 11, 341, 393, 574, 411, 364, 2058, 19866, 11, 558, 30, 400, 2058, 19866, 411, 527, 441, 6840, 44, 2058, 378, 433, 13, 759, 286, 994, 380], "temperature": 0.0, "avg_logprob": -0.1657475779827376, "compression_ratio": 1.76171875, "no_speech_prob": 6.107418448664248e-05}, {"id": 115, "seek": 69528, "start": 695.28, "end": 699.72, "text": " allow you to look at the future by just cutting off the window, it could look like a decoder", "tokens": [2089, 291, 281, 574, 412, 264, 2027, 538, 445, 6492, 766, 264, 4910, 11, 309, 727, 574, 411, 257, 979, 19866], "temperature": 0.0, "avg_logprob": -0.1433910456570712, "compression_ratio": 1.6317689530685922, "no_speech_prob": 5.918421084061265e-05}, {"id": 116, "seek": 69528, "start": 699.72, "end": 707.6, "text": " for language models. And this is nice. And we get this beautiful, you know, o of 1 dependence", "tokens": [337, 2856, 5245, 13, 400, 341, 307, 1481, 13, 400, 321, 483, 341, 2238, 11, 291, 458, 11, 277, 295, 502, 31704], "temperature": 0.0, "avg_logprob": -0.1433910456570712, "compression_ratio": 1.6317689530685922, "no_speech_prob": 5.918421084061265e-05}, {"id": 117, "seek": 69528, "start": 707.6, "end": 711.16, "text": " in time, right? No dependence at all in the time dimension. That's an improvement. But", "tokens": [294, 565, 11, 558, 30, 883, 31704, 412, 439, 294, 264, 565, 10139, 13, 663, 311, 364, 10444, 13, 583], "temperature": 0.0, "avg_logprob": -0.1433910456570712, "compression_ratio": 1.6317689530685922, "no_speech_prob": 5.918421084061265e-05}, {"id": 118, "seek": 69528, "start": 711.16, "end": 715.72, "text": " there are some problems. So, what about long distance dependencies, right? This is why", "tokens": [456, 366, 512, 2740, 13, 407, 11, 437, 466, 938, 4560, 36606, 11, 558, 30, 639, 307, 983], "temperature": 0.0, "avg_logprob": -0.1433910456570712, "compression_ratio": 1.6317689530685922, "no_speech_prob": 5.918421084061265e-05}, {"id": 119, "seek": 69528, "start": 715.72, "end": 719.76, "text": " we said we wanted to use recurrent neural networks because they would do better at encoding", "tokens": [321, 848, 321, 1415, 281, 764, 18680, 1753, 18161, 9590, 570, 436, 576, 360, 1101, 412, 43430], "temperature": 0.0, "avg_logprob": -0.1433910456570712, "compression_ratio": 1.6317689530685922, "no_speech_prob": 5.918421084061265e-05}, {"id": 120, "seek": 71976, "start": 719.76, "end": 726.36, "text": " long distance dependencies. It's a problem, just like it was a problem before. But by stacking", "tokens": [938, 4560, 36606, 13, 467, 311, 257, 1154, 11, 445, 411, 309, 390, 257, 1154, 949, 13, 583, 538, 41376], "temperature": 0.0, "avg_logprob": -0.1430928394047901, "compression_ratio": 1.5851528384279476, "no_speech_prob": 2.9767752494080923e-05}, {"id": 121, "seek": 71976, "start": 726.36, "end": 732.3199999999999, "text": " WordWindow layers, we can get to wider, longer contexts. So, if you have some sort of", "tokens": [8725, 45813, 305, 7914, 11, 321, 393, 483, 281, 11842, 11, 2854, 30628, 13, 407, 11, 498, 291, 362, 512, 1333, 295], "temperature": 0.0, "avg_logprob": -0.1430928394047901, "compression_ratio": 1.5851528384279476, "no_speech_prob": 2.9767752494080923e-05}, {"id": 122, "seek": 71976, "start": 732.3199999999999, "end": 740.04, "text": " window size, and then you stack two layers, so red states here are state kind of how you", "tokens": [4910, 2744, 11, 293, 550, 291, 8630, 732, 7914, 11, 370, 2182, 4368, 510, 366, 1785, 733, 295, 577, 291], "temperature": 0.0, "avg_logprob": -0.1430928394047901, "compression_ratio": 1.5851528384279476, "no_speech_prob": 2.9767752494080923e-05}, {"id": 123, "seek": 71976, "start": 740.04, "end": 747.76, "text": " can look, how far away you can look in order to encode hk, right? So, in the embedding layer,", "tokens": [393, 574, 11, 577, 1400, 1314, 291, 393, 574, 294, 1668, 281, 2058, 1429, 276, 74, 11, 558, 30, 407, 11, 294, 264, 12240, 3584, 4583, 11], "temperature": 0.0, "avg_logprob": -0.1430928394047901, "compression_ratio": 1.5851528384279476, "no_speech_prob": 2.9767752494080923e-05}, {"id": 124, "seek": 74776, "start": 747.76, "end": 752.8, "text": " we have these sort of words here. So, this is the last layer, this top layer of the", "tokens": [321, 362, 613, 1333, 295, 2283, 510, 13, 407, 11, 341, 307, 264, 1036, 4583, 11, 341, 1192, 4583, 295, 264], "temperature": 0.0, "avg_logprob": -0.16099814294089734, "compression_ratio": 1.8385964912280701, "no_speech_prob": 4.2642004700610414e-05}, {"id": 125, "seek": 74776, "start": 752.8, "end": 758.68, "text": " WordWindow classifier. Here's the embedding of hk at the output of your encoder. And so,", "tokens": [8725, 45813, 305, 1508, 9902, 13, 1692, 311, 264, 12240, 3584, 295, 276, 74, 412, 264, 5598, 295, 428, 2058, 19866, 13, 400, 370, 11], "temperature": 0.0, "avg_logprob": -0.16099814294089734, "compression_ratio": 1.8385964912280701, "no_speech_prob": 4.2642004700610414e-05}, {"id": 126, "seek": 74776, "start": 758.68, "end": 762.92, "text": " it looks at, you know, the local five words, because that's the window size. And then,", "tokens": [309, 1542, 412, 11, 291, 458, 11, 264, 2654, 1732, 2283, 11, 570, 300, 311, 264, 4910, 2744, 13, 400, 550, 11], "temperature": 0.0, "avg_logprob": -0.16099814294089734, "compression_ratio": 1.8385964912280701, "no_speech_prob": 4.2642004700610414e-05}, {"id": 127, "seek": 74776, "start": 762.92, "end": 768.08, "text": " as well, you know, the farthest word over here has also looked a couple of words away,", "tokens": [382, 731, 11, 291, 458, 11, 264, 1400, 36356, 1349, 670, 510, 575, 611, 2956, 257, 1916, 295, 2283, 1314, 11], "temperature": 0.0, "avg_logprob": -0.16099814294089734, "compression_ratio": 1.8385964912280701, "no_speech_prob": 4.2642004700610414e-05}, {"id": 128, "seek": 74776, "start": 768.08, "end": 772.4, "text": " right? So, if you stack these, and stack these, and stack these without growing the window", "tokens": [558, 30, 407, 11, 498, 291, 8630, 613, 11, 293, 8630, 613, 11, 293, 8630, 613, 1553, 4194, 264, 4910], "temperature": 0.0, "avg_logprob": -0.16099814294089734, "compression_ratio": 1.8385964912280701, "no_speech_prob": 4.2642004700610414e-05}, {"id": 129, "seek": 74776, "start": 772.4, "end": 777.12, "text": " size at all at any given layer, you can look pretty far. And actually there are tricks", "tokens": [2744, 412, 439, 412, 604, 2212, 4583, 11, 291, 393, 574, 1238, 1400, 13, 400, 767, 456, 366, 11733], "temperature": 0.0, "avg_logprob": -0.16099814294089734, "compression_ratio": 1.8385964912280701, "no_speech_prob": 4.2642004700610414e-05}, {"id": 130, "seek": 77712, "start": 777.12, "end": 782.08, "text": " you can use to look even farther. But you still have this sort of, at least in principle,", "tokens": [291, 393, 764, 281, 574, 754, 20344, 13, 583, 291, 920, 362, 341, 1333, 295, 11, 412, 1935, 294, 8665, 11], "temperature": 0.0, "avg_logprob": -0.13044532271456127, "compression_ratio": 1.6444444444444444, "no_speech_prob": 1.8625098164193332e-05}, {"id": 131, "seek": 77712, "start": 782.08, "end": 787.84, "text": " problem, where you've got a word like this h1. And you can see how it's in blue. And,", "tokens": [1154, 11, 689, 291, 600, 658, 257, 1349, 411, 341, 276, 16, 13, 400, 291, 393, 536, 577, 309, 311, 294, 3344, 13, 400, 11], "temperature": 0.0, "avg_logprob": -0.13044532271456127, "compression_ratio": 1.6444444444444444, "no_speech_prob": 1.8625098164193332e-05}, {"id": 132, "seek": 77712, "start": 787.84, "end": 793.36, "text": " you know, with these two layers of the network, I don't know anything about h1 at all when", "tokens": [291, 458, 11, 365, 613, 732, 7914, 295, 264, 3209, 11, 286, 500, 380, 458, 1340, 466, 276, 16, 412, 439, 562], "temperature": 0.0, "avg_logprob": -0.13044532271456127, "compression_ratio": 1.6444444444444444, "no_speech_prob": 1.8625098164193332e-05}, {"id": 133, "seek": 77712, "start": 793.36, "end": 798.28, "text": " I'm building up the representation of hk over here. I could solve that by adding another", "tokens": [286, 478, 2390, 493, 264, 10290, 295, 276, 74, 670, 510, 13, 286, 727, 5039, 300, 538, 5127, 1071], "temperature": 0.0, "avg_logprob": -0.13044532271456127, "compression_ratio": 1.6444444444444444, "no_speech_prob": 1.8625098164193332e-05}, {"id": 134, "seek": 77712, "start": 798.28, "end": 804.84, "text": " layer in depth, but, you know, in principle, you always have some finite field. So, this", "tokens": [4583, 294, 7161, 11, 457, 11, 291, 458, 11, 294, 8665, 11, 291, 1009, 362, 512, 19362, 2519, 13, 407, 11, 341], "temperature": 0.0, "avg_logprob": -0.13044532271456127, "compression_ratio": 1.6444444444444444, "no_speech_prob": 1.8625098164193332e-05}, {"id": 135, "seek": 80484, "start": 804.84, "end": 810.5600000000001, "text": " is, you know, actually pretty useful. These, you know, word window kind of contextualizers,", "tokens": [307, 11, 291, 458, 11, 767, 1238, 4420, 13, 1981, 11, 291, 458, 11, 1349, 4910, 733, 295, 35526, 22525, 11], "temperature": 0.0, "avg_logprob": -0.16752453126769135, "compression_ratio": 1.799342105263158, "no_speech_prob": 9.457597479922697e-05}, {"id": 136, "seek": 80484, "start": 810.5600000000001, "end": 814.44, "text": " and we will learn more about them later. And there was sort of a lot of this effort that", "tokens": [293, 321, 486, 1466, 544, 466, 552, 1780, 13, 400, 456, 390, 1333, 295, 257, 688, 295, 341, 4630, 300], "temperature": 0.0, "avg_logprob": -0.16752453126769135, "compression_ratio": 1.799342105263158, "no_speech_prob": 9.457597479922697e-05}, {"id": 137, "seek": 80484, "start": 814.44, "end": 818.08, "text": " I talked about at the beginning of the class, was actually sort of partly deciding which", "tokens": [286, 2825, 466, 412, 264, 2863, 295, 264, 1508, 11, 390, 767, 1333, 295, 17031, 17990, 597], "temperature": 0.0, "avg_logprob": -0.16752453126769135, "compression_ratio": 1.799342105263158, "no_speech_prob": 9.457597479922697e-05}, {"id": 138, "seek": 80484, "start": 818.08, "end": 822.88, "text": " of, when you know, word window stuff, convolutional, it's called stuff, or attention, and attention", "tokens": [295, 11, 562, 291, 458, 11, 1349, 4910, 1507, 11, 45216, 304, 11, 309, 311, 1219, 1507, 11, 420, 3202, 11, 293, 3202], "temperature": 0.0, "avg_logprob": -0.16752453126769135, "compression_ratio": 1.799342105263158, "no_speech_prob": 9.457597479922697e-05}, {"id": 139, "seek": 80484, "start": 822.88, "end": 828.96, "text": " has won out for the time being. And so, yeah, what about attention? So, what, why could", "tokens": [575, 1582, 484, 337, 264, 565, 885, 13, 400, 370, 11, 1338, 11, 437, 466, 3202, 30, 407, 11, 437, 11, 983, 727], "temperature": 0.0, "avg_logprob": -0.16752453126769135, "compression_ratio": 1.799342105263158, "no_speech_prob": 9.457597479922697e-05}, {"id": 140, "seek": 80484, "start": 828.96, "end": 833.5600000000001, "text": " it be useful as, like, as a fundamental building block instead of sort of sugar on top of", "tokens": [309, 312, 4420, 382, 11, 411, 11, 382, 257, 8088, 2390, 3461, 2602, 295, 1333, 295, 5076, 322, 1192, 295], "temperature": 0.0, "avg_logprob": -0.16752453126769135, "compression_ratio": 1.799342105263158, "no_speech_prob": 9.457597479922697e-05}, {"id": 141, "seek": 83356, "start": 833.56, "end": 841.0, "text": " our LSTMs? So, just to recall some of the intuitions of attention, it treats a words", "tokens": [527, 441, 6840, 26386, 30, 407, 11, 445, 281, 9901, 512, 295, 264, 16224, 626, 295, 3202, 11, 309, 19566, 257, 2283], "temperature": 0.0, "avg_logprob": -0.14382627037134063, "compression_ratio": 1.6948356807511737, "no_speech_prob": 8.612541569164023e-05}, {"id": 142, "seek": 83356, "start": 841.0, "end": 848.1999999999999, "text": " representation as a query, and it looks somewhere and tries to sort of access information from", "tokens": [10290, 382, 257, 14581, 11, 293, 309, 1542, 4079, 293, 9898, 281, 1333, 295, 2105, 1589, 490], "temperature": 0.0, "avg_logprob": -0.14382627037134063, "compression_ratio": 1.6948356807511737, "no_speech_prob": 8.612541569164023e-05}, {"id": 143, "seek": 83356, "start": 848.1999999999999, "end": 853.04, "text": " a set of values, right? So, we had a word representation in our decoder in our machine translation", "tokens": [257, 992, 295, 4190, 11, 558, 30, 407, 11, 321, 632, 257, 1349, 10290, 294, 527, 979, 19866, 294, 527, 3479, 12853], "temperature": 0.0, "avg_logprob": -0.14382627037134063, "compression_ratio": 1.6948356807511737, "no_speech_prob": 8.612541569164023e-05}, {"id": 144, "seek": 83356, "start": 853.04, "end": 860.2399999999999, "text": " systems. The set of values were all of the encoder states for the source sentence.", "tokens": [3652, 13, 440, 992, 295, 4190, 645, 439, 295, 264, 2058, 19866, 4368, 337, 264, 4009, 8174, 13], "temperature": 0.0, "avg_logprob": -0.14382627037134063, "compression_ratio": 1.6948356807511737, "no_speech_prob": 8.612541569164023e-05}, {"id": 145, "seek": 86024, "start": 860.24, "end": 864.96, "text": " And today we'll think about, instead of attention from the decoder to the encoder, we will", "tokens": [400, 965, 321, 603, 519, 466, 11, 2602, 295, 3202, 490, 264, 979, 19866, 281, 264, 2058, 19866, 11, 321, 486], "temperature": 0.0, "avg_logprob": -0.14814471339320276, "compression_ratio": 1.754863813229572, "no_speech_prob": 2.9305791031219997e-05}, {"id": 146, "seek": 86024, "start": 864.96, "end": 871.52, "text": " think about attention within a single sentence. So, just a very quick picture of it, you've", "tokens": [519, 466, 3202, 1951, 257, 2167, 8174, 13, 407, 11, 445, 257, 588, 1702, 3036, 295, 309, 11, 291, 600], "temperature": 0.0, "avg_logprob": -0.14814471339320276, "compression_ratio": 1.754863813229572, "no_speech_prob": 2.9305791031219997e-05}, {"id": 147, "seek": 86024, "start": 871.52, "end": 875.44, "text": " got your embedding layer again, I'm putting the computational dependence counts here, so", "tokens": [658, 428, 12240, 3584, 4583, 797, 11, 286, 478, 3372, 264, 28270, 31704, 14893, 510, 11, 370], "temperature": 0.0, "avg_logprob": -0.14814471339320276, "compression_ratio": 1.754863813229572, "no_speech_prob": 2.9305791031219997e-05}, {"id": 148, "seek": 86024, "start": 875.44, "end": 880.64, "text": " all of these sort of can be done in parallel for the embedding layer again. And now you're", "tokens": [439, 295, 613, 1333, 295, 393, 312, 1096, 294, 8952, 337, 264, 12240, 3584, 4583, 797, 13, 400, 586, 291, 434], "temperature": 0.0, "avg_logprob": -0.14814471339320276, "compression_ratio": 1.754863813229572, "no_speech_prob": 2.9305791031219997e-05}, {"id": 149, "seek": 86024, "start": 880.64, "end": 884.92, "text": " doing attention, right? So, you're kind of looking at every single word in the embedding", "tokens": [884, 3202, 11, 558, 30, 407, 11, 291, 434, 733, 295, 1237, 412, 633, 2167, 1349, 294, 264, 12240, 3584], "temperature": 0.0, "avg_logprob": -0.14814471339320276, "compression_ratio": 1.754863813229572, "no_speech_prob": 2.9305791031219997e-05}, {"id": 150, "seek": 88492, "start": 884.92, "end": 892.3199999999999, "text": " layer to attend to this word. And I'm omitting a bunch of arrows here, so these are all arrows.", "tokens": [4583, 281, 6888, 281, 341, 1349, 13, 400, 286, 478, 3406, 2414, 257, 3840, 295, 19669, 510, 11, 370, 613, 366, 439, 19669, 13], "temperature": 0.0, "avg_logprob": -0.14846855799357098, "compression_ratio": 1.7018867924528303, "no_speech_prob": 4.0677539800526574e-05}, {"id": 151, "seek": 88492, "start": 892.3199999999999, "end": 895.92, "text": " All words interact with all words, and we'll get deep into this today, I promise, but I", "tokens": [1057, 2283, 4648, 365, 439, 2283, 11, 293, 321, 603, 483, 2452, 666, 341, 965, 11, 286, 6228, 11, 457, 286], "temperature": 0.0, "avg_logprob": -0.14846855799357098, "compression_ratio": 1.7018867924528303, "no_speech_prob": 4.0677539800526574e-05}, {"id": 152, "seek": 88492, "start": 895.92, "end": 901.12, "text": " just wanted to sort of make this a little bit less dense looking of a graph. And then,", "tokens": [445, 1415, 281, 1333, 295, 652, 341, 257, 707, 857, 1570, 18011, 1237, 295, 257, 4295, 13, 400, 550, 11], "temperature": 0.0, "avg_logprob": -0.14846855799357098, "compression_ratio": 1.7018867924528303, "no_speech_prob": 4.0677539800526574e-05}, {"id": 153, "seek": 88492, "start": 901.12, "end": 906.92, "text": " so, in the second layer, again, all pairs of words interact, and this is all parallelizable.", "tokens": [370, 11, 294, 264, 1150, 4583, 11, 797, 11, 439, 15494, 295, 2283, 4648, 11, 293, 341, 307, 439, 8952, 22395, 13], "temperature": 0.0, "avg_logprob": -0.14846855799357098, "compression_ratio": 1.7018867924528303, "no_speech_prob": 4.0677539800526574e-05}, {"id": 154, "seek": 88492, "start": 906.92, "end": 911.9599999999999, "text": " So, you can't parallelize in depth, right? Because you need to encode this layer before", "tokens": [407, 11, 291, 393, 380, 8952, 1125, 294, 7161, 11, 558, 30, 1436, 291, 643, 281, 2058, 1429, 341, 4583, 949], "temperature": 0.0, "avg_logprob": -0.14846855799357098, "compression_ratio": 1.7018867924528303, "no_speech_prob": 4.0677539800526574e-05}, {"id": 155, "seek": 91196, "start": 911.96, "end": 918.76, "text": " you can do that layer, but in time, it is parallelizable. So, it checks that box. So, again,", "tokens": [291, 393, 360, 300, 4583, 11, 457, 294, 565, 11, 309, 307, 8952, 22395, 13, 407, 11, 309, 13834, 300, 2424, 13, 407, 11, 797, 11], "temperature": 0.0, "avg_logprob": -0.14151804070723684, "compression_ratio": 1.6043478260869566, "no_speech_prob": 3.5904387914342806e-05}, {"id": 156, "seek": 91196, "start": 918.76, "end": 926.72, "text": " we have O of one sort of computational dependence, you know, a number of unparallizable operations", "tokens": [321, 362, 422, 295, 472, 1333, 295, 28270, 31704, 11, 291, 458, 11, 257, 1230, 295, 517, 2181, 336, 22395, 7705], "temperature": 0.0, "avg_logprob": -0.14151804070723684, "compression_ratio": 1.6043478260869566, "no_speech_prob": 3.5904387914342806e-05}, {"id": 157, "seek": 91196, "start": 926.72, "end": 933.2, "text": " as a function of sequence length, and as an added benefit, right? The interaction distance", "tokens": [382, 257, 2445, 295, 8310, 4641, 11, 293, 382, 364, 3869, 5121, 11, 558, 30, 440, 9285, 4560], "temperature": 0.0, "avg_logprob": -0.14151804070723684, "compression_ratio": 1.6043478260869566, "no_speech_prob": 3.5904387914342806e-05}, {"id": 158, "seek": 91196, "start": 933.2, "end": 939.2800000000001, "text": " between words is O of one as well. So, whereas before, we had recurrent networks where", "tokens": [1296, 2283, 307, 422, 295, 472, 382, 731, 13, 407, 11, 9735, 949, 11, 321, 632, 18680, 1753, 9590, 689], "temperature": 0.0, "avg_logprob": -0.14151804070723684, "compression_ratio": 1.6043478260869566, "no_speech_prob": 3.5904387914342806e-05}, {"id": 159, "seek": 93928, "start": 939.28, "end": 945.8399999999999, "text": " if you are far, so T is the last word in the sentence, you could have O of T operations", "tokens": [498, 291, 366, 1400, 11, 370, 314, 307, 264, 1036, 1349, 294, 264, 8174, 11, 291, 727, 362, 422, 295, 314, 7705], "temperature": 0.0, "avg_logprob": -0.16989866557874178, "compression_ratio": 1.6181818181818182, "no_speech_prob": 2.078130273730494e-05}, {"id": 160, "seek": 93928, "start": 945.8399999999999, "end": 951.4, "text": " between you and a far away word, with attention, you interact immediately. That's very first", "tokens": [1296, 291, 293, 257, 1400, 1314, 1349, 11, 365, 3202, 11, 291, 4648, 4258, 13, 663, 311, 588, 700], "temperature": 0.0, "avg_logprob": -0.16989866557874178, "compression_ratio": 1.6181818181818182, "no_speech_prob": 2.078130273730494e-05}, {"id": 161, "seek": 93928, "start": 951.4, "end": 956.88, "text": " layer, you get to see your far away word, and so that's O of one. And this ends up being", "tokens": [4583, 11, 291, 483, 281, 536, 428, 1400, 1314, 1349, 11, 293, 370, 300, 311, 422, 295, 472, 13, 400, 341, 5314, 493, 885], "temperature": 0.0, "avg_logprob": -0.16989866557874178, "compression_ratio": 1.6181818181818182, "no_speech_prob": 2.078130273730494e-05}, {"id": 162, "seek": 93928, "start": 956.88, "end": 965.9599999999999, "text": " seemingly fascinatingly powerful, and we'll get into a lot of details today. Okay. So,", "tokens": [18709, 10343, 356, 4005, 11, 293, 321, 603, 483, 666, 257, 688, 295, 4365, 965, 13, 1033, 13, 407, 11], "temperature": 0.0, "avg_logprob": -0.16989866557874178, "compression_ratio": 1.6181818181818182, "no_speech_prob": 2.078130273730494e-05}, {"id": 163, "seek": 96596, "start": 965.96, "end": 970.88, "text": " this is sort of why attention solves the two problems that we brought up with recurrent", "tokens": [341, 307, 1333, 295, 983, 3202, 39890, 264, 732, 2740, 300, 321, 3038, 493, 365, 18680, 1753], "temperature": 0.0, "avg_logprob": -0.12701529589566318, "compression_ratio": 1.6628787878787878, "no_speech_prob": 9.458548447582871e-05}, {"id": 164, "seek": 96596, "start": 970.88, "end": 976.0400000000001, "text": " neural networks, but with our empiricist hats on, it shouldn't be proof yet that, you", "tokens": [18161, 9590, 11, 457, 365, 527, 25790, 299, 468, 20549, 322, 11, 309, 4659, 380, 312, 8177, 1939, 300, 11, 291], "temperature": 0.0, "avg_logprob": -0.12701529589566318, "compression_ratio": 1.6628787878787878, "no_speech_prob": 9.458548447582871e-05}, {"id": 165, "seek": 96596, "start": 976.0400000000001, "end": 979.84, "text": " know, it should be a good building block. And in fact, it takes a little bit of thinking", "tokens": [458, 11, 309, 820, 312, 257, 665, 2390, 3461, 13, 400, 294, 1186, 11, 309, 2516, 257, 707, 857, 295, 1953], "temperature": 0.0, "avg_logprob": -0.12701529589566318, "compression_ratio": 1.6628787878787878, "no_speech_prob": 9.458548447582871e-05}, {"id": 166, "seek": 96596, "start": 979.84, "end": 985.32, "text": " to think about how to turn attention into a building block like RNNs were. So, let's", "tokens": [281, 519, 466, 577, 281, 1261, 3202, 666, 257, 2390, 3461, 411, 45702, 45, 82, 645, 13, 407, 11, 718, 311], "temperature": 0.0, "avg_logprob": -0.12701529589566318, "compression_ratio": 1.6628787878787878, "no_speech_prob": 9.458548447582871e-05}, {"id": 167, "seek": 96596, "start": 985.32, "end": 991.44, "text": " start by digging right into just the equations for self-attention, which again is attention", "tokens": [722, 538, 17343, 558, 666, 445, 264, 11787, 337, 2698, 12, 1591, 1251, 11, 597, 797, 307, 3202], "temperature": 0.0, "avg_logprob": -0.12701529589566318, "compression_ratio": 1.6628787878787878, "no_speech_prob": 9.458548447582871e-05}, {"id": 168, "seek": 99144, "start": 991.44, "end": 996.84, "text": " to, or the, everything is looking within itself, we'll formalize this for you. So, we're", "tokens": [281, 11, 420, 264, 11, 1203, 307, 1237, 1951, 2564, 11, 321, 603, 9860, 1125, 341, 337, 291, 13, 407, 11, 321, 434], "temperature": 0.0, "avg_logprob": -0.21211252292665114, "compression_ratio": 1.6884615384615385, "no_speech_prob": 6.707726424792781e-05}, {"id": 169, "seek": 99144, "start": 996.84, "end": 1003.7600000000001, "text": " going to be talking all lecture today about queries, keys, and values. Our queries are", "tokens": [516, 281, 312, 1417, 439, 7991, 965, 466, 24109, 11, 9317, 11, 293, 4190, 13, 2621, 24109, 366], "temperature": 0.0, "avg_logprob": -0.21211252292665114, "compression_ratio": 1.6884615384615385, "no_speech_prob": 6.707726424792781e-05}, {"id": 170, "seek": 99144, "start": 1003.7600000000001, "end": 1009.44, "text": " going to be a set of T queries, each query is a vector in dimension D. You can just think", "tokens": [516, 281, 312, 257, 992, 295, 314, 24109, 11, 1184, 14581, 307, 257, 8062, 294, 10139, 413, 13, 509, 393, 445, 519], "temperature": 0.0, "avg_logprob": -0.21211252292665114, "compression_ratio": 1.6884615384615385, "no_speech_prob": 6.707726424792781e-05}, {"id": 171, "seek": 99144, "start": 1009.44, "end": 1014.2800000000001, "text": " of them as just those vectors right now, not worrying necessarily about where they came", "tokens": [295, 552, 382, 445, 729, 18875, 558, 586, 11, 406, 18788, 4725, 466, 689, 436, 1361], "temperature": 0.0, "avg_logprob": -0.21211252292665114, "compression_ratio": 1.6884615384615385, "no_speech_prob": 6.707726424792781e-05}, {"id": 172, "seek": 99144, "start": 1014.2800000000001, "end": 1021.4000000000001, "text": " from. We have a set of keys, K1 to KT. Again, each vector K is in dimension L. So, we", "tokens": [490, 13, 492, 362, 257, 992, 295, 9317, 11, 591, 16, 281, 591, 51, 13, 3764, 11, 1184, 8062, 591, 307, 294, 10139, 441, 13, 407, 11, 321], "temperature": 0.0, "avg_logprob": -0.21211252292665114, "compression_ratio": 1.6884615384615385, "no_speech_prob": 6.707726424792781e-05}, {"id": 173, "seek": 102140, "start": 1021.4, "end": 1027.4, "text": " have a value D, and we have some values. Each value is going to be also in dimension L", "tokens": [362, 257, 2158, 413, 11, 293, 321, 362, 512, 4190, 13, 6947, 2158, 307, 516, 281, 312, 611, 294, 10139, 441], "temperature": 0.0, "avg_logprob": -0.20608596491619824, "compression_ratio": 1.854251012145749, "no_speech_prob": 1.7499516616226174e-05}, {"id": 174, "seek": 102140, "start": 1027.4, "end": 1033.56, "text": " D. And for now, we're going to assume that we have the same number of all of them, that's", "tokens": [413, 13, 400, 337, 586, 11, 321, 434, 516, 281, 6552, 300, 321, 362, 264, 912, 1230, 295, 439, 295, 552, 11, 300, 311], "temperature": 0.0, "avg_logprob": -0.20608596491619824, "compression_ratio": 1.854251012145749, "no_speech_prob": 1.7499516616226174e-05}, {"id": 175, "seek": 102140, "start": 1033.56, "end": 1040.36, "text": " not necessarily the case later. So, in self-attention, the keys, queries, and values come from the", "tokens": [406, 4725, 264, 1389, 1780, 13, 407, 11, 294, 2698, 12, 1591, 1251, 11, 264, 9317, 11, 24109, 11, 293, 4190, 808, 490, 264], "temperature": 0.0, "avg_logprob": -0.20608596491619824, "compression_ratio": 1.854251012145749, "no_speech_prob": 1.7499516616226174e-05}, {"id": 176, "seek": 102140, "start": 1040.36, "end": 1047.04, "text": " same source of information, the same sentence, for example. And so, yeah, in practice, when", "tokens": [912, 4009, 295, 1589, 11, 264, 912, 8174, 11, 337, 1365, 13, 400, 370, 11, 1338, 11, 294, 3124, 11, 562], "temperature": 0.0, "avg_logprob": -0.20608596491619824, "compression_ratio": 1.854251012145749, "no_speech_prob": 1.7499516616226174e-05}, {"id": 177, "seek": 102140, "start": 1047.04, "end": 1050.52, "text": " they all come from the same sentence, right, this is going to be the same number of all of", "tokens": [436, 439, 808, 490, 264, 912, 8174, 11, 558, 11, 341, 307, 516, 281, 312, 264, 912, 1230, 295, 439, 295], "temperature": 0.0, "avg_logprob": -0.20608596491619824, "compression_ratio": 1.854251012145749, "no_speech_prob": 1.7499516616226174e-05}, {"id": 178, "seek": 105052, "start": 1050.52, "end": 1056.36, "text": " them. It's all going to be T. In practice, you can have the numbers differ. So, where do", "tokens": [552, 13, 467, 311, 439, 516, 281, 312, 314, 13, 682, 3124, 11, 291, 393, 362, 264, 3547, 743, 13, 407, 11, 689, 360], "temperature": 0.0, "avg_logprob": -0.13152977728074597, "compression_ratio": 1.7105263157894737, "no_speech_prob": 5.063626667833887e-05}, {"id": 179, "seek": 105052, "start": 1056.36, "end": 1061.28, "text": " these come from? We'll get into the specifics of this later, but for now, think about the", "tokens": [613, 808, 490, 30, 492, 603, 483, 666, 264, 28454, 295, 341, 1780, 11, 457, 337, 586, 11, 519, 466, 264], "temperature": 0.0, "avg_logprob": -0.13152977728074597, "compression_ratio": 1.7105263157894737, "no_speech_prob": 5.063626667833887e-05}, {"id": 180, "seek": 105052, "start": 1061.28, "end": 1066.28, "text": " output of the previous layer. So, imagine the output is, you know, you have like the embedding", "tokens": [5598, 295, 264, 3894, 4583, 13, 407, 11, 3811, 264, 5598, 307, 11, 291, 458, 11, 291, 362, 411, 264, 12240, 3584], "temperature": 0.0, "avg_logprob": -0.13152977728074597, "compression_ratio": 1.7105263157894737, "no_speech_prob": 5.063626667833887e-05}, {"id": 181, "seek": 105052, "start": 1066.28, "end": 1070.4, "text": " layer, right, and that's the input to something that's going to do self-attention. Think of", "tokens": [4583, 11, 558, 11, 293, 300, 311, 264, 4846, 281, 746, 300, 311, 516, 281, 360, 2698, 12, 1591, 1251, 13, 6557, 295], "temperature": 0.0, "avg_logprob": -0.13152977728074597, "compression_ratio": 1.7105263157894737, "no_speech_prob": 5.063626667833887e-05}, {"id": 182, "seek": 105052, "start": 1070.4, "end": 1079.0, "text": " all of these outputs of the embeddings as some vectors x i. And now, we can just say that", "tokens": [439, 295, 613, 23930, 295, 264, 12240, 29432, 382, 512, 18875, 2031, 741, 13, 400, 586, 11, 321, 393, 445, 584, 300], "temperature": 0.0, "avg_logprob": -0.13152977728074597, "compression_ratio": 1.7105263157894737, "no_speech_prob": 5.063626667833887e-05}, {"id": 183, "seek": 107900, "start": 1079.0, "end": 1085.12, "text": " the value is equal to the key, is equal to the query, is equal to that x i. So, we're", "tokens": [264, 2158, 307, 2681, 281, 264, 2141, 11, 307, 2681, 281, 264, 14581, 11, 307, 2681, 281, 300, 2031, 741, 13, 407, 11, 321, 434], "temperature": 0.0, "avg_logprob": -0.15634116188424532, "compression_ratio": 1.772, "no_speech_prob": 8.663643711770419e-06}, {"id": 184, "seek": 107900, "start": 1085.12, "end": 1089.0, "text": " just going to use the same vectors for all of them. But labeling them as keys, queries,", "tokens": [445, 516, 281, 764, 264, 912, 18875, 337, 439, 295, 552, 13, 583, 40244, 552, 382, 9317, 11, 24109, 11], "temperature": 0.0, "avg_logprob": -0.15634116188424532, "compression_ratio": 1.772, "no_speech_prob": 8.663643711770419e-06}, {"id": 185, "seek": 107900, "start": 1089.0, "end": 1093.44, "text": " and values, I promise, will be very useful in how we sort of think about what's going", "tokens": [293, 4190, 11, 286, 6228, 11, 486, 312, 588, 4420, 294, 577, 321, 1333, 295, 519, 466, 437, 311, 516], "temperature": 0.0, "avg_logprob": -0.15634116188424532, "compression_ratio": 1.772, "no_speech_prob": 8.663643711770419e-06}, {"id": 186, "seek": 107900, "start": 1093.44, "end": 1102.4, "text": " on and how we look at the equations that implement this. So, self-attention pretty generally,", "tokens": [322, 293, 577, 321, 574, 412, 264, 11787, 300, 4445, 341, 13, 407, 11, 2698, 12, 1591, 1251, 1238, 5101, 11], "temperature": 0.0, "avg_logprob": -0.15634116188424532, "compression_ratio": 1.772, "no_speech_prob": 8.663643711770419e-06}, {"id": 187, "seek": 107900, "start": 1102.4, "end": 1107.56, "text": " but with this dot product, so, dot product self-attention, here's just the math. Math is,", "tokens": [457, 365, 341, 5893, 1674, 11, 370, 11, 5893, 1674, 2698, 12, 1591, 1251, 11, 510, 311, 445, 264, 5221, 13, 15776, 307, 11], "temperature": 0.0, "avg_logprob": -0.15634116188424532, "compression_ratio": 1.772, "no_speech_prob": 8.663643711770419e-06}, {"id": 188, "seek": 110756, "start": 1107.56, "end": 1113.04, "text": " you compute key query affinities, and the dot product bit is the fact that you're using", "tokens": [291, 14722, 2141, 14581, 2096, 259, 1088, 11, 293, 264, 5893, 1674, 857, 307, 264, 1186, 300, 291, 434, 1228], "temperature": 0.0, "avg_logprob": -0.15001924259146465, "compression_ratio": 1.647887323943662, "no_speech_prob": 3.219003338017501e-05}, {"id": 189, "seek": 110756, "start": 1113.04, "end": 1118.84, "text": " the dot product function here. So, you take a dot product for all pairs i and j of", "tokens": [264, 5893, 1674, 2445, 510, 13, 407, 11, 291, 747, 257, 5893, 1674, 337, 439, 15494, 741, 293, 361, 295], "temperature": 0.0, "avg_logprob": -0.15001924259146465, "compression_ratio": 1.647887323943662, "no_speech_prob": 3.219003338017501e-05}, {"id": 190, "seek": 110756, "start": 1118.84, "end": 1127.84, "text": " qi dotted with kj. So, that is a t by t matrix, capital T, right, by t matrix of affinities.", "tokens": [9505, 72, 37459, 365, 350, 73, 13, 407, 11, 300, 307, 257, 256, 538, 256, 8141, 11, 4238, 314, 11, 558, 11, 538, 256, 8141, 295, 2096, 259, 1088, 13], "temperature": 0.0, "avg_logprob": -0.15001924259146465, "compression_ratio": 1.647887323943662, "no_speech_prob": 3.219003338017501e-05}, {"id": 191, "seek": 110756, "start": 1127.84, "end": 1134.6799999999998, "text": " Those are scalar values not bounded in size. Next, you compute the attention weights we", "tokens": [3950, 366, 39684, 4190, 406, 37498, 294, 2744, 13, 3087, 11, 291, 14722, 264, 3202, 17443, 321], "temperature": 0.0, "avg_logprob": -0.15001924259146465, "compression_ratio": 1.647887323943662, "no_speech_prob": 3.219003338017501e-05}, {"id": 192, "seek": 113468, "start": 1134.68, "end": 1138.3200000000002, "text": " saw this as well, using the softmax function. I've just written out the softmax function", "tokens": [1866, 341, 382, 731, 11, 1228, 264, 2787, 41167, 2445, 13, 286, 600, 445, 3720, 484, 264, 2787, 41167, 2445], "temperature": 0.0, "avg_logprob": -0.14213351117886178, "compression_ratio": 1.836734693877551, "no_speech_prob": 2.8406928322510794e-05}, {"id": 193, "seek": 113468, "start": 1138.3200000000002, "end": 1145.1200000000001, "text": " here. So, you know, you exponentiate the affinity, and then you sum over, in this case,", "tokens": [510, 13, 407, 11, 291, 458, 11, 291, 37871, 13024, 264, 39703, 11, 293, 550, 291, 2408, 670, 11, 294, 341, 1389, 11], "temperature": 0.0, "avg_logprob": -0.14213351117886178, "compression_ratio": 1.836734693877551, "no_speech_prob": 2.8406928322510794e-05}, {"id": 194, "seek": 113468, "start": 1145.1200000000001, "end": 1150.8, "text": " right, you're summing over all of the keys. So, you've got a given query, and you're", "tokens": [558, 11, 291, 434, 2408, 2810, 670, 439, 295, 264, 9317, 13, 407, 11, 291, 600, 658, 257, 2212, 14581, 11, 293, 291, 434], "temperature": 0.0, "avg_logprob": -0.14213351117886178, "compression_ratio": 1.836734693877551, "no_speech_prob": 2.8406928322510794e-05}, {"id": 195, "seek": 113468, "start": 1150.8, "end": 1155.72, "text": " summing over all the keys for the normalization. So, where should this query be looking? Remember,", "tokens": [2408, 2810, 670, 439, 264, 9317, 337, 264, 2710, 2144, 13, 407, 11, 689, 820, 341, 14581, 312, 1237, 30, 5459, 11], "temperature": 0.0, "avg_logprob": -0.14213351117886178, "compression_ratio": 1.836734693877551, "no_speech_prob": 2.8406928322510794e-05}, {"id": 196, "seek": 113468, "start": 1155.72, "end": 1162.52, "text": " you've got t different queries that we're doing this for here. And so, for a given query,", "tokens": [291, 600, 658, 256, 819, 24109, 300, 321, 434, 884, 341, 337, 510, 13, 400, 370, 11, 337, 257, 2212, 14581, 11], "temperature": 0.0, "avg_logprob": -0.14213351117886178, "compression_ratio": 1.836734693877551, "no_speech_prob": 2.8406928322510794e-05}, {"id": 197, "seek": 116252, "start": 1162.52, "end": 1166.8799999999999, "text": " you sum over all the keys to get your normalization constant. Normalizing by that gives you a", "tokens": [291, 2408, 670, 439, 264, 9317, 281, 483, 428, 2710, 2144, 5754, 13, 21277, 3319, 538, 300, 2709, 291, 257], "temperature": 0.0, "avg_logprob": -0.17297201571257217, "compression_ratio": 1.6575342465753424, "no_speech_prob": 3.426416151341982e-05}, {"id": 198, "seek": 116252, "start": 1166.8799999999999, "end": 1173.28, "text": " distribution over the sequence length t. So, now you have sort of a weight on all of the", "tokens": [7316, 670, 264, 8310, 4641, 256, 13, 407, 11, 586, 291, 362, 1333, 295, 257, 3364, 322, 439, 295, 264], "temperature": 0.0, "avg_logprob": -0.17297201571257217, "compression_ratio": 1.6575342465753424, "no_speech_prob": 3.426416151341982e-05}, {"id": 199, "seek": 116252, "start": 1173.28, "end": 1181.12, "text": " sequence indices. And again, we do our weighted average. So, we've got our weights for our", "tokens": [8310, 43840, 13, 400, 797, 11, 321, 360, 527, 32807, 4274, 13, 407, 11, 321, 600, 658, 527, 17443, 337, 527], "temperature": 0.0, "avg_logprob": -0.17297201571257217, "compression_ratio": 1.6575342465753424, "no_speech_prob": 3.426416151341982e-05}, {"id": 200, "seek": 116252, "start": 1181.12, "end": 1186.84, "text": " average, and then the output, right, there's going to be one output per query. The output", "tokens": [4274, 11, 293, 550, 264, 5598, 11, 558, 11, 456, 311, 516, 281, 312, 472, 5598, 680, 14581, 13, 440, 5598], "temperature": 0.0, "avg_logprob": -0.17297201571257217, "compression_ratio": 1.6575342465753424, "no_speech_prob": 3.426416151341982e-05}, {"id": 201, "seek": 118684, "start": 1186.84, "end": 1193.48, "text": " is the weights for that multiplied by the value vectors, right? So, again, if you set the", "tokens": [307, 264, 17443, 337, 300, 17207, 538, 264, 2158, 18875, 11, 558, 30, 407, 11, 797, 11, 498, 291, 992, 264], "temperature": 0.0, "avg_logprob": -0.16532863419631433, "compression_ratio": 1.8122448979591836, "no_speech_prob": 1.7774884327081963e-05}, {"id": 202, "seek": 118684, "start": 1193.48, "end": 1199.6799999999998, "text": " keys, the queries, the values to all be x, this makes sense, but it's nice to have the", "tokens": [9317, 11, 264, 24109, 11, 264, 4190, 281, 439, 312, 2031, 11, 341, 1669, 2020, 11, 457, 309, 311, 1481, 281, 362, 264], "temperature": 0.0, "avg_logprob": -0.16532863419631433, "compression_ratio": 1.8122448979591836, "no_speech_prob": 1.7774884327081963e-05}, {"id": 203, "seek": 118684, "start": 1199.6799999999998, "end": 1204.32, "text": " keys and the keys to know sort of which thing is doing what. You can think of the query", "tokens": [9317, 293, 264, 9317, 281, 458, 1333, 295, 597, 551, 307, 884, 437, 13, 509, 393, 519, 295, 264, 14581], "temperature": 0.0, "avg_logprob": -0.16532863419631433, "compression_ratio": 1.8122448979591836, "no_speech_prob": 1.7774884327081963e-05}, {"id": 204, "seek": 118684, "start": 1204.32, "end": 1209.32, "text": " as being sort of looking for information somewhere, the key as, you know, interacting with", "tokens": [382, 885, 1333, 295, 1237, 337, 1589, 4079, 11, 264, 2141, 382, 11, 291, 458, 11, 18017, 365], "temperature": 0.0, "avg_logprob": -0.16532863419631433, "compression_ratio": 1.8122448979591836, "no_speech_prob": 1.7774884327081963e-05}, {"id": 205, "seek": 118684, "start": 1209.32, "end": 1213.1599999999999, "text": " the query, and then the value is the thing, you know, that you're actually going to, you", "tokens": [264, 14581, 11, 293, 550, 264, 2158, 307, 264, 551, 11, 291, 458, 11, 300, 291, 434, 767, 516, 281, 11, 291], "temperature": 0.0, "avg_logprob": -0.16532863419631433, "compression_ratio": 1.8122448979591836, "no_speech_prob": 1.7774884327081963e-05}, {"id": 206, "seek": 121316, "start": 1213.16, "end": 1220.16, "text": " know, weight in your average and output. So, question you might like to answer is, so", "tokens": [458, 11, 3364, 294, 428, 4274, 293, 5598, 13, 407, 11, 1168, 291, 1062, 411, 281, 1867, 307, 11, 370], "temperature": 0.0, "avg_logprob": -0.17135274133016898, "compression_ratio": 1.7183098591549295, "no_speech_prob": 2.3182497898233123e-05}, {"id": 207, "seek": 121316, "start": 1220.16, "end": 1225.16, "text": " if now we're connecting everything to everything, how is this different to using a fully connected", "tokens": [498, 586, 321, 434, 11015, 1203, 281, 1203, 11, 577, 307, 341, 819, 281, 1228, 257, 4498, 4582], "temperature": 0.0, "avg_logprob": -0.17135274133016898, "compression_ratio": 1.7183098591549295, "no_speech_prob": 2.3182497898233123e-05}, {"id": 208, "seek": 121316, "start": 1225.16, "end": 1233.3600000000001, "text": " layer? That's a great question. A couple of reasons. One is that, unlike a fully connected", "tokens": [4583, 30, 663, 311, 257, 869, 1168, 13, 316, 1916, 295, 4112, 13, 1485, 307, 300, 11, 8343, 257, 4498, 4582], "temperature": 0.0, "avg_logprob": -0.17135274133016898, "compression_ratio": 1.7183098591549295, "no_speech_prob": 2.3182497898233123e-05}, {"id": 209, "seek": 121316, "start": 1233.3600000000001, "end": 1240.64, "text": " layer, you get to learn the interaction weights. Well, the interaction weights are dynamic", "tokens": [4583, 11, 291, 483, 281, 1466, 264, 9285, 17443, 13, 1042, 11, 264, 9285, 17443, 366, 8546], "temperature": 0.0, "avg_logprob": -0.17135274133016898, "compression_ratio": 1.7183098591549295, "no_speech_prob": 2.3182497898233123e-05}, {"id": 210, "seek": 124064, "start": 1240.64, "end": 1246.76, "text": " as a function of what the actual values here are, right? So, in a fully connected layer,", "tokens": [382, 257, 2445, 295, 437, 264, 3539, 4190, 510, 366, 11, 558, 30, 407, 11, 294, 257, 4498, 4582, 4583, 11], "temperature": 0.0, "avg_logprob": -0.1308894905389524, "compression_ratio": 1.6833976833976834, "no_speech_prob": 2.2823123799753375e-05}, {"id": 211, "seek": 124064, "start": 1246.76, "end": 1250.16, "text": " you have these weights that you're learning slowly over the course of the training", "tokens": [291, 362, 613, 17443, 300, 291, 434, 2539, 5692, 670, 264, 1164, 295, 264, 3097], "temperature": 0.0, "avg_logprob": -0.1308894905389524, "compression_ratio": 1.6833976833976834, "no_speech_prob": 2.2823123799753375e-05}, {"id": 212, "seek": 124064, "start": 1250.16, "end": 1255.16, "text": " your network that allow you to say sort of which hidden units you should be looking at.", "tokens": [428, 3209, 300, 2089, 291, 281, 584, 1333, 295, 597, 7633, 6815, 291, 820, 312, 1237, 412, 13], "temperature": 0.0, "avg_logprob": -0.1308894905389524, "compression_ratio": 1.6833976833976834, "no_speech_prob": 2.2823123799753375e-05}, {"id": 213, "seek": 124064, "start": 1255.16, "end": 1261.2, "text": " In attention, it's the actual interactions between the key and the query vectors, which", "tokens": [682, 3202, 11, 309, 311, 264, 3539, 13280, 1296, 264, 2141, 293, 264, 14581, 18875, 11, 597], "temperature": 0.0, "avg_logprob": -0.1308894905389524, "compression_ratio": 1.6833976833976834, "no_speech_prob": 2.2823123799753375e-05}, {"id": 214, "seek": 124064, "start": 1261.2, "end": 1266.0400000000002, "text": " are dependent on the actual content that are allowed to vary by time. And so, the actual", "tokens": [366, 12334, 322, 264, 3539, 2701, 300, 366, 4350, 281, 10559, 538, 565, 13, 400, 370, 11, 264, 3539], "temperature": 0.0, "avg_logprob": -0.1308894905389524, "compression_ratio": 1.6833976833976834, "no_speech_prob": 2.2823123799753375e-05}, {"id": 215, "seek": 126604, "start": 1266.04, "end": 1270.3999999999999, "text": " strengths of all the interactions of all the sort of attention weights, which you could", "tokens": [16986, 295, 439, 264, 13280, 295, 439, 264, 1333, 295, 3202, 17443, 11, 597, 291, 727], "temperature": 0.0, "avg_logprob": -0.11690253303164527, "compression_ratio": 1.899581589958159, "no_speech_prob": 3.882084274664521e-05}, {"id": 216, "seek": 126604, "start": 1270.3999999999999, "end": 1275.68, "text": " think of as, you know, connected to the weights in the fully connected layer, are allowed", "tokens": [519, 295, 382, 11, 291, 458, 11, 4582, 281, 264, 17443, 294, 264, 4498, 4582, 4583, 11, 366, 4350], "temperature": 0.0, "avg_logprob": -0.11690253303164527, "compression_ratio": 1.899581589958159, "no_speech_prob": 3.882084274664521e-05}, {"id": 217, "seek": 126604, "start": 1275.68, "end": 1280.92, "text": " to change as a function of the input. A separate thing is that the parameterization is much", "tokens": [281, 1319, 382, 257, 2445, 295, 264, 4846, 13, 316, 4994, 551, 307, 300, 264, 13075, 2144, 307, 709], "temperature": 0.0, "avg_logprob": -0.11690253303164527, "compression_ratio": 1.899581589958159, "no_speech_prob": 3.882084274664521e-05}, {"id": 218, "seek": 126604, "start": 1280.92, "end": 1286.32, "text": " different. So, you're not learning an independent connection weight for all pairs of things. Instead,", "tokens": [819, 13, 407, 11, 291, 434, 406, 2539, 364, 6695, 4984, 3364, 337, 439, 15494, 295, 721, 13, 7156, 11], "temperature": 0.0, "avg_logprob": -0.11690253303164527, "compression_ratio": 1.899581589958159, "no_speech_prob": 3.882084274664521e-05}, {"id": 219, "seek": 126604, "start": 1286.32, "end": 1294.32, "text": " you have, you're allowed to parameterize the attention as, you know, these sort of", "tokens": [291, 362, 11, 291, 434, 4350, 281, 13075, 1125, 264, 3202, 382, 11, 291, 458, 11, 613, 1333, 295], "temperature": 0.0, "avg_logprob": -0.11690253303164527, "compression_ratio": 1.899581589958159, "no_speech_prob": 3.882084274664521e-05}, {"id": 220, "seek": 129432, "start": 1294.32, "end": 1298.6799999999998, "text": " dot product functions between vectors that are representations. And you end up having,", "tokens": [5893, 1674, 6828, 1296, 18875, 300, 366, 33358, 13, 400, 291, 917, 493, 1419, 11], "temperature": 0.0, "avg_logprob": -0.17834569757634944, "compression_ratio": 1.717557251908397, "no_speech_prob": 8.748745312914252e-05}, {"id": 221, "seek": 129432, "start": 1298.6799999999998, "end": 1304.9199999999998, "text": " you know, the parameters work out more nicely, which we'll see later. We haven't gone into", "tokens": [291, 458, 11, 264, 9834, 589, 484, 544, 9594, 11, 597, 321, 603, 536, 1780, 13, 492, 2378, 380, 2780, 666], "temperature": 0.0, "avg_logprob": -0.17834569757634944, "compression_ratio": 1.717557251908397, "no_speech_prob": 8.748745312914252e-05}, {"id": 222, "seek": 129432, "start": 1304.9199999999998, "end": 1308.76, "text": " how we're parameterizing these functions yet. So, those are the two answers, I'd say,", "tokens": [577, 321, 434, 13075, 3319, 613, 6828, 1939, 13, 407, 11, 729, 366, 264, 732, 6338, 11, 286, 1116, 584, 11], "temperature": 0.0, "avg_logprob": -0.17834569757634944, "compression_ratio": 1.717557251908397, "no_speech_prob": 8.748745312914252e-05}, {"id": 223, "seek": 129432, "start": 1308.76, "end": 1314.48, "text": " is one is you have this sort of dynamic connectivity. And two is, you know, you don't have just,", "tokens": [307, 472, 307, 291, 362, 341, 1333, 295, 8546, 21095, 13, 400, 732, 307, 11, 291, 458, 11, 291, 500, 380, 362, 445, 11], "temperature": 0.0, "avg_logprob": -0.17834569757634944, "compression_ratio": 1.717557251908397, "no_speech_prob": 8.748745312914252e-05}, {"id": 224, "seek": 129432, "start": 1314.48, "end": 1319.56, "text": " it has this inductive bias that's not just connect everything to everything feed forward.", "tokens": [309, 575, 341, 31612, 488, 12577, 300, 311, 406, 445, 1745, 1203, 281, 1203, 3154, 2128, 13], "temperature": 0.0, "avg_logprob": -0.17834569757634944, "compression_ratio": 1.717557251908397, "no_speech_prob": 8.748745312914252e-05}, {"id": 225, "seek": 131956, "start": 1319.56, "end": 1329.12, "text": " Great. Okay, I think that's a very interesting question. Yeah, so I'm glad you asked it.", "tokens": [3769, 13, 1033, 11, 286, 519, 300, 311, 257, 588, 1880, 1168, 13, 865, 11, 370, 286, 478, 5404, 291, 2351, 309, 13], "temperature": 0.0, "avg_logprob": -0.20272382100423178, "compression_ratio": 1.6842105263157894, "no_speech_prob": 0.00011228729272261262}, {"id": 226, "seek": 131956, "start": 1329.12, "end": 1334.32, "text": " Okay, so, we've talked about self-attention now. The equations are going to self-attention.", "tokens": [1033, 11, 370, 11, 321, 600, 2825, 466, 2698, 12, 1591, 1251, 586, 13, 440, 11787, 366, 516, 281, 2698, 12, 1591, 1251, 13], "temperature": 0.0, "avg_logprob": -0.20272382100423178, "compression_ratio": 1.6842105263157894, "no_speech_prob": 0.00011228729272261262}, {"id": 227, "seek": 131956, "start": 1334.32, "end": 1339.24, "text": " But, can we just like use this as a building block? I mean, you know, take all of your LSTMs,", "tokens": [583, 11, 393, 321, 445, 411, 764, 341, 382, 257, 2390, 3461, 30, 286, 914, 11, 291, 458, 11, 747, 439, 295, 428, 441, 6840, 26386, 11], "temperature": 0.0, "avg_logprob": -0.20272382100423178, "compression_ratio": 1.6842105263157894, "no_speech_prob": 0.00011228729272261262}, {"id": 228, "seek": 131956, "start": 1339.24, "end": 1342.76, "text": " throw them out. Use the self-attention that we've just defined instead. Why not? Well,", "tokens": [3507, 552, 484, 13, 8278, 264, 2698, 12, 1591, 1251, 300, 321, 600, 445, 7642, 2602, 13, 1545, 406, 30, 1042, 11], "temperature": 0.0, "avg_logprob": -0.20272382100423178, "compression_ratio": 1.6842105263157894, "no_speech_prob": 0.00011228729272261262}, {"id": 229, "seek": 131956, "start": 1342.76, "end": 1348.6399999999999, "text": " here's a couple of reasons why. So, look at self-attention as a building block. So, we", "tokens": [510, 311, 257, 1916, 295, 4112, 983, 13, 407, 11, 574, 412, 2698, 12, 1591, 1251, 382, 257, 2390, 3461, 13, 407, 11, 321], "temperature": 0.0, "avg_logprob": -0.20272382100423178, "compression_ratio": 1.6842105263157894, "no_speech_prob": 0.00011228729272261262}, {"id": 230, "seek": 134864, "start": 1348.64, "end": 1355.92, "text": " have some words in the sentence, the chef who, some stuff, long sentence, food is the last", "tokens": [362, 512, 2283, 294, 264, 8174, 11, 264, 10530, 567, 11, 512, 1507, 11, 938, 8174, 11, 1755, 307, 264, 1036], "temperature": 0.0, "avg_logprob": -0.17171921805729942, "compression_ratio": 1.8823529411764706, "no_speech_prob": 3.704181290231645e-05}, {"id": 231, "seek": 134864, "start": 1355.92, "end": 1361.3200000000002, "text": " word of the sentence. Okay. And, you know, they have an embedding. And from that, you get", "tokens": [1349, 295, 264, 8174, 13, 1033, 13, 400, 11, 291, 458, 11, 436, 362, 364, 12240, 3584, 13, 400, 490, 300, 11, 291, 483], "temperature": 0.0, "avg_logprob": -0.17171921805729942, "compression_ratio": 1.8823529411764706, "no_speech_prob": 3.704181290231645e-05}, {"id": 232, "seek": 134864, "start": 1361.3200000000002, "end": 1366.44, "text": " your key query in value. We've said so far, right, there's the same vector actually, but,", "tokens": [428, 2141, 14581, 294, 2158, 13, 492, 600, 848, 370, 1400, 11, 558, 11, 456, 311, 264, 912, 8062, 767, 11, 457, 11], "temperature": 0.0, "avg_logprob": -0.17171921805729942, "compression_ratio": 1.8823529411764706, "no_speech_prob": 3.704181290231645e-05}, {"id": 233, "seek": 134864, "start": 1366.44, "end": 1371.3200000000002, "text": " you know, key query value, key query value, key query value. And, you know, we might stack", "tokens": [291, 458, 11, 2141, 14581, 2158, 11, 2141, 14581, 2158, 11, 2141, 14581, 2158, 13, 400, 11, 291, 458, 11, 321, 1062, 8630], "temperature": 0.0, "avg_logprob": -0.17171921805729942, "compression_ratio": 1.8823529411764706, "no_speech_prob": 3.704181290231645e-05}, {"id": 234, "seek": 134864, "start": 1371.3200000000002, "end": 1375.96, "text": " them like LSTM layers. So, you have key query value, perform self-attention on the key", "tokens": [552, 411, 441, 6840, 44, 7914, 13, 407, 11, 291, 362, 2141, 14581, 2158, 11, 2042, 2698, 12, 1591, 1251, 322, 264, 2141], "temperature": 0.0, "avg_logprob": -0.17171921805729942, "compression_ratio": 1.8823529411764706, "no_speech_prob": 3.704181290231645e-05}, {"id": 235, "seek": 137596, "start": 1375.96, "end": 1380.3600000000001, "text": " queries and values. As we said, self-attention is a function on key queries and values.", "tokens": [24109, 293, 4190, 13, 1018, 321, 848, 11, 2698, 12, 1591, 1251, 307, 257, 2445, 322, 2141, 24109, 293, 4190, 13], "temperature": 0.0, "avg_logprob": -0.13038004725432592, "compression_ratio": 1.7918367346938775, "no_speech_prob": 2.8404399927239865e-05}, {"id": 236, "seek": 137596, "start": 1380.3600000000001, "end": 1385.56, "text": " So, perform self-attention now that you have these, get new key queries values, and then", "tokens": [407, 11, 2042, 2698, 12, 1591, 1251, 586, 300, 291, 362, 613, 11, 483, 777, 2141, 24109, 4190, 11, 293, 550], "temperature": 0.0, "avg_logprob": -0.13038004725432592, "compression_ratio": 1.7918367346938775, "no_speech_prob": 2.8404399927239865e-05}, {"id": 237, "seek": 137596, "start": 1385.56, "end": 1390.1200000000001, "text": " perform self-attention again. Look, you know, this looks a lot like, a lot like stacking", "tokens": [2042, 2698, 12, 1591, 1251, 797, 13, 2053, 11, 291, 458, 11, 341, 1542, 257, 688, 411, 11, 257, 688, 411, 41376], "temperature": 0.0, "avg_logprob": -0.13038004725432592, "compression_ratio": 1.7918367346938775, "no_speech_prob": 2.8404399927239865e-05}, {"id": 238, "seek": 137596, "start": 1390.1200000000001, "end": 1395.08, "text": " LSTMs. But, it actually has a few issues as it stands. So, we're going to need to go on", "tokens": [441, 6840, 26386, 13, 583, 11, 309, 767, 575, 257, 1326, 2663, 382, 309, 7382, 13, 407, 11, 321, 434, 516, 281, 643, 281, 352, 322], "temperature": 0.0, "avg_logprob": -0.13038004725432592, "compression_ratio": 1.7918367346938775, "no_speech_prob": 2.8404399927239865e-05}, {"id": 239, "seek": 137596, "start": 1395.08, "end": 1399.64, "text": " a journey to determine what's missing from our self-attention. And the first thing is", "tokens": [257, 4671, 281, 6997, 437, 311, 5361, 490, 527, 2698, 12, 1591, 1251, 13, 400, 264, 700, 551, 307], "temperature": 0.0, "avg_logprob": -0.13038004725432592, "compression_ratio": 1.7918367346938775, "no_speech_prob": 2.8404399927239865e-05}, {"id": 240, "seek": 139964, "start": 1399.64, "end": 1407.96, "text": " that self-attention is an operation on sets. Okay. So, for the equations that we had before,", "tokens": [300, 2698, 12, 1591, 1251, 307, 364, 6916, 322, 6352, 13, 1033, 13, 407, 11, 337, 264, 11787, 300, 321, 632, 949, 11], "temperature": 0.0, "avg_logprob": -0.13655813535054526, "compression_ratio": 1.6199261992619927, "no_speech_prob": 2.7096617486677133e-05}, {"id": 241, "seek": 139964, "start": 1407.96, "end": 1414.0400000000002, "text": " the self-attention equation never referred to the indices of K, Q, or V, except to sort", "tokens": [264, 2698, 12, 1591, 1251, 5367, 1128, 10839, 281, 264, 43840, 295, 591, 11, 1249, 11, 420, 691, 11, 3993, 281, 1333], "temperature": 0.0, "avg_logprob": -0.13655813535054526, "compression_ratio": 1.6199261992619927, "no_speech_prob": 2.7096617486677133e-05}, {"id": 242, "seek": 139964, "start": 1414.0400000000002, "end": 1418.0, "text": " of say which pairs we're interacting with each other. It doesn't know what the order", "tokens": [295, 584, 597, 15494, 321, 434, 18017, 365, 1184, 661, 13, 467, 1177, 380, 458, 437, 264, 1668], "temperature": 0.0, "avg_logprob": -0.13655813535054526, "compression_ratio": 1.6199261992619927, "no_speech_prob": 2.7096617486677133e-05}, {"id": 243, "seek": 139964, "start": 1418.0, "end": 1422.96, "text": " of your sentence is. When it's computing, though, the weights, it has no idea. And so,", "tokens": [295, 428, 8174, 307, 13, 1133, 309, 311, 15866, 11, 1673, 11, 264, 17443, 11, 309, 575, 572, 1558, 13, 400, 370, 11], "temperature": 0.0, "avg_logprob": -0.13655813535054526, "compression_ratio": 1.6199261992619927, "no_speech_prob": 2.7096617486677133e-05}, {"id": 244, "seek": 139964, "start": 1422.96, "end": 1428.0800000000002, "text": " if I were to input this sentence, the chef who food, it would be the same as if I just", "tokens": [498, 286, 645, 281, 4846, 341, 8174, 11, 264, 10530, 567, 1755, 11, 309, 576, 312, 264, 912, 382, 498, 286, 445], "temperature": 0.0, "avg_logprob": -0.13655813535054526, "compression_ratio": 1.6199261992619927, "no_speech_prob": 2.7096617486677133e-05}, {"id": 245, "seek": 142808, "start": 1428.08, "end": 1434.1599999999999, "text": " swapped the with chef and then swapped who with the, and it just had, would have no idea.", "tokens": [50011, 264, 365, 10530, 293, 550, 50011, 567, 365, 264, 11, 293, 309, 445, 632, 11, 576, 362, 572, 1558, 13], "temperature": 0.0, "avg_logprob": -0.19065468451556036, "compression_ratio": 1.8620689655172413, "no_speech_prob": 1.982935646083206e-05}, {"id": 246, "seek": 142808, "start": 1434.1599999999999, "end": 1438.84, "text": " So, already this is not going to work because the order in which words appear in sentences", "tokens": [407, 11, 1217, 341, 307, 406, 516, 281, 589, 570, 264, 1668, 294, 597, 2283, 4204, 294, 16579], "temperature": 0.0, "avg_logprob": -0.19065468451556036, "compression_ratio": 1.8620689655172413, "no_speech_prob": 1.982935646083206e-05}, {"id": 247, "seek": 142808, "start": 1438.84, "end": 1443.6799999999998, "text": " matters. So, here's the first problem that we need to work with. So, I'm going to have", "tokens": [7001, 13, 407, 11, 510, 311, 264, 700, 1154, 300, 321, 643, 281, 589, 365, 13, 407, 11, 286, 478, 516, 281, 362], "temperature": 0.0, "avg_logprob": -0.19065468451556036, "compression_ratio": 1.8620689655172413, "no_speech_prob": 1.982935646083206e-05}, {"id": 248, "seek": 142808, "start": 1443.6799999999998, "end": 1447.4399999999998, "text": " a list of barriers. This is just the first, I had a whole journey ahead of us. And then", "tokens": [257, 1329, 295, 13565, 13, 639, 307, 445, 264, 700, 11, 286, 632, 257, 1379, 4671, 2286, 295, 505, 13, 400, 550], "temperature": 0.0, "avg_logprob": -0.19065468451556036, "compression_ratio": 1.8620689655172413, "no_speech_prob": 1.982935646083206e-05}, {"id": 249, "seek": 142808, "start": 1447.4399999999998, "end": 1452.6799999999998, "text": " we're going to have a list of solutions. So, we need to represent the sequence order somehow.", "tokens": [321, 434, 516, 281, 362, 257, 1329, 295, 6547, 13, 407, 11, 321, 643, 281, 2906, 264, 8310, 1668, 6063, 13], "temperature": 0.0, "avg_logprob": -0.19065468451556036, "compression_ratio": 1.8620689655172413, "no_speech_prob": 1.982935646083206e-05}, {"id": 250, "seek": 142808, "start": 1452.6799999999998, "end": 1456.4399999999998, "text": " We can't just lose that information entirely because we wouldn't know what order the words", "tokens": [492, 393, 380, 445, 3624, 300, 1589, 7696, 570, 321, 2759, 380, 458, 437, 1668, 264, 2283], "temperature": 0.0, "avg_logprob": -0.19065468451556036, "compression_ratio": 1.8620689655172413, "no_speech_prob": 1.982935646083206e-05}, {"id": 251, "seek": 145644, "start": 1456.44, "end": 1462.0, "text": " showed up in. So, somehow, if we're not going to change the self-attention equations", "tokens": [4712, 493, 294, 13, 407, 11, 6063, 11, 498, 321, 434, 406, 516, 281, 1319, 264, 2698, 12, 1591, 1251, 11787], "temperature": 0.0, "avg_logprob": -0.16260111230051416, "compression_ratio": 1.74, "no_speech_prob": 7.719794666627422e-05}, {"id": 252, "seek": 145644, "start": 1462.0, "end": 1468.48, "text": " themselves, we need to encode the order in the keys, queries, and values, and let the", "tokens": [2969, 11, 321, 643, 281, 2058, 1429, 264, 1668, 294, 264, 9317, 11, 24109, 11, 293, 4190, 11, 293, 718, 264], "temperature": 0.0, "avg_logprob": -0.16260111230051416, "compression_ratio": 1.74, "no_speech_prob": 7.719794666627422e-05}, {"id": 253, "seek": 145644, "start": 1468.48, "end": 1475.28, "text": " network sort of figure it out on its own. So, think about this. We have T sequence indices.", "tokens": [3209, 1333, 295, 2573, 309, 484, 322, 1080, 1065, 13, 407, 11, 519, 466, 341, 13, 492, 362, 314, 8310, 43840, 13], "temperature": 0.0, "avg_logprob": -0.16260111230051416, "compression_ratio": 1.74, "no_speech_prob": 7.719794666627422e-05}, {"id": 254, "seek": 145644, "start": 1475.28, "end": 1480.48, "text": " And we're going to bound T to some finite constant. So, T is never going to be bigger", "tokens": [400, 321, 434, 516, 281, 5472, 314, 281, 512, 19362, 5754, 13, 407, 11, 314, 307, 1128, 516, 281, 312, 3801], "temperature": 0.0, "avg_logprob": -0.16260111230051416, "compression_ratio": 1.74, "no_speech_prob": 7.719794666627422e-05}, {"id": 255, "seek": 145644, "start": 1480.48, "end": 1485.56, "text": " than something for us. And we call it T. And now we're going to represent the sequence", "tokens": [813, 746, 337, 505, 13, 400, 321, 818, 309, 314, 13, 400, 586, 321, 434, 516, 281, 2906, 264, 8310], "temperature": 0.0, "avg_logprob": -0.16260111230051416, "compression_ratio": 1.74, "no_speech_prob": 7.719794666627422e-05}, {"id": 256, "seek": 148556, "start": 1485.56, "end": 1491.24, "text": " index as a vector. So, PI is going to be the vector representing index I. And it's going", "tokens": [8186, 382, 257, 8062, 13, 407, 11, 27176, 307, 516, 281, 312, 264, 8062, 13460, 8186, 286, 13, 400, 309, 311, 516], "temperature": 0.0, "avg_logprob": -0.14597310858257748, "compression_ratio": 1.6195652173913044, "no_speech_prob": 7.140386151149869e-05}, {"id": 257, "seek": 148556, "start": 1491.24, "end": 1495.52, "text": " to be in dimensionality D just like our keys, queries, and values. And so, we're going", "tokens": [281, 312, 294, 10139, 1860, 413, 445, 411, 527, 9317, 11, 24109, 11, 293, 4190, 13, 400, 370, 11, 321, 434, 516], "temperature": 0.0, "avg_logprob": -0.14597310858257748, "compression_ratio": 1.6195652173913044, "no_speech_prob": 7.140386151149869e-05}, {"id": 258, "seek": 148556, "start": 1495.52, "end": 1501.56, "text": " to have one of these for one to T. So, don't worry yet about what the PI are like, how", "tokens": [281, 362, 472, 295, 613, 337, 472, 281, 314, 13, 407, 11, 500, 380, 3292, 1939, 466, 437, 264, 27176, 366, 411, 11, 577], "temperature": 0.0, "avg_logprob": -0.14597310858257748, "compression_ratio": 1.6195652173913044, "no_speech_prob": 7.140386151149869e-05}, {"id": 259, "seek": 148556, "start": 1501.56, "end": 1506.04, "text": " they're constructed. We'll get right into that. But think about this. It's easy to incorporate", "tokens": [436, 434, 17083, 13, 492, 603, 483, 558, 666, 300, 13, 583, 519, 466, 341, 13, 467, 311, 1858, 281, 16091], "temperature": 0.0, "avg_logprob": -0.14597310858257748, "compression_ratio": 1.6195652173913044, "no_speech_prob": 7.140386151149869e-05}, {"id": 260, "seek": 148556, "start": 1506.04, "end": 1511.48, "text": " this information into our attention building blocks. At the first layer, if you let tilde", "tokens": [341, 1589, 666, 527, 3202, 2390, 8474, 13, 1711, 264, 700, 4583, 11, 498, 291, 718, 45046], "temperature": 0.0, "avg_logprob": -0.14597310858257748, "compression_ratio": 1.6195652173913044, "no_speech_prob": 7.140386151149869e-05}, {"id": 261, "seek": 151148, "start": 1511.48, "end": 1519.04, "text": " V tilde K tilde Q be our old values keys and queries, we can just add. We could do other", "tokens": [691, 45046, 591, 45046, 1249, 312, 527, 1331, 4190, 9317, 293, 24109, 11, 321, 393, 445, 909, 13, 492, 727, 360, 661], "temperature": 0.0, "avg_logprob": -0.1762090944776348, "compression_ratio": 1.5913043478260869, "no_speech_prob": 3.535267023835331e-05}, {"id": 262, "seek": 151148, "start": 1519.04, "end": 1525.2, "text": " stuff too. But in practice, we just add. So, VI is equal to V tilde I, our orderless value", "tokens": [1507, 886, 13, 583, 294, 3124, 11, 321, 445, 909, 13, 407, 11, 27619, 307, 2681, 281, 691, 45046, 286, 11, 527, 1668, 1832, 2158], "temperature": 0.0, "avg_logprob": -0.1762090944776348, "compression_ratio": 1.5913043478260869, "no_speech_prob": 3.535267023835331e-05}, {"id": 263, "seek": 151148, "start": 1525.2, "end": 1533.56, "text": " vector plus PI. So, this might be your embedding vector. And then you add the index that it's", "tokens": [8062, 1804, 27176, 13, 407, 11, 341, 1062, 312, 428, 12240, 3584, 8062, 13, 400, 550, 291, 909, 264, 8186, 300, 309, 311], "temperature": 0.0, "avg_logprob": -0.1762090944776348, "compression_ratio": 1.5913043478260869, "no_speech_prob": 3.535267023835331e-05}, {"id": 264, "seek": 151148, "start": 1533.56, "end": 1539.3600000000001, "text": " at to its vector. And you might only do this at the first layer of the network, for example.", "tokens": [412, 281, 1080, 8062, 13, 400, 291, 1062, 787, 360, 341, 412, 264, 700, 4583, 295, 264, 3209, 11, 337, 1365, 13], "temperature": 0.0, "avg_logprob": -0.1762090944776348, "compression_ratio": 1.5913043478260869, "no_speech_prob": 3.535267023835331e-05}, {"id": 265, "seek": 153936, "start": 1539.36, "end": 1542.1999999999998, "text": " So you do the same thing for the query and the key. So, this is something that you could", "tokens": [407, 291, 360, 264, 912, 551, 337, 264, 14581, 293, 264, 2141, 13, 407, 11, 341, 307, 746, 300, 291, 727], "temperature": 0.0, "avg_logprob": -0.15897176976789507, "compression_ratio": 1.7568627450980392, "no_speech_prob": 4.539014844340272e-05}, {"id": 266, "seek": 153936, "start": 1542.1999999999998, "end": 1548.7199999999998, "text": " do. In practice, you do something slightly different. But this is something that, you know,", "tokens": [360, 13, 682, 3124, 11, 291, 360, 746, 4748, 819, 13, 583, 341, 307, 746, 300, 11, 291, 458, 11], "temperature": 0.0, "avg_logprob": -0.15897176976789507, "compression_ratio": 1.7568627450980392, "no_speech_prob": 4.539014844340272e-05}, {"id": 267, "seek": 153936, "start": 1548.7199999999998, "end": 1555.6, "text": " now it knows the order of the sequence. Because if these PI's, you've set properly somehow,", "tokens": [586, 309, 3255, 264, 1668, 295, 264, 8310, 13, 1436, 498, 613, 27176, 311, 11, 291, 600, 992, 6108, 6063, 11], "temperature": 0.0, "avg_logprob": -0.15897176976789507, "compression_ratio": 1.7568627450980392, "no_speech_prob": 4.539014844340272e-05}, {"id": 268, "seek": 153936, "start": 1555.6, "end": 1560.08, "text": " then now the network is able to figure out what to do with it. So, what's one way of actually", "tokens": [550, 586, 264, 3209, 307, 1075, 281, 2573, 484, 437, 281, 360, 365, 309, 13, 407, 11, 437, 311, 472, 636, 295, 767], "temperature": 0.0, "avg_logprob": -0.15897176976789507, "compression_ratio": 1.7568627450980392, "no_speech_prob": 4.539014844340272e-05}, {"id": 269, "seek": 153936, "start": 1560.08, "end": 1568.0, "text": " making this happen? One way of making this happen is through the concatenation of", "tokens": [1455, 341, 1051, 30, 1485, 636, 295, 1455, 341, 1051, 307, 807, 264, 1588, 7186, 399, 295], "temperature": 0.0, "avg_logprob": -0.15897176976789507, "compression_ratio": 1.7568627450980392, "no_speech_prob": 4.539014844340272e-05}, {"id": 270, "seek": 156800, "start": 1568.0, "end": 1572.96, "text": " synosoids. And this was an interesting take when the first transformer's paper came out,", "tokens": [5451, 9869, 3742, 13, 400, 341, 390, 364, 1880, 747, 562, 264, 700, 31782, 311, 3035, 1361, 484, 11], "temperature": 0.0, "avg_logprob": -0.1863290769559843, "compression_ratio": 1.8874458874458875, "no_speech_prob": 9.912435780279338e-05}, {"id": 271, "seek": 156800, "start": 1572.96, "end": 1579.44, "text": " they used this method. So, let's dig into it. So, you have varying wavelengths of", "tokens": [436, 1143, 341, 3170, 13, 407, 11, 718, 311, 2528, 666, 309, 13, 407, 11, 291, 362, 22984, 47424, 295], "temperature": 0.0, "avg_logprob": -0.1863290769559843, "compression_ratio": 1.8874458874458875, "no_speech_prob": 9.912435780279338e-05}, {"id": 272, "seek": 156800, "start": 1579.44, "end": 1584.64, "text": " sinusoidal functions in each of your dimensions. So, in the first dimension, if you have this", "tokens": [41503, 17079, 304, 6828, 294, 1184, 295, 428, 12819, 13, 407, 11, 294, 264, 700, 10139, 11, 498, 291, 362, 341], "temperature": 0.0, "avg_logprob": -0.1863290769559843, "compression_ratio": 1.8874458874458875, "no_speech_prob": 9.912435780279338e-05}, {"id": 273, "seek": 156800, "start": 1584.64, "end": 1589.44, "text": " sine function with a given period, and then this cosine function with a given period,", "tokens": [18609, 2445, 365, 257, 2212, 2896, 11, 293, 550, 341, 23565, 2445, 365, 257, 2212, 2896, 11], "temperature": 0.0, "avg_logprob": -0.1863290769559843, "compression_ratio": 1.8874458874458875, "no_speech_prob": 9.912435780279338e-05}, {"id": 274, "seek": 156800, "start": 1589.44, "end": 1594.88, "text": " and then sort of dot, dot, dot, you sort of change the periods until you get to much,", "tokens": [293, 550, 1333, 295, 5893, 11, 5893, 11, 5893, 11, 291, 1333, 295, 1319, 264, 13804, 1826, 291, 483, 281, 709, 11], "temperature": 0.0, "avg_logprob": -0.1863290769559843, "compression_ratio": 1.8874458874458875, "no_speech_prob": 9.912435780279338e-05}, {"id": 275, "seek": 159488, "start": 1594.88, "end": 1598.72, "text": " different periods. And what does it look like? It looks like that. So, imagine here,", "tokens": [819, 13804, 13, 400, 437, 775, 309, 574, 411, 30, 467, 1542, 411, 300, 13, 407, 11, 3811, 510, 11], "temperature": 0.0, "avg_logprob": -0.1314877445257983, "compression_ratio": 1.6475409836065573, "no_speech_prob": 3.0710096325492486e-05}, {"id": 276, "seek": 159488, "start": 1599.6000000000001, "end": 1605.68, "text": " in the vertical axis, we've got the dimensionality of the network. So, this is D,", "tokens": [294, 264, 9429, 10298, 11, 321, 600, 658, 264, 10139, 1860, 295, 264, 3209, 13, 407, 11, 341, 307, 413, 11], "temperature": 0.0, "avg_logprob": -0.1314877445257983, "compression_ratio": 1.6475409836065573, "no_speech_prob": 3.0710096325492486e-05}, {"id": 277, "seek": 159488, "start": 1606.64, "end": 1611.44, "text": " and then this is sequence length. And by just specifying, you know, in each row,", "tokens": [293, 550, 341, 307, 8310, 4641, 13, 400, 538, 445, 1608, 5489, 11, 291, 458, 11, 294, 1184, 5386, 11], "temperature": 0.0, "avg_logprob": -0.1314877445257983, "compression_ratio": 1.6475409836065573, "no_speech_prob": 3.0710096325492486e-05}, {"id": 278, "seek": 159488, "start": 1611.44, "end": 1615.2, "text": " is sort of one of these signs with different frequencies.", "tokens": [307, 1333, 295, 472, 295, 613, 7880, 365, 819, 20250, 13], "temperature": 0.0, "avg_logprob": -0.1314877445257983, "compression_ratio": 1.6475409836065573, "no_speech_prob": 3.0710096325492486e-05}, {"id": 279, "seek": 159488, "start": 1616.72, "end": 1621.3600000000001, "text": " Right? And you can sort of see how this is encoding position. These things have different values", "tokens": [1779, 30, 400, 291, 393, 1333, 295, 536, 577, 341, 307, 43430, 2535, 13, 1981, 721, 362, 819, 4190], "temperature": 0.0, "avg_logprob": -0.1314877445257983, "compression_ratio": 1.6475409836065573, "no_speech_prob": 3.0710096325492486e-05}, {"id": 280, "seek": 162136, "start": 1621.36, "end": 1627.6799999999998, "text": " at different indices, and that's pretty cool. I don't really know how they thought of it", "tokens": [412, 819, 43840, 11, 293, 300, 311, 1238, 1627, 13, 286, 500, 380, 534, 458, 577, 436, 1194, 295, 309], "temperature": 0.0, "avg_logprob": -0.1264048899923052, "compression_ratio": 1.7657992565055762, "no_speech_prob": 8.938572136685252e-06}, {"id": 281, "seek": 162136, "start": 1627.6799999999998, "end": 1632.7199999999998, "text": " immediately. But one cool thing about it is this periodicity notion. Right? The fact that", "tokens": [4258, 13, 583, 472, 1627, 551, 466, 309, 307, 341, 27790, 507, 10710, 13, 1779, 30, 440, 1186, 300], "temperature": 0.0, "avg_logprob": -0.1264048899923052, "compression_ratio": 1.7657992565055762, "no_speech_prob": 8.938572136685252e-06}, {"id": 282, "seek": 162136, "start": 1632.7199999999998, "end": 1637.76, "text": " the synosoids have periods that might be less than the sequence length indicates that maybe the", "tokens": [264, 5451, 9869, 3742, 362, 13804, 300, 1062, 312, 1570, 813, 264, 8310, 4641, 16203, 300, 1310, 264], "temperature": 0.0, "avg_logprob": -0.1264048899923052, "compression_ratio": 1.7657992565055762, "no_speech_prob": 8.938572136685252e-06}, {"id": 283, "seek": 162136, "start": 1637.76, "end": 1644.0, "text": " absolute position of a word isn't so important. Right? Because if the period is less than the sequence", "tokens": [8236, 2535, 295, 257, 1349, 1943, 380, 370, 1021, 13, 1779, 30, 1436, 498, 264, 2896, 307, 1570, 813, 264, 8310], "temperature": 0.0, "avg_logprob": -0.1264048899923052, "compression_ratio": 1.7657992565055762, "no_speech_prob": 8.938572136685252e-06}, {"id": 284, "seek": 162136, "start": 1644.0, "end": 1648.08, "text": " length, you lose information, maybe about where you are. Of course, you have the concatenation of", "tokens": [4641, 11, 291, 3624, 1589, 11, 1310, 466, 689, 291, 366, 13, 2720, 1164, 11, 291, 362, 264, 1588, 7186, 399, 295], "temperature": 0.0, "avg_logprob": -0.1264048899923052, "compression_ratio": 1.7657992565055762, "no_speech_prob": 8.938572136685252e-06}, {"id": 285, "seek": 164808, "start": 1648.08, "end": 1654.3999999999999, "text": " many of them. So, that's a pro. Maybe it can extrapolate to longer sequences, because again,", "tokens": [867, 295, 552, 13, 407, 11, 300, 311, 257, 447, 13, 2704, 309, 393, 48224, 473, 281, 2854, 22978, 11, 570, 797, 11], "temperature": 0.0, "avg_logprob": -0.11541495323181153, "compression_ratio": 1.6727941176470589, "no_speech_prob": 1.9521361537044868e-05}, {"id": 286, "seek": 164808, "start": 1654.3999999999999, "end": 1659.6799999999998, "text": " you sort of have this repetition of values, right? Because the periods will, when they,", "tokens": [291, 1333, 295, 362, 341, 30432, 295, 4190, 11, 558, 30, 1436, 264, 13804, 486, 11, 562, 436, 11], "temperature": 0.0, "avg_logprob": -0.11541495323181153, "compression_ratio": 1.6727941176470589, "no_speech_prob": 1.9521361537044868e-05}, {"id": 287, "seek": 164808, "start": 1659.6799999999998, "end": 1663.76, "text": " when they complete, you'll see that value again. The cons are that it's not learnable. I mean,", "tokens": [562, 436, 3566, 11, 291, 603, 536, 300, 2158, 797, 13, 440, 1014, 366, 300, 309, 311, 406, 1466, 712, 13, 286, 914, 11], "temperature": 0.0, "avg_logprob": -0.11541495323181153, "compression_ratio": 1.6727941176470589, "no_speech_prob": 1.9521361537044868e-05}, {"id": 288, "seek": 164808, "start": 1663.76, "end": 1668.3999999999999, "text": " this is cool, but you can't, there's no learnable parameters in any of this. And also,", "tokens": [341, 307, 1627, 11, 457, 291, 393, 380, 11, 456, 311, 572, 1466, 712, 9834, 294, 604, 295, 341, 13, 400, 611, 11], "temperature": 0.0, "avg_logprob": -0.11541495323181153, "compression_ratio": 1.6727941176470589, "no_speech_prob": 1.9521361537044868e-05}, {"id": 289, "seek": 164808, "start": 1668.3999999999999, "end": 1672.3999999999999, "text": " the extrapolation doesn't really work. So, this is an interesting and definitely still done.", "tokens": [264, 48224, 399, 1177, 380, 534, 589, 13, 407, 11, 341, 307, 364, 1880, 293, 2138, 920, 1096, 13], "temperature": 0.0, "avg_logprob": -0.11541495323181153, "compression_ratio": 1.6727941176470589, "no_speech_prob": 1.9521361537044868e-05}, {"id": 290, "seek": 167240, "start": 1672.4, "end": 1677.8400000000001, "text": " But what's done more frequently now is we, you know, what do we do? We learn the position", "tokens": [583, 437, 311, 1096, 544, 10374, 586, 307, 321, 11, 291, 458, 11, 437, 360, 321, 360, 30, 492, 1466, 264, 2535], "temperature": 0.0, "avg_logprob": -0.14965878644035857, "compression_ratio": 1.7123893805309736, "no_speech_prob": 5.5611217248952016e-05}, {"id": 291, "seek": 167240, "start": 1677.8400000000001, "end": 1685.6000000000001, "text": " of representations from scratch. So, we have, we're going to learn them from scratch. So,", "tokens": [295, 33358, 490, 8459, 13, 407, 11, 321, 362, 11, 321, 434, 516, 281, 1466, 552, 490, 8459, 13, 407, 11], "temperature": 0.0, "avg_logprob": -0.14965878644035857, "compression_ratio": 1.7123893805309736, "no_speech_prob": 5.5611217248952016e-05}, {"id": 292, "seek": 167240, "start": 1685.6000000000001, "end": 1689.8400000000001, "text": " let all the PI just be learnable parameters. So, what we're going to do is we're going to have a matrix", "tokens": [718, 439, 264, 27176, 445, 312, 1466, 712, 9834, 13, 407, 11, 437, 321, 434, 516, 281, 360, 307, 321, 434, 516, 281, 362, 257, 8141], "temperature": 0.0, "avg_logprob": -0.14965878644035857, "compression_ratio": 1.7123893805309736, "no_speech_prob": 5.5611217248952016e-05}, {"id": 293, "seek": 167240, "start": 1689.8400000000001, "end": 1695.92, "text": " P. That's going to be in dimensionality D, dimensionality of our network again, by the sequence length.", "tokens": [430, 13, 663, 311, 516, 281, 312, 294, 10139, 1860, 413, 11, 10139, 1860, 295, 527, 3209, 797, 11, 538, 264, 8310, 4641, 13], "temperature": 0.0, "avg_logprob": -0.14965878644035857, "compression_ratio": 1.7123893805309736, "no_speech_prob": 5.5611217248952016e-05}, {"id": 294, "seek": 169592, "start": 1695.92, "end": 1702.96, "text": " So, this is just a big matrix, right? Of the size here, of this size effectively, D by sequence length.", "tokens": [407, 11, 341, 307, 445, 257, 955, 8141, 11, 558, 30, 2720, 264, 2744, 510, 11, 295, 341, 2744, 8659, 11, 413, 538, 8310, 4641, 13], "temperature": 0.0, "avg_logprob": -0.14464542783539872, "compression_ratio": 1.6317689530685922, "no_speech_prob": 2.8406542696757242e-05}, {"id": 295, "seek": 169592, "start": 1704.0, "end": 1707.3600000000001, "text": " But every single value in that matrix is just a learnable parameter.", "tokens": [583, 633, 2167, 2158, 294, 300, 8141, 307, 445, 257, 1466, 712, 13075, 13], "temperature": 0.0, "avg_logprob": -0.14464542783539872, "compression_ratio": 1.6317689530685922, "no_speech_prob": 2.8406542696757242e-05}, {"id": 296, "seek": 169592, "start": 1708.72, "end": 1712.64, "text": " Proves flexibility. Now, you get to learn what positions is sort of supposed to mean,", "tokens": [1705, 977, 12635, 13, 823, 11, 291, 483, 281, 1466, 437, 8432, 307, 1333, 295, 3442, 281, 914, 11], "temperature": 0.0, "avg_logprob": -0.14464542783539872, "compression_ratio": 1.6317689530685922, "no_speech_prob": 2.8406542696757242e-05}, {"id": 297, "seek": 169592, "start": 1712.64, "end": 1719.3600000000001, "text": " according to your data, end to end. So, that's cool. Cons, you definitely can't extrapolate to", "tokens": [4650, 281, 428, 1412, 11, 917, 281, 917, 13, 407, 11, 300, 311, 1627, 13, 6923, 11, 291, 2138, 393, 380, 48224, 473, 281], "temperature": 0.0, "avg_logprob": -0.14464542783539872, "compression_ratio": 1.6317689530685922, "no_speech_prob": 2.8406542696757242e-05}, {"id": 298, "seek": 169592, "start": 1719.3600000000001, "end": 1724.24, "text": " indices outside 1 to T, right? Because you set the size of this parameter matrix at the beginning,", "tokens": [43840, 2380, 502, 281, 314, 11, 558, 30, 1436, 291, 992, 264, 2744, 295, 341, 13075, 8141, 412, 264, 2863, 11], "temperature": 0.0, "avg_logprob": -0.14464542783539872, "compression_ratio": 1.6317689530685922, "no_speech_prob": 2.8406542696757242e-05}, {"id": 299, "seek": 172424, "start": 1724.24, "end": 1728.88, "text": " and you learned them all. Now, if you want to go beyond position T, you know, you just,", "tokens": [293, 291, 3264, 552, 439, 13, 823, 11, 498, 291, 528, 281, 352, 4399, 2535, 314, 11, 291, 458, 11, 291, 445, 11], "temperature": 0.0, "avg_logprob": -0.12071957989273785, "compression_ratio": 1.741444866920152, "no_speech_prob": 2.7105043045594357e-05}, {"id": 300, "seek": 172424, "start": 1728.88, "end": 1734.08, "text": " you have no way to represent it effectively. But most systems use this. This is super useful.", "tokens": [291, 362, 572, 636, 281, 2906, 309, 8659, 13, 583, 881, 3652, 764, 341, 13, 639, 307, 1687, 4420, 13], "temperature": 0.0, "avg_logprob": -0.12071957989273785, "compression_ratio": 1.741444866920152, "no_speech_prob": 2.7105043045594357e-05}, {"id": 301, "seek": 172424, "start": 1734.64, "end": 1739.84, "text": " And sometimes people try more flexible representations of position, because again, the absolute", "tokens": [400, 2171, 561, 853, 544, 11358, 33358, 295, 2535, 11, 570, 797, 11, 264, 8236], "temperature": 0.0, "avg_logprob": -0.12071957989273785, "compression_ratio": 1.741444866920152, "no_speech_prob": 2.7105043045594357e-05}, {"id": 302, "seek": 172424, "start": 1739.84, "end": 1747.44, "text": " index of a word is not sort of its natural representation of its position in the sentence.", "tokens": [8186, 295, 257, 1349, 307, 406, 1333, 295, 1080, 3303, 10290, 295, 1080, 2535, 294, 264, 8174, 13], "temperature": 0.0, "avg_logprob": -0.12071957989273785, "compression_ratio": 1.741444866920152, "no_speech_prob": 2.7105043045594357e-05}, {"id": 303, "seek": 172424, "start": 1747.44, "end": 1751.68, "text": " And so, people have looked at the kind of the relative position between words, as well as", "tokens": [400, 370, 11, 561, 362, 2956, 412, 264, 733, 295, 264, 4972, 2535, 1296, 2283, 11, 382, 731, 382], "temperature": 0.0, "avg_logprob": -0.12071957989273785, "compression_ratio": 1.741444866920152, "no_speech_prob": 2.7105043045594357e-05}, {"id": 304, "seek": 175168, "start": 1751.68, "end": 1756.64, "text": " position representations that depend on syntax. But we're not going to be able to go too far into", "tokens": [2535, 33358, 300, 5672, 322, 28431, 13, 583, 321, 434, 406, 516, 281, 312, 1075, 281, 352, 886, 1400, 666], "temperature": 0.0, "avg_logprob": -0.10251832008361816, "compression_ratio": 1.7127272727272727, "no_speech_prob": 5.3902462241239846e-05}, {"id": 305, "seek": 175168, "start": 1756.64, "end": 1762.8, "text": " those today. Okay, so that was problem 1, right? We just, no matter what we did, if we didn't have", "tokens": [729, 965, 13, 1033, 11, 370, 300, 390, 1154, 502, 11, 558, 30, 492, 445, 11, 572, 1871, 437, 321, 630, 11, 498, 321, 994, 380, 362], "temperature": 0.0, "avg_logprob": -0.10251832008361816, "compression_ratio": 1.7127272727272727, "no_speech_prob": 5.3902462241239846e-05}, {"id": 306, "seek": 175168, "start": 1762.8, "end": 1767.28, "text": " representation of position, there was no way we could use self-attention as our new building block.", "tokens": [10290, 295, 2535, 11, 456, 390, 572, 636, 321, 727, 764, 2698, 12, 1591, 1251, 382, 527, 777, 2390, 3461, 13], "temperature": 0.0, "avg_logprob": -0.10251832008361816, "compression_ratio": 1.7127272727272727, "no_speech_prob": 5.3902462241239846e-05}, {"id": 307, "seek": 175168, "start": 1767.28, "end": 1770.5600000000002, "text": " And we've solved it with position representations that we just sort of add to the inputs.", "tokens": [400, 321, 600, 13041, 309, 365, 2535, 33358, 300, 321, 445, 1333, 295, 909, 281, 264, 15743, 13], "temperature": 0.0, "avg_logprob": -0.10251832008361816, "compression_ratio": 1.7127272727272727, "no_speech_prob": 5.3902462241239846e-05}, {"id": 308, "seek": 175168, "start": 1772.88, "end": 1777.68, "text": " Next, we're going to see this problem that you don't have non-linearities. You know,", "tokens": [3087, 11, 321, 434, 516, 281, 536, 341, 1154, 300, 291, 500, 380, 362, 2107, 12, 28263, 1088, 13, 509, 458, 11], "temperature": 0.0, "avg_logprob": -0.10251832008361816, "compression_ratio": 1.7127272727272727, "no_speech_prob": 5.3902462241239846e-05}, {"id": 309, "seek": 177768, "start": 1777.68, "end": 1784.0800000000002, "text": " even saying non-linearities, abstract features, they're great deep learning, end to end learning", "tokens": [754, 1566, 2107, 12, 28263, 1088, 11, 12649, 4122, 11, 436, 434, 869, 2452, 2539, 11, 917, 281, 917, 2539], "temperature": 0.0, "avg_logprob": -0.15185059138706752, "compression_ratio": 1.6371308016877637, "no_speech_prob": 3.0232831704779528e-05}, {"id": 310, "seek": 177768, "start": 1784.0800000000002, "end": 1791.1200000000001, "text": " of representations is awesome. But right now, we're just doing weighted averages. And so, what is", "tokens": [295, 33358, 307, 3476, 13, 583, 558, 586, 11, 321, 434, 445, 884, 32807, 42257, 13, 400, 370, 11, 437, 307], "temperature": 0.0, "avg_logprob": -0.15185059138706752, "compression_ratio": 1.6371308016877637, "no_speech_prob": 3.0232831704779528e-05}, {"id": 311, "seek": 177768, "start": 1791.1200000000001, "end": 1796.5600000000002, "text": " our solution going to be? I mean, it's not going to be all that complex. So, all we're doing right", "tokens": [527, 3827, 516, 281, 312, 30, 286, 914, 11, 309, 311, 406, 516, 281, 312, 439, 300, 3997, 13, 407, 11, 439, 321, 434, 884, 558], "temperature": 0.0, "avg_logprob": -0.15185059138706752, "compression_ratio": 1.6371308016877637, "no_speech_prob": 3.0232831704779528e-05}, {"id": 312, "seek": 177768, "start": 1796.5600000000002, "end": 1802.0, "text": " now is re-averaging vectors, right? So, you've got sort of the self-attention here. And if you", "tokens": [586, 307, 319, 12, 64, 331, 3568, 18875, 11, 558, 30, 407, 11, 291, 600, 658, 1333, 295, 264, 2698, 12, 1591, 1251, 510, 13, 400, 498, 291], "temperature": 0.0, "avg_logprob": -0.15185059138706752, "compression_ratio": 1.6371308016877637, "no_speech_prob": 3.0232831704779528e-05}, {"id": 313, "seek": 180200, "start": 1802.0, "end": 1808.0, "text": " just stacked another one, you just keep sort of averaging projections of vectors. But what if we just", "tokens": [445, 28867, 1071, 472, 11, 291, 445, 1066, 1333, 295, 47308, 32371, 295, 18875, 13, 583, 437, 498, 321, 445], "temperature": 0.0, "avg_logprob": -0.10713822079688004, "compression_ratio": 1.6541666666666666, "no_speech_prob": 9.816944839258213e-06}, {"id": 314, "seek": 180200, "start": 1808.0, "end": 1814.96, "text": " add a feed-forward network for every individual word? So, within this layer, each of these feed-forward", "tokens": [909, 257, 3154, 12, 13305, 3209, 337, 633, 2609, 1349, 30, 407, 11, 1951, 341, 4583, 11, 1184, 295, 613, 3154, 12, 13305], "temperature": 0.0, "avg_logprob": -0.10713822079688004, "compression_ratio": 1.6541666666666666, "no_speech_prob": 9.816944839258213e-06}, {"id": 315, "seek": 180200, "start": 1814.96, "end": 1821.2, "text": " neural networks shares parameters. But it gets in just the output of self-attention for this word", "tokens": [18161, 9590, 12182, 9834, 13, 583, 309, 2170, 294, 445, 264, 5598, 295, 2698, 12, 1591, 1251, 337, 341, 1349], "temperature": 0.0, "avg_logprob": -0.10713822079688004, "compression_ratio": 1.6541666666666666, "no_speech_prob": 9.816944839258213e-06}, {"id": 316, "seek": 180200, "start": 1821.2, "end": 1828.88, "text": " as we defined it, processes it, and emits something else. And so, you know, you have output i", "tokens": [382, 321, 7642, 309, 11, 7555, 309, 11, 293, 846, 1208, 746, 1646, 13, 400, 370, 11, 291, 458, 11, 291, 362, 5598, 741], "temperature": 0.0, "avg_logprob": -0.10713822079688004, "compression_ratio": 1.6541666666666666, "no_speech_prob": 9.816944839258213e-06}, {"id": 317, "seek": 182888, "start": 1828.88, "end": 1834.8000000000002, "text": " from self-attention, which we saw slides ago. Apply, you know, a feed-forward layer where you take", "tokens": [490, 2698, 12, 1591, 1251, 11, 597, 321, 1866, 9788, 2057, 13, 25264, 11, 291, 458, 11, 257, 3154, 12, 13305, 4583, 689, 291, 747], "temperature": 0.0, "avg_logprob": -0.1137738274139108, "compression_ratio": 1.7478260869565216, "no_speech_prob": 2.8405273042153567e-05}, {"id": 318, "seek": 182888, "start": 1834.8000000000002, "end": 1841.7600000000002, "text": " the output, multiply by matrix, you know, non-linearity, other matrix. And the intuition here, you can think", "tokens": [264, 5598, 11, 12972, 538, 8141, 11, 291, 458, 11, 2107, 12, 1889, 17409, 11, 661, 8141, 13, 400, 264, 24002, 510, 11, 291, 393, 519], "temperature": 0.0, "avg_logprob": -0.1137738274139108, "compression_ratio": 1.7478260869565216, "no_speech_prob": 2.8405273042153567e-05}, {"id": 319, "seek": 182888, "start": 1841.7600000000002, "end": 1847.8400000000001, "text": " of at least is, well, you know, something like the feed-forward network processes the result", "tokens": [295, 412, 1935, 307, 11, 731, 11, 291, 458, 11, 746, 411, 264, 3154, 12, 13305, 3209, 7555, 264, 1874], "temperature": 0.0, "avg_logprob": -0.1137738274139108, "compression_ratio": 1.7478260869565216, "no_speech_prob": 2.8405273042153567e-05}, {"id": 320, "seek": 182888, "start": 1847.8400000000001, "end": 1853.8400000000001, "text": " of the attention for each thing. But more fundamentally, right, you needed some kind of non-linearity", "tokens": [295, 264, 3202, 337, 1184, 551, 13, 583, 544, 17879, 11, 558, 11, 291, 2978, 512, 733, 295, 2107, 12, 1889, 17409], "temperature": 0.0, "avg_logprob": -0.1137738274139108, "compression_ratio": 1.7478260869565216, "no_speech_prob": 2.8405273042153567e-05}, {"id": 321, "seek": 185384, "start": 1853.84, "end": 1859.6799999999998, "text": " there. And, you know, a feed-forward network will do a good job. Okay, so that's another problem", "tokens": [456, 13, 400, 11, 291, 458, 11, 257, 3154, 12, 13305, 3209, 486, 360, 257, 665, 1691, 13, 1033, 11, 370, 300, 311, 1071, 1154], "temperature": 0.0, "avg_logprob": -0.08549744532658504, "compression_ratio": 1.7359154929577465, "no_speech_prob": 4.2640003812266514e-05}, {"id": 322, "seek": 185384, "start": 1859.6799999999998, "end": 1865.84, "text": " solved. Easy fix. Add a feed-forward network, get your non-linearity. Now, your self-attention", "tokens": [13041, 13, 16002, 3191, 13, 5349, 257, 3154, 12, 13305, 3209, 11, 483, 428, 2107, 12, 1889, 17409, 13, 823, 11, 428, 2698, 12, 1591, 1251], "temperature": 0.0, "avg_logprob": -0.08549744532658504, "compression_ratio": 1.7359154929577465, "no_speech_prob": 4.2640003812266514e-05}, {"id": 323, "seek": 185384, "start": 1865.84, "end": 1870.0, "text": " output, you can sort of process it, have that sort of depth increasing as the layers of the network", "tokens": [5598, 11, 291, 393, 1333, 295, 1399, 309, 11, 362, 300, 1333, 295, 7161, 5662, 382, 264, 7914, 295, 264, 3209], "temperature": 0.0, "avg_logprob": -0.08549744532658504, "compression_ratio": 1.7359154929577465, "no_speech_prob": 4.2640003812266514e-05}, {"id": 324, "seek": 185384, "start": 1870.0, "end": 1878.1599999999999, "text": " increase, which we know is useful. Another problem. Okay, so bear with me on this one. We don't want", "tokens": [3488, 11, 597, 321, 458, 307, 4420, 13, 3996, 1154, 13, 1033, 11, 370, 6155, 365, 385, 322, 341, 472, 13, 492, 500, 380, 528], "temperature": 0.0, "avg_logprob": -0.08549744532658504, "compression_ratio": 1.7359154929577465, "no_speech_prob": 4.2640003812266514e-05}, {"id": 325, "seek": 185384, "start": 1878.1599999999999, "end": 1882.9599999999998, "text": " to look at the future when we're doing language modeling. Right, so language modeling, you're trying", "tokens": [281, 574, 412, 264, 2027, 562, 321, 434, 884, 2856, 15983, 13, 1779, 11, 370, 2856, 15983, 11, 291, 434, 1382], "temperature": 0.0, "avg_logprob": -0.08549744532658504, "compression_ratio": 1.7359154929577465, "no_speech_prob": 4.2640003812266514e-05}, {"id": 326, "seek": 188296, "start": 1882.96, "end": 1889.68, "text": " to predict words in the future. And with the recurrent model, it's very natural, right? Like, you just", "tokens": [281, 6069, 2283, 294, 264, 2027, 13, 400, 365, 264, 18680, 1753, 2316, 11, 309, 311, 588, 3303, 11, 558, 30, 1743, 11, 291, 445], "temperature": 0.0, "avg_logprob": -0.12169955218279803, "compression_ratio": 1.6576271186440679, "no_speech_prob": 5.648453225148842e-05}, {"id": 327, "seek": 188296, "start": 1889.68, "end": 1896.24, "text": " don't unroll it further. Once you've unrolled a word to unrolled your LSTM to a given word,", "tokens": [500, 380, 517, 3970, 309, 3052, 13, 3443, 291, 600, 517, 28850, 257, 1349, 281, 517, 28850, 428, 441, 6840, 44, 281, 257, 2212, 1349, 11], "temperature": 0.0, "avg_logprob": -0.12169955218279803, "compression_ratio": 1.6576271186440679, "no_speech_prob": 5.648453225148842e-05}, {"id": 328, "seek": 188296, "start": 1896.24, "end": 1901.68, "text": " the sort of no way to have given it to the next word as well. But in self-attention, we'll see that", "tokens": [264, 1333, 295, 572, 636, 281, 362, 2212, 309, 281, 264, 958, 1349, 382, 731, 13, 583, 294, 2698, 12, 1591, 1251, 11, 321, 603, 536, 300], "temperature": 0.0, "avg_logprob": -0.12169955218279803, "compression_ratio": 1.6576271186440679, "no_speech_prob": 5.648453225148842e-05}, {"id": 329, "seek": 188296, "start": 1901.68, "end": 1906.24, "text": " this is a little bit trickier. So, we can't cheat and look at the stuff we're trying to be predicting,", "tokens": [341, 307, 257, 707, 857, 4282, 811, 13, 407, 11, 321, 393, 380, 17470, 293, 574, 412, 264, 1507, 321, 434, 1382, 281, 312, 32884, 11], "temperature": 0.0, "avg_logprob": -0.12169955218279803, "compression_ratio": 1.6576271186440679, "no_speech_prob": 5.648453225148842e-05}, {"id": 330, "seek": 188296, "start": 1906.24, "end": 1909.6000000000001, "text": " because then we would train networks that were totally useless. So what are we going to do?", "tokens": [570, 550, 321, 576, 3847, 9590, 300, 645, 3879, 14115, 13, 407, 437, 366, 321, 516, 281, 360, 30], "temperature": 0.0, "avg_logprob": -0.12169955218279803, "compression_ratio": 1.6576271186440679, "no_speech_prob": 5.648453225148842e-05}, {"id": 331, "seek": 190960, "start": 1909.6, "end": 1915.12, "text": " We're going to mask, masking is a word that's going to keep coming up. We're going to mask the future", "tokens": [492, 434, 516, 281, 6094, 11, 31226, 307, 257, 1349, 300, 311, 516, 281, 1066, 1348, 493, 13, 492, 434, 516, 281, 6094, 264, 2027], "temperature": 0.0, "avg_logprob": -0.10409195732524376, "compression_ratio": 1.8086642599277978, "no_speech_prob": 3.590845153667033e-05}, {"id": 332, "seek": 190960, "start": 1915.12, "end": 1920.6399999999999, "text": " in self-attention. So, in particular, this is important when we have decoters. Right, one of the", "tokens": [294, 2698, 12, 1591, 1251, 13, 407, 11, 294, 1729, 11, 341, 307, 1021, 562, 321, 362, 979, 310, 433, 13, 1779, 11, 472, 295, 264], "temperature": 0.0, "avg_logprob": -0.10409195732524376, "compression_ratio": 1.8086642599277978, "no_speech_prob": 3.590845153667033e-05}, {"id": 333, "seek": 190960, "start": 1920.6399999999999, "end": 1925.52, "text": " reasons why we could use bidirectional LSTMs in our encoters was that we could see the whole source", "tokens": [4112, 983, 321, 727, 764, 12957, 621, 41048, 441, 6840, 26386, 294, 527, 2058, 310, 433, 390, 300, 321, 727, 536, 264, 1379, 4009], "temperature": 0.0, "avg_logprob": -0.10409195732524376, "compression_ratio": 1.8086642599277978, "no_speech_prob": 3.590845153667033e-05}, {"id": 334, "seek": 190960, "start": 1925.52, "end": 1929.9199999999998, "text": " sentence in neural machine translation. But when we're predicting the output sentence, right, we", "tokens": [8174, 294, 18161, 3479, 12853, 13, 583, 562, 321, 434, 32884, 264, 5598, 8174, 11, 558, 11, 321], "temperature": 0.0, "avg_logprob": -0.10409195732524376, "compression_ratio": 1.8086642599277978, "no_speech_prob": 3.590845153667033e-05}, {"id": 335, "seek": 190960, "start": 1929.9199999999998, "end": 1935.52, "text": " can't see the future if we want to train the model to do the actual prediction. So, to use self-attention", "tokens": [393, 380, 536, 264, 2027, 498, 321, 528, 281, 3847, 264, 2316, 281, 360, 264, 3539, 17630, 13, 407, 11, 281, 764, 2698, 12, 1591, 1251], "temperature": 0.0, "avg_logprob": -0.10409195732524376, "compression_ratio": 1.8086642599277978, "no_speech_prob": 3.590845153667033e-05}, {"id": 336, "seek": 193552, "start": 1935.52, "end": 1941.36, "text": " in a decoder, you can mask the future. One thing that you could do is you could just every time", "tokens": [294, 257, 979, 19866, 11, 291, 393, 6094, 264, 2027, 13, 1485, 551, 300, 291, 727, 360, 307, 291, 727, 445, 633, 565], "temperature": 0.0, "avg_logprob": -0.1875890866674558, "compression_ratio": 1.6695652173913043, "no_speech_prob": 5.827649511047639e-05}, {"id": 337, "seek": 193552, "start": 1941.36, "end": 1948.8799999999999, "text": " you compute attention, you change the set of keys and values this should be. Keys and values", "tokens": [291, 14722, 3202, 11, 291, 1319, 264, 992, 295, 9317, 293, 4190, 341, 820, 312, 13, 43733, 293, 4190], "temperature": 0.0, "avg_logprob": -0.1875890866674558, "compression_ratio": 1.6695652173913043, "no_speech_prob": 5.827649511047639e-05}, {"id": 338, "seek": 193552, "start": 1948.8799999999999, "end": 1953.36, "text": " to only include past words. So, you're sort of dynamically changing the stuff that you're attending", "tokens": [281, 787, 4090, 1791, 2283, 13, 407, 11, 291, 434, 1333, 295, 43492, 4473, 264, 1507, 300, 291, 434, 15862], "temperature": 0.0, "avg_logprob": -0.1875890866674558, "compression_ratio": 1.6695652173913043, "no_speech_prob": 5.827649511047639e-05}, {"id": 339, "seek": 193552, "start": 1953.36, "end": 1959.68, "text": " over. But that doesn't let us do stuff with tensors as well as as pre-melizably as we will see.", "tokens": [670, 13, 583, 300, 1177, 380, 718, 505, 360, 1507, 365, 10688, 830, 382, 731, 382, 382, 659, 12, 10909, 590, 1188, 382, 321, 486, 536, 13], "temperature": 0.0, "avg_logprob": -0.1875890866674558, "compression_ratio": 1.6695652173913043, "no_speech_prob": 5.827649511047639e-05}, {"id": 340, "seek": 195968, "start": 1959.68, "end": 1965.28, "text": " So, we don't want to do that. Instead, we're going to mask out the future words through the", "tokens": [407, 11, 321, 500, 380, 528, 281, 360, 300, 13, 7156, 11, 321, 434, 516, 281, 6094, 484, 264, 2027, 2283, 807, 264], "temperature": 0.0, "avg_logprob": -0.11381544248022214, "compression_ratio": 1.696035242290749, "no_speech_prob": 5.143544331076555e-05}, {"id": 341, "seek": 195968, "start": 1965.28, "end": 1970.3200000000002, "text": " attention weights themselves. So, in math, don't worry, we'll get to the sort of diagram. But in math,", "tokens": [3202, 17443, 2969, 13, 407, 11, 294, 5221, 11, 500, 380, 3292, 11, 321, 603, 483, 281, 264, 1333, 295, 10686, 13, 583, 294, 5221, 11], "temperature": 0.0, "avg_logprob": -0.11381544248022214, "compression_ratio": 1.696035242290749, "no_speech_prob": 5.143544331076555e-05}, {"id": 342, "seek": 195968, "start": 1970.3200000000002, "end": 1976.48, "text": " we had these attention scores and they were equal to just this dot product before for all pairs.", "tokens": [321, 632, 613, 3202, 13444, 293, 436, 645, 2681, 281, 445, 341, 5893, 1674, 949, 337, 439, 15494, 13], "temperature": 0.0, "avg_logprob": -0.11381544248022214, "compression_ratio": 1.696035242290749, "no_speech_prob": 5.143544331076555e-05}, {"id": 343, "seek": 195968, "start": 1978.3200000000002, "end": 1987.1200000000001, "text": " Right, but now, only if the key is strictly less than the key index is strictly less than the", "tokens": [1779, 11, 457, 586, 11, 787, 498, 264, 2141, 307, 20792, 1570, 813, 264, 2141, 8186, 307, 20792, 1570, 813, 264], "temperature": 0.0, "avg_logprob": -0.11381544248022214, "compression_ratio": 1.696035242290749, "no_speech_prob": 5.143544331076555e-05}, {"id": 344, "seek": 198712, "start": 1987.12, "end": 1995.12, "text": " key index. So, this would be j less than i. Should we let the network look at the word and", "tokens": [2141, 8186, 13, 407, 11, 341, 576, 312, 361, 1570, 813, 741, 13, 6454, 321, 718, 264, 3209, 574, 412, 264, 1349, 293], "temperature": 0.0, "avg_logprob": -0.2884343569395972, "compression_ratio": 1.8571428571428572, "no_speech_prob": 4.83156691188924e-05}, {"id": 345, "seek": 198712, "start": 1995.12, "end": 1999.12, "text": " it should be negative infinity otherwise. So, we don't let you look at the output. So,", "tokens": [309, 820, 312, 3671, 13202, 5911, 13, 407, 11, 321, 500, 380, 718, 291, 574, 412, 264, 5598, 13, 407, 11], "temperature": 0.0, "avg_logprob": -0.2884343569395972, "compression_ratio": 1.8571428571428572, "no_speech_prob": 4.83156691188924e-05}, {"id": 346, "seek": 198712, "start": 1999.12, "end": 2005.12, "text": " let's go to the picture. For encoding the words that we'll see here, so maybe we have a start token.", "tokens": [718, 311, 352, 281, 264, 3036, 13, 1171, 43430, 264, 2283, 300, 321, 603, 536, 510, 11, 370, 1310, 321, 362, 257, 722, 14862, 13], "temperature": 0.0, "avg_logprob": -0.2884343569395972, "compression_ratio": 1.8571428571428572, "no_speech_prob": 4.83156691188924e-05}, {"id": 347, "seek": 198712, "start": 2007.12, "end": 2011.12, "text": " You want to decide, this is your whole sentence now. You want to decide which words in the sentence", "tokens": [509, 528, 281, 4536, 11, 341, 307, 428, 1379, 8174, 586, 13, 509, 528, 281, 4536, 597, 2283, 294, 264, 8174], "temperature": 0.0, "avg_logprob": -0.2884343569395972, "compression_ratio": 1.8571428571428572, "no_speech_prob": 4.83156691188924e-05}, {"id": 348, "seek": 198712, "start": 2011.12, "end": 2015.12, "text": " you're allowed to look at when making your predictions. So, you're allowed to look at the", "tokens": [291, 434, 4350, 281, 574, 412, 562, 1455, 428, 21264, 13, 407, 11, 291, 434, 4350, 281, 574, 412, 264], "temperature": 0.0, "avg_logprob": -0.2884343569395972, "compression_ratio": 1.8571428571428572, "no_speech_prob": 4.83156691188924e-05}, {"id": 349, "seek": 201512, "start": 2015.12, "end": 2021.12, "text": " first word and in order to predict the, I'm not allowed to look at the word the, I'm also not", "tokens": [700, 1349, 293, 294, 1668, 281, 6069, 264, 11, 286, 478, 406, 4350, 281, 574, 412, 264, 1349, 264, 11, 286, 478, 611, 406], "temperature": 0.0, "avg_logprob": -0.24057637008966185, "compression_ratio": 1.9891891891891893, "no_speech_prob": 4.467846156330779e-05}, {"id": 350, "seek": 201512, "start": 2021.12, "end": 2027.12, "text": " allowed to look at any of the future words, I am allowed to look at the word start. So, this", "tokens": [4350, 281, 574, 412, 604, 295, 264, 2027, 2283, 11, 286, 669, 4350, 281, 574, 412, 264, 1349, 722, 13, 407, 11, 341], "temperature": 0.0, "avg_logprob": -0.24057637008966185, "compression_ratio": 1.9891891891891893, "no_speech_prob": 4.467846156330779e-05}, {"id": 351, "seek": 201512, "start": 2027.12, "end": 2033.12, "text": " kind of block is not shaded here. In order to predict the word chef, I can look at start and", "tokens": [733, 295, 3461, 307, 406, 48067, 510, 13, 682, 1668, 281, 6069, 264, 1349, 10530, 11, 286, 393, 574, 412, 722, 293], "temperature": 0.0, "avg_logprob": -0.24057637008966185, "compression_ratio": 1.9891891891891893, "no_speech_prob": 4.467846156330779e-05}, {"id": 352, "seek": 201512, "start": 2033.12, "end": 2039.12, "text": " the, right, start the, but not chef naturally or the word that comes after it. So, we're", "tokens": [264, 11, 558, 11, 722, 264, 11, 457, 406, 10530, 8195, 420, 264, 1349, 300, 1487, 934, 309, 13, 407, 11, 321, 434], "temperature": 0.0, "avg_logprob": -0.24057637008966185, "compression_ratio": 1.9891891891891893, "no_speech_prob": 4.467846156330779e-05}, {"id": 353, "seek": 203912, "start": 2039.12, "end": 2047.12, "text": " allowed to look at the word chef naturally or the word that comes after it. Likewise for the other words.", "tokens": [4350, 281, 574, 412, 264, 1349, 10530, 8195, 420, 264, 1349, 300, 1487, 934, 309, 13, 30269, 337, 264, 661, 2283, 13], "temperature": 0.0, "avg_logprob": -0.25753601177318675, "compression_ratio": 1.572192513368984, "no_speech_prob": 2.212020626757294e-05}, {"id": 354, "seek": 203912, "start": 2047.12, "end": 2053.12, "text": " So, you can see this sort of, this matrix here, right. So, we just want to make sure that our", "tokens": [407, 11, 291, 393, 536, 341, 1333, 295, 11, 341, 8141, 510, 11, 558, 13, 407, 11, 321, 445, 528, 281, 652, 988, 300, 527], "temperature": 0.0, "avg_logprob": -0.25753601177318675, "compression_ratio": 1.572192513368984, "no_speech_prob": 2.212020626757294e-05}, {"id": 355, "seek": 203912, "start": 2053.12, "end": 2060.12, "text": " attention weights are zero everywhere here. So, in the affinities calculation, we add negative", "tokens": [3202, 17443, 366, 4018, 5315, 510, 13, 407, 11, 294, 264, 2096, 259, 1088, 17108, 11, 321, 909, 3671], "temperature": 0.0, "avg_logprob": -0.25753601177318675, "compression_ratio": 1.572192513368984, "no_speech_prob": 2.212020626757294e-05}, {"id": 356, "seek": 206012, "start": 2060.12, "end": 2069.12, "text": " infinity to all of these in this big matrix. And that guarantees that we can't look to the future.", "tokens": [13202, 281, 439, 295, 613, 294, 341, 955, 8141, 13, 400, 300, 32567, 300, 321, 393, 380, 574, 281, 264, 2027, 13], "temperature": 0.0, "avg_logprob": -0.13344639617127257, "compression_ratio": 1.616580310880829, "no_speech_prob": 1.777601573849097e-05}, {"id": 357, "seek": 206012, "start": 2069.12, "end": 2076.12, "text": " Okay, so now we can do big matrix multiplications to compute our attention as we will see. And we sort of", "tokens": [1033, 11, 370, 586, 321, 393, 360, 955, 8141, 17596, 763, 281, 14722, 527, 3202, 382, 321, 486, 536, 13, 400, 321, 1333, 295], "temperature": 0.0, "avg_logprob": -0.13344639617127257, "compression_ratio": 1.616580310880829, "no_speech_prob": 1.777601573849097e-05}, {"id": 358, "seek": 206012, "start": 2076.12, "end": 2081.12, "text": " don't worry about looking at the future because we've added these negative infinities. And that's the last,", "tokens": [500, 380, 3292, 466, 1237, 412, 264, 2027, 570, 321, 600, 3869, 613, 3671, 7193, 1088, 13, 400, 300, 311, 264, 1036, 11], "temperature": 0.0, "avg_logprob": -0.13344639617127257, "compression_ratio": 1.616580310880829, "no_speech_prob": 1.777601573849097e-05}, {"id": 359, "seek": 208112, "start": 2081.12, "end": 2090.12, "text": " that's the last problem with self-attention sort of that comes up fundamentally as like what do we need for this building block.", "tokens": [300, 311, 264, 1036, 1154, 365, 2698, 12, 1591, 1251, 1333, 295, 300, 1487, 493, 17879, 382, 411, 437, 360, 321, 643, 337, 341, 2390, 3461, 13], "temperature": 0.0, "avg_logprob": -0.171507161596547, "compression_ratio": 1.6818181818181819, "no_speech_prob": 1.300524945690995e-05}, {"id": 360, "seek": 208112, "start": 2090.12, "end": 2096.12, "text": " You have, you didn't have an inherent notion of order. Now you have a good notion of order or at least something of", "tokens": [509, 362, 11, 291, 994, 380, 362, 364, 26387, 10710, 295, 1668, 13, 823, 291, 362, 257, 665, 10710, 295, 1668, 420, 412, 1935, 746, 295], "temperature": 0.0, "avg_logprob": -0.171507161596547, "compression_ratio": 1.6818181818181819, "no_speech_prob": 1.300524945690995e-05}, {"id": 361, "seek": 208112, "start": 2096.12, "end": 2104.12, "text": " a notion of order. You didn't have nonlinearities, add feed forward networks. And then you didn't want to look at the future.", "tokens": [257, 10710, 295, 1668, 13, 509, 994, 380, 362, 2107, 1889, 289, 1088, 11, 909, 3154, 2128, 9590, 13, 400, 550, 291, 994, 380, 528, 281, 574, 412, 264, 2027, 13], "temperature": 0.0, "avg_logprob": -0.171507161596547, "compression_ratio": 1.6818181818181819, "no_speech_prob": 1.300524945690995e-05}, {"id": 362, "seek": 210412, "start": 2104.12, "end": 2114.12, "text": " You add the masks for the decoders. So, you know, self-attention is the basis of any self-attention based building block.", "tokens": [509, 909, 264, 11830, 337, 264, 979, 378, 433, 13, 407, 11, 291, 458, 11, 2698, 12, 1591, 1251, 307, 264, 5143, 295, 604, 2698, 12, 1591, 1251, 2361, 2390, 3461, 13], "temperature": 0.0, "avg_logprob": -0.14965402961957572, "compression_ratio": 1.6129032258064515, "no_speech_prob": 1.593383785802871e-05}, {"id": 363, "seek": 210412, "start": 2114.12, "end": 2121.12, "text": " Hello. Position representations are useful. Nonlinearities are good. You don't have to use a feed forward network.", "tokens": [2425, 13, 29780, 33358, 366, 4420, 13, 8774, 1889, 289, 1088, 366, 665, 13, 509, 500, 380, 362, 281, 764, 257, 3154, 2128, 3209, 13], "temperature": 0.0, "avg_logprob": -0.14965402961957572, "compression_ratio": 1.6129032258064515, "no_speech_prob": 1.593383785802871e-05}, {"id": 364, "seek": 210412, "start": 2121.12, "end": 2128.12, "text": " Right? Like you could have just done other stuff, I guess. But, you know, in practice actually it's really easy to parallelize these feed forward networks as well.", "tokens": [1779, 30, 1743, 291, 727, 362, 445, 1096, 661, 1507, 11, 286, 2041, 13, 583, 11, 291, 458, 11, 294, 3124, 767, 309, 311, 534, 1858, 281, 8952, 1125, 613, 3154, 2128, 9590, 382, 731, 13], "temperature": 0.0, "avg_logprob": -0.14965402961957572, "compression_ratio": 1.6129032258064515, "no_speech_prob": 1.593383785802871e-05}, {"id": 365, "seek": 212812, "start": 2128.12, "end": 2138.12, "text": " So we end up doing that. And then the masking, you know, yeah, you don't want information to leak from the future to the past in your decoder.", "tokens": [407, 321, 917, 493, 884, 300, 13, 400, 550, 264, 31226, 11, 291, 458, 11, 1338, 11, 291, 500, 380, 528, 1589, 281, 17143, 490, 264, 2027, 281, 264, 1791, 294, 428, 979, 19866, 13], "temperature": 0.0, "avg_logprob": -0.11234475041294957, "compression_ratio": 1.667953667953668, "no_speech_prob": 2.545745337556582e-05}, {"id": 366, "seek": 212812, "start": 2138.12, "end": 2147.12, "text": " So, so let me be clear. We haven't talked about the transformer yet. But this is all you would need if you were thinking like, gosh,", "tokens": [407, 11, 370, 718, 385, 312, 1850, 13, 492, 2378, 380, 2825, 466, 264, 31782, 1939, 13, 583, 341, 307, 439, 291, 576, 643, 498, 291, 645, 1953, 411, 11, 6502, 11], "temperature": 0.0, "avg_logprob": -0.11234475041294957, "compression_ratio": 1.667953667953668, "no_speech_prob": 2.545745337556582e-05}, {"id": 367, "seek": 212812, "start": 2147.12, "end": 2153.12, "text": " what do I need in order to build my self-attention building block. We'll see that there are a lot more details in the transformer that we're going to spend,", "tokens": [437, 360, 286, 643, 294, 1668, 281, 1322, 452, 2698, 12, 1591, 1251, 2390, 3461, 13, 492, 603, 536, 300, 456, 366, 257, 688, 544, 4365, 294, 264, 31782, 300, 321, 434, 516, 281, 3496, 11], "temperature": 0.0, "avg_logprob": -0.11234475041294957, "compression_ratio": 1.667953667953668, "no_speech_prob": 2.545745337556582e-05}, {"id": 368, "seek": 215312, "start": 2153.12, "end": 2165.12, "text": " the rest of the lecture going through. But I want you to sort of at least, as you're thinking about what's going to come next after the transformer and how you're going to invent it,", "tokens": [264, 1472, 295, 264, 7991, 516, 807, 13, 583, 286, 528, 291, 281, 1333, 295, 412, 1935, 11, 382, 291, 434, 1953, 466, 437, 311, 516, 281, 808, 958, 934, 264, 31782, 293, 577, 291, 434, 516, 281, 7962, 309, 11], "temperature": 0.0, "avg_logprob": -0.07658216418052206, "compression_ratio": 1.7161016949152543, "no_speech_prob": 0.00010069127893075347}, {"id": 369, "seek": 215312, "start": 2165.12, "end": 2172.12, "text": " think about the fact that these are the things that were necessary. And then the other things end up being very, very important to turns out.", "tokens": [519, 466, 264, 1186, 300, 613, 366, 264, 721, 300, 645, 4818, 13, 400, 550, 264, 661, 721, 917, 493, 885, 588, 11, 588, 1021, 281, 4523, 484, 13], "temperature": 0.0, "avg_logprob": -0.07658216418052206, "compression_ratio": 1.7161016949152543, "no_speech_prob": 0.00010069127893075347}, {"id": 370, "seek": 215312, "start": 2172.12, "end": 2179.12, "text": " But, you know, there's a lot of design space here that hasn't been explored yet.", "tokens": [583, 11, 291, 458, 11, 456, 311, 257, 688, 295, 1715, 1901, 510, 300, 6132, 380, 668, 24016, 1939, 13], "temperature": 0.0, "avg_logprob": -0.07658216418052206, "compression_ratio": 1.7161016949152543, "no_speech_prob": 0.00010069127893075347}, {"id": 371, "seek": 217912, "start": 2179.12, "end": 2191.12, "text": " Okay, so let's talk about the transformer model. And I'm going to pause. There are any, this is a good question. I can take it now.", "tokens": [1033, 11, 370, 718, 311, 751, 466, 264, 31782, 2316, 13, 400, 286, 478, 516, 281, 10465, 13, 821, 366, 604, 11, 341, 307, 257, 665, 1168, 13, 286, 393, 747, 309, 586, 13], "temperature": 0.0, "avg_logprob": -0.12699789319719587, "compression_ratio": 1.4761904761904763, "no_speech_prob": 0.0001272949593840167}, {"id": 372, "seek": 217912, "start": 2191.12, "end": 2201.12, "text": " Okay. So, transformers. Let's get to it. Let's look at the transformer encoder decoder blocks at a high level first.", "tokens": [1033, 13, 407, 11, 4088, 433, 13, 961, 311, 483, 281, 309, 13, 961, 311, 574, 412, 264, 31782, 2058, 19866, 979, 19866, 8474, 412, 257, 1090, 1496, 700, 13], "temperature": 0.0, "avg_logprob": -0.12699789319719587, "compression_ratio": 1.4761904761904763, "no_speech_prob": 0.0001272949593840167}, {"id": 373, "seek": 220112, "start": 2201.12, "end": 2211.12, "text": " This should look a lot like the encoder decoders that we saw with the recurrent neural network machine translation systems that we saw.", "tokens": [639, 820, 574, 257, 688, 411, 264, 2058, 19866, 979, 378, 433, 300, 321, 1866, 365, 264, 18680, 1753, 18161, 3209, 3479, 12853, 3652, 300, 321, 1866, 13], "temperature": 0.0, "avg_logprob": -0.08099376713788067, "compression_ratio": 1.8393574297188755, "no_speech_prob": 8.887074363883585e-05}, {"id": 374, "seek": 220112, "start": 2211.12, "end": 2220.12, "text": " Okay, so we have our word embeddings. We're going to add in our position representations. We saw that. And that's from our input sequence.", "tokens": [1033, 11, 370, 321, 362, 527, 1349, 12240, 29432, 13, 492, 434, 516, 281, 909, 294, 527, 2535, 33358, 13, 492, 1866, 300, 13, 400, 300, 311, 490, 527, 4846, 8310, 13], "temperature": 0.0, "avg_logprob": -0.08099376713788067, "compression_ratio": 1.8393574297188755, "no_speech_prob": 8.887074363883585e-05}, {"id": 375, "seek": 220112, "start": 2220.12, "end": 2229.12, "text": " We'll have a sequence of encoder blocks. Each of them is called a transformer encoder. And then, you know, we have our output sequence, word embeddings, position representation again.", "tokens": [492, 603, 362, 257, 8310, 295, 2058, 19866, 8474, 13, 6947, 295, 552, 307, 1219, 257, 31782, 2058, 19866, 13, 400, 550, 11, 291, 458, 11, 321, 362, 527, 5598, 8310, 11, 1349, 12240, 29432, 11, 2535, 10290, 797, 13], "temperature": 0.0, "avg_logprob": -0.08099376713788067, "compression_ratio": 1.8393574297188755, "no_speech_prob": 8.887074363883585e-05}, {"id": 376, "seek": 222912, "start": 2229.12, "end": 2241.12, "text": " We have a transformer decoder. Each end, the last layer of encoders is going to be used in each layer of the transformer decoder.", "tokens": [492, 362, 257, 31782, 979, 19866, 13, 6947, 917, 11, 264, 1036, 4583, 295, 2058, 378, 433, 307, 516, 281, 312, 1143, 294, 1184, 4583, 295, 264, 31782, 979, 19866, 13], "temperature": 0.0, "avg_logprob": -0.09378417332967122, "compression_ratio": 1.6303317535545023, "no_speech_prob": 4.264445306034759e-05}, {"id": 377, "seek": 222912, "start": 2241.12, "end": 2251.12, "text": " And then we get some outputs, some predictions. Okay, so this looks pretty much the same at a very high level. Maybe minus the fact that now we need to do the position representation addition at the very beginning.", "tokens": [400, 550, 321, 483, 512, 23930, 11, 512, 21264, 13, 1033, 11, 370, 341, 1542, 1238, 709, 264, 912, 412, 257, 588, 1090, 1496, 13, 2704, 3175, 264, 1186, 300, 586, 321, 643, 281, 360, 264, 2535, 10290, 4500, 412, 264, 588, 2863, 13], "temperature": 0.0, "avg_logprob": -0.09378417332967122, "compression_ratio": 1.6303317535545023, "no_speech_prob": 4.264445306034759e-05}, {"id": 378, "seek": 225112, "start": 2251.12, "end": 2259.12, "text": " So now let's look at these blocks themselves. So the encoder and decoder blocks, what's left that we haven't covered, right?", "tokens": [407, 586, 718, 311, 574, 412, 613, 8474, 2969, 13, 407, 264, 2058, 19866, 293, 979, 19866, 8474, 11, 437, 311, 1411, 300, 321, 2378, 380, 5343, 11, 558, 30], "temperature": 0.0, "avg_logprob": -0.14463962958409235, "compression_ratio": 1.7154471544715446, "no_speech_prob": 8.218357834266499e-05}, {"id": 379, "seek": 225112, "start": 2259.12, "end": 2265.12, "text": " Because we could just put the building blocks that we just came up with in the first part of class in these things, right?", "tokens": [1436, 321, 727, 445, 829, 264, 2390, 8474, 300, 321, 445, 1361, 493, 365, 294, 264, 700, 644, 295, 1508, 294, 613, 721, 11, 558, 30], "temperature": 0.0, "avg_logprob": -0.14463962958409235, "compression_ratio": 1.7154471544715446, "no_speech_prob": 8.218357834266499e-05}, {"id": 380, "seek": 225112, "start": 2265.12, "end": 2275.12, "text": " In coders, we need our self attention, our feed forward networks. We have our position representations. We get the masking for the decoders. Right, we can just slot these in.", "tokens": [682, 17656, 433, 11, 321, 643, 527, 2698, 3202, 11, 527, 3154, 2128, 9590, 13, 492, 362, 527, 2535, 33358, 13, 492, 483, 264, 31226, 337, 264, 979, 378, 433, 13, 1779, 11, 321, 393, 445, 14747, 613, 294, 13], "temperature": 0.0, "avg_logprob": -0.14463962958409235, "compression_ratio": 1.7154471544715446, "no_speech_prob": 8.218357834266499e-05}, {"id": 381, "seek": 227512, "start": 2275.12, "end": 2283.12, "text": " But it turns out they wouldn't work all that well compared to transformers. So what's left? So the first thing is key query value attention.", "tokens": [583, 309, 4523, 484, 436, 2759, 380, 589, 439, 300, 731, 5347, 281, 4088, 433, 13, 407, 437, 311, 1411, 30, 407, 264, 700, 551, 307, 2141, 14581, 2158, 3202, 13], "temperature": 0.0, "avg_logprob": -0.10651921211405004, "compression_ratio": 1.5355648535564854, "no_speech_prob": 5.6487839174224064e-05}, {"id": 382, "seek": 227512, "start": 2283.12, "end": 2296.12, "text": " This is a specific way of getting the K, Q, and V vectors from the single word embedding. Right? So instead of letting K, Q, and V equal to X, like the output from the last layer, we're going to do something a little bit more.", "tokens": [639, 307, 257, 2685, 636, 295, 1242, 264, 591, 11, 1249, 11, 293, 691, 18875, 490, 264, 2167, 1349, 12240, 3584, 13, 1779, 30, 407, 2602, 295, 8295, 591, 11, 1249, 11, 293, 691, 2681, 281, 1783, 11, 411, 264, 5598, 490, 264, 1036, 4583, 11, 321, 434, 516, 281, 360, 746, 257, 707, 857, 544, 13], "temperature": 0.0, "avg_logprob": -0.10651921211405004, "compression_ratio": 1.5355648535564854, "no_speech_prob": 5.6487839174224064e-05}, {"id": 383, "seek": 229612, "start": 2296.12, "end": 2307.12, "text": " Next is multi-headed attention. We're going to attend to multiple places in a single layer. And we'll see that that gets us sort of kind of interesting properties in the homework later on.", "tokens": [3087, 307, 4825, 12, 28409, 3202, 13, 492, 434, 516, 281, 6888, 281, 3866, 3190, 294, 257, 2167, 4583, 13, 400, 321, 603, 536, 300, 300, 2170, 505, 1333, 295, 733, 295, 1880, 7221, 294, 264, 14578, 1780, 322, 13], "temperature": 0.0, "avg_logprob": -0.0730146428813105, "compression_ratio": 1.610655737704918, "no_speech_prob": 9.911216329783201e-05}, {"id": 384, "seek": 229612, "start": 2307.12, "end": 2316.12, "text": " But we'll talk a little bit about it today. And then there's a bunch of things that just help with training. These seemed like they were very hard to train at first. A lot of these tricks are very useful.", "tokens": [583, 321, 603, 751, 257, 707, 857, 466, 309, 965, 13, 400, 550, 456, 311, 257, 3840, 295, 721, 300, 445, 854, 365, 3097, 13, 1981, 6576, 411, 436, 645, 588, 1152, 281, 3847, 412, 700, 13, 316, 688, 295, 613, 11733, 366, 588, 4420, 13], "temperature": 0.0, "avg_logprob": -0.0730146428813105, "compression_ratio": 1.610655737704918, "no_speech_prob": 9.911216329783201e-05}, {"id": 385, "seek": 231612, "start": 2316.12, "end": 2327.12, "text": " So we'll talk about residual connections, layer normalization, and scaling the dot product. Everything in bullet point three here, tricks to help with training. Don't improve with the model is able to do.", "tokens": [407, 321, 603, 751, 466, 27980, 9271, 11, 4583, 2710, 2144, 11, 293, 21589, 264, 5893, 1674, 13, 5471, 294, 11632, 935, 1045, 510, 11, 11733, 281, 854, 365, 3097, 13, 1468, 380, 3470, 365, 264, 2316, 307, 1075, 281, 360, 13], "temperature": 0.0, "avg_logprob": -0.09835467207322426, "compression_ratio": 1.6933797909407666, "no_speech_prob": 0.00015113265544641763}, {"id": 386, "seek": 231612, "start": 2327.12, "end": 2335.12, "text": " But they're crucial in that they improve the training process. So modeling improvements of both kinds are really, really important.", "tokens": [583, 436, 434, 11462, 294, 300, 436, 3470, 264, 3097, 1399, 13, 407, 15983, 13797, 295, 1293, 3685, 366, 534, 11, 534, 1021, 13], "temperature": 0.0, "avg_logprob": -0.09835467207322426, "compression_ratio": 1.6933797909407666, "no_speech_prob": 0.00015113265544641763}, {"id": 387, "seek": 231612, "start": 2335.12, "end": 2342.12, "text": " So it's good that we're using self attention, which is this cool thing that had these properties. But if we couldn't train it, it wouldn't be useful.", "tokens": [407, 309, 311, 665, 300, 321, 434, 1228, 2698, 3202, 11, 597, 307, 341, 1627, 551, 300, 632, 613, 7221, 13, 583, 498, 321, 2809, 380, 3847, 309, 11, 309, 2759, 380, 312, 4420, 13], "temperature": 0.0, "avg_logprob": -0.09835467207322426, "compression_ratio": 1.6933797909407666, "no_speech_prob": 0.00015113265544641763}, {"id": 388, "seek": 234212, "start": 2342.12, "end": 2352.12, "text": " OK, so here's how the transformer builds the key query and value vectors.", "tokens": [2264, 11, 370, 510, 311, 577, 264, 31782, 15182, 264, 2141, 14581, 293, 2158, 18875, 13], "temperature": 0.0, "avg_logprob": -0.20832086076923445, "compression_ratio": 1.4044117647058822, "no_speech_prob": 0.00037396137486211956}, {"id": 389, "seek": 234212, "start": 2352.12, "end": 2362.12, "text": " We have X1 to Xt. The input vector is to our transformer layer. And we're going to find the transformer encoder here.", "tokens": [492, 362, 1783, 16, 281, 1783, 83, 13, 440, 4846, 8062, 307, 281, 527, 31782, 4583, 13, 400, 321, 434, 516, 281, 915, 264, 31782, 2058, 19866, 510, 13], "temperature": 0.0, "avg_logprob": -0.20832086076923445, "compression_ratio": 1.4044117647058822, "no_speech_prob": 0.00037396137486211956}, {"id": 390, "seek": 236212, "start": 2362.12, "end": 2373.12, "text": " So we have one of these vectors per word, you can say. And again, each XI is going to be a vector in dimensionality D. And here's how we compute the keys, queries, and values.", "tokens": [407, 321, 362, 472, 295, 613, 18875, 680, 1349, 11, 291, 393, 584, 13, 400, 797, 11, 1184, 1783, 40, 307, 516, 281, 312, 257, 8062, 294, 10139, 1860, 413, 13, 400, 510, 311, 577, 321, 14722, 264, 9317, 11, 24109, 11, 293, 4190, 13], "temperature": 0.0, "avg_logprob": -0.14379772685822986, "compression_ratio": 1.4343434343434343, "no_speech_prob": 0.00012530761887319386}, {"id": 391, "seek": 236212, "start": 2373.12, "end": 2382.12, "text": " We're going to let each key, KI, which we saw before, be equal to some matrix K times XI, where K is D by D.", "tokens": [492, 434, 516, 281, 718, 1184, 2141, 11, 591, 40, 11, 597, 321, 1866, 949, 11, 312, 2681, 281, 512, 8141, 591, 1413, 1783, 40, 11, 689, 591, 307, 413, 538, 413, 13], "temperature": 0.0, "avg_logprob": -0.14379772685822986, "compression_ratio": 1.4343434343434343, "no_speech_prob": 0.00012530761887319386}, {"id": 392, "seek": 238212, "start": 2382.12, "end": 2392.12, "text": " So this is a transformation from dimensionality D to dimensionality D. We're going to call this the key matrix K. And we're going to do the same thing for the queries.", "tokens": [407, 341, 307, 257, 9887, 490, 10139, 1860, 413, 281, 10139, 1860, 413, 13, 492, 434, 516, 281, 818, 341, 264, 2141, 8141, 591, 13, 400, 321, 434, 516, 281, 360, 264, 912, 551, 337, 264, 24109, 13], "temperature": 0.0, "avg_logprob": -0.11183061991652397, "compression_ratio": 1.7080745341614907, "no_speech_prob": 0.00010888145334320143}, {"id": 393, "seek": 238212, "start": 2392.12, "end": 2399.12, "text": " So we're going to take the XI, multiply by matrix, get the query vector, and we'll do the same thing for V.", "tokens": [407, 321, 434, 516, 281, 747, 264, 1783, 40, 11, 12972, 538, 8141, 11, 483, 264, 14581, 8062, 11, 293, 321, 603, 360, 264, 912, 551, 337, 691, 13], "temperature": 0.0, "avg_logprob": -0.11183061991652397, "compression_ratio": 1.7080745341614907, "no_speech_prob": 0.00010888145334320143}, {"id": 394, "seek": 239912, "start": 2399.12, "end": 2417.12, "text": " OK, so you can just plug this in. Now instead of saying that all the K, Q, and the V are all the same as X, they all are slightly different because you apply a linear transformation. What does this do? Well, you can think about it as like, well, the matrices K, Q, and V can be very different from each other.", "tokens": [2264, 11, 370, 291, 393, 445, 5452, 341, 294, 13, 823, 2602, 295, 1566, 300, 439, 264, 591, 11, 1249, 11, 293, 264, 691, 366, 439, 264, 912, 382, 1783, 11, 436, 439, 366, 4748, 819, 570, 291, 3079, 257, 8213, 9887, 13, 708, 775, 341, 360, 30, 1042, 11, 291, 393, 519, 466, 309, 382, 411, 11, 731, 11, 264, 32284, 591, 11, 1249, 11, 293, 691, 393, 312, 588, 819, 490, 1184, 661, 13], "temperature": 0.0, "avg_logprob": -0.13495410680770875, "compression_ratio": 1.5606060606060606, "no_speech_prob": 8.47803385113366e-05}, {"id": 395, "seek": 241712, "start": 2417.12, "end": 2432.12, "text": " And so they sort of emphasize or allow different aspects of the X vectors to be used in each of the three roles. So we wrote out the self-attentioned equations with the three roles to indicate the different things are being done with each of them.", "tokens": [400, 370, 436, 1333, 295, 16078, 420, 2089, 819, 7270, 295, 264, 1783, 18875, 281, 312, 1143, 294, 1184, 295, 264, 1045, 9604, 13, 407, 321, 4114, 484, 264, 2698, 12, 1591, 1251, 292, 11787, 365, 264, 1045, 9604, 281, 13330, 264, 819, 721, 366, 885, 1096, 365, 1184, 295, 552, 13], "temperature": 0.0, "avg_logprob": -0.06972854402330186, "compression_ratio": 1.7342342342342343, "no_speech_prob": 4.398938108352013e-05}, {"id": 396, "seek": 241712, "start": 2432.12, "end": 2440.12, "text": " So maybe K and Q are helping you figure out where to look. And so they should be a certain way. They should look at different parts of X.", "tokens": [407, 1310, 591, 293, 1249, 366, 4315, 291, 2573, 484, 689, 281, 574, 13, 400, 370, 436, 820, 312, 257, 1629, 636, 13, 814, 820, 574, 412, 819, 3166, 295, 1783, 13], "temperature": 0.0, "avg_logprob": -0.06972854402330186, "compression_ratio": 1.7342342342342343, "no_speech_prob": 4.398938108352013e-05}, {"id": 397, "seek": 244012, "start": 2440.12, "end": 2449.12, "text": " And then V, the value, maybe you want to pass along a different information than the thing that actually helps you access that information.", "tokens": [400, 550, 691, 11, 264, 2158, 11, 1310, 291, 528, 281, 1320, 2051, 257, 819, 1589, 813, 264, 551, 300, 767, 3665, 291, 2105, 300, 1589, 13], "temperature": 0.0, "avg_logprob": -0.11238804730502042, "compression_ratio": 1.513157894736842, "no_speech_prob": 1.9219600289943628e-05}, {"id": 398, "seek": 244012, "start": 2449.12, "end": 2463.12, "text": " So this is important. How do we do this? In practice, we compute it with really big tensors. So we had our X vectors, which we've been talking about sort of word by words. We had the sequence XI, X1 to XT.", "tokens": [407, 341, 307, 1021, 13, 1012, 360, 321, 360, 341, 30, 682, 3124, 11, 321, 14722, 309, 365, 534, 955, 10688, 830, 13, 407, 321, 632, 527, 1783, 18875, 11, 597, 321, 600, 668, 1417, 466, 1333, 295, 1349, 538, 2283, 13, 492, 632, 264, 8310, 1783, 40, 11, 1783, 16, 281, 1783, 51, 13], "temperature": 0.0, "avg_logprob": -0.11238804730502042, "compression_ratio": 1.513157894736842, "no_speech_prob": 1.9219600289943628e-05}, {"id": 399, "seek": 246312, "start": 2463.12, "end": 2473.12, "text": " So we actually represent them all as a matrix X, which is in our sequence length by dimensionality. So sequence length by D, capital T by D.", "tokens": [407, 321, 767, 2906, 552, 439, 382, 257, 8141, 1783, 11, 597, 307, 294, 527, 8310, 4641, 538, 10139, 1860, 13, 407, 8310, 4641, 538, 413, 11, 4238, 314, 538, 413, 13], "temperature": 0.0, "avg_logprob": -0.13085580112958195, "compression_ratio": 1.6506550218340612, "no_speech_prob": 4.398666715133004e-05}, {"id": 400, "seek": 246312, "start": 2473.12, "end": 2488.12, "text": " And now if we have the matrix for each of our key query and value, right, we're going to apply, like we're going to look at these things XK, XQ, and XV, which are all of the same dimensionality as X because of the D by D transformations.", "tokens": [400, 586, 498, 321, 362, 264, 8141, 337, 1184, 295, 527, 2141, 14581, 293, 2158, 11, 558, 11, 321, 434, 516, 281, 3079, 11, 411, 321, 434, 516, 281, 574, 412, 613, 721, 1783, 42, 11, 1783, 48, 11, 293, 1783, 53, 11, 597, 366, 439, 295, 264, 912, 10139, 1860, 382, 1783, 570, 295, 264, 413, 538, 413, 34852, 13], "temperature": 0.0, "avg_logprob": -0.13085580112958195, "compression_ratio": 1.6506550218340612, "no_speech_prob": 4.398666715133004e-05}, {"id": 401, "seek": 248812, "start": 2488.12, "end": 2495.12, "text": " So how do we compute self-attention? We have our output tensor, which is the same dimensionality as the input X.", "tokens": [407, 577, 360, 321, 14722, 2698, 12, 1591, 1251, 30, 492, 362, 527, 5598, 40863, 11, 597, 307, 264, 912, 10139, 1860, 382, 264, 4846, 1783, 13], "temperature": 0.0, "avg_logprob": -0.1146674233098184, "compression_ratio": 1.6782006920415224, "no_speech_prob": 0.00013762869639322162}, {"id": 402, "seek": 248812, "start": 2495.12, "end": 2503.12, "text": " This is going to be equal to softmax, or as a softmax, of this matrix multiplication, which we'll get into, times the value vectors.", "tokens": [639, 307, 516, 281, 312, 2681, 281, 2787, 41167, 11, 420, 382, 257, 2787, 41167, 11, 295, 341, 8141, 27290, 11, 597, 321, 603, 483, 666, 11, 1413, 264, 2158, 18875, 13], "temperature": 0.0, "avg_logprob": -0.1146674233098184, "compression_ratio": 1.6782006920415224, "no_speech_prob": 0.00013762869639322162}, {"id": 403, "seek": 248812, "start": 2503.12, "end": 2509.12, "text": " So the matrix multiplication here is computing affinities between keys and queries we'll see. And then here's our averaging.", "tokens": [407, 264, 8141, 27290, 510, 307, 15866, 2096, 259, 1088, 1296, 9317, 293, 24109, 321, 603, 536, 13, 400, 550, 510, 311, 527, 47308, 13], "temperature": 0.0, "avg_logprob": -0.1146674233098184, "compression_ratio": 1.6782006920415224, "no_speech_prob": 0.00013762869639322162}, {"id": 404, "seek": 248812, "start": 2509.12, "end": 2517.12, "text": " What does that look like pictorially? So you take the key query dot products. So this term here, XQ, XK transpose.", "tokens": [708, 775, 300, 574, 411, 2317, 284, 2270, 30, 407, 291, 747, 264, 2141, 14581, 5893, 3383, 13, 407, 341, 1433, 510, 11, 1783, 48, 11, 1783, 42, 25167, 13], "temperature": 0.0, "avg_logprob": -0.1146674233098184, "compression_ratio": 1.6782006920415224, "no_speech_prob": 0.00013762869639322162}, {"id": 405, "seek": 251712, "start": 2517.12, "end": 2526.12, "text": " It's giving you all dot products, all T by T pairs of attention scores. So our Eij are in this matrix right here. It's T by T.", "tokens": [467, 311, 2902, 291, 439, 5893, 3383, 11, 439, 314, 538, 314, 15494, 295, 3202, 13444, 13, 407, 527, 462, 1718, 366, 294, 341, 8141, 558, 510, 13, 467, 311, 314, 538, 314, 13], "temperature": 0.0, "avg_logprob": -0.1355405535016741, "compression_ratio": 1.6136363636363635, "no_speech_prob": 0.00015592070121783763}, {"id": 406, "seek": 251712, "start": 2526.12, "end": 2536.12, "text": " And this is just a big matrix multiplication. So you do the matrix multiplication, XQ, and then XK, and then you get all of the dot products by through this.", "tokens": [400, 341, 307, 445, 257, 955, 8141, 27290, 13, 407, 291, 360, 264, 8141, 27290, 11, 1783, 48, 11, 293, 550, 1783, 42, 11, 293, 550, 291, 483, 439, 295, 264, 5893, 3383, 538, 807, 341, 13], "temperature": 0.0, "avg_logprob": -0.1355405535016741, "compression_ratio": 1.6136363636363635, "no_speech_prob": 0.00015592070121783763}, {"id": 407, "seek": 253612, "start": 2536.12, "end": 2550.12, "text": " So now you have this big T by T set of scores. That's what we wanted. And now you can softmax that directly as a matrix. And then do a matrix multiplication here with XV in order to give your output vector.", "tokens": [407, 586, 291, 362, 341, 955, 314, 538, 314, 992, 295, 13444, 13, 663, 311, 437, 321, 1415, 13, 400, 586, 291, 393, 2787, 41167, 300, 3838, 382, 257, 8141, 13, 400, 550, 360, 257, 8141, 27290, 510, 365, 1783, 53, 294, 1668, 281, 976, 428, 5598, 8062, 13], "temperature": 0.0, "avg_logprob": -0.11036898426173888, "compression_ratio": 1.5766129032258065, "no_speech_prob": 1.892107138701249e-05}, {"id": 408, "seek": 253612, "start": 2550.12, "end": 2559.12, "text": " So this is actually doing the weighted average that we saw at the beginning of the class. And this, you know, there's no for loops here. It's really beautifully, which is a vectorized.", "tokens": [407, 341, 307, 767, 884, 264, 32807, 4274, 300, 321, 1866, 412, 264, 2863, 295, 264, 1508, 13, 400, 341, 11, 291, 458, 11, 456, 311, 572, 337, 16121, 510, 13, 467, 311, 534, 16525, 11, 597, 307, 257, 8062, 1602, 13], "temperature": 0.0, "avg_logprob": -0.11036898426173888, "compression_ratio": 1.5766129032258065, "no_speech_prob": 1.892107138701249e-05}, {"id": 409, "seek": 255912, "start": 2559.12, "end": 2578.12, "text": " And it gives us our output, which again, remember same dimensionality T by D. Okay, so all periods of attention scores then compute the averages by applying the score, the softmax of the scores to the XV matrix.", "tokens": [400, 309, 2709, 505, 527, 5598, 11, 597, 797, 11, 1604, 912, 10139, 1860, 314, 538, 413, 13, 1033, 11, 370, 439, 13804, 295, 3202, 13444, 550, 14722, 264, 42257, 538, 9275, 264, 6175, 11, 264, 2787, 41167, 295, 264, 13444, 281, 264, 1783, 53, 8141, 13], "temperature": 0.0, "avg_logprob": -0.13526012383255304, "compression_ratio": 1.37012987012987, "no_speech_prob": 3.7046200304757804e-05}, {"id": 410, "seek": 257812, "start": 2578.12, "end": 2591.12, "text": " So that's it. That's it for key query value attention. That's how, you know, we implemented with tensors. Next we'll look at the kind of the next thing that ends up being quite important for training transformers in practice, which is multi-headed attention.", "tokens": [407, 300, 311, 309, 13, 663, 311, 309, 337, 2141, 14581, 2158, 3202, 13, 663, 311, 577, 11, 291, 458, 11, 321, 12270, 365, 10688, 830, 13, 3087, 321, 603, 574, 412, 264, 733, 295, 264, 958, 551, 300, 5314, 493, 885, 1596, 1021, 337, 3097, 4088, 433, 294, 3124, 11, 597, 307, 4825, 12, 28409, 3202, 13], "temperature": 0.0, "avg_logprob": -0.16555569761542863, "compression_ratio": 1.7268722466960353, "no_speech_prob": 4.26358928962145e-05}, {"id": 411, "seek": 257812, "start": 2591.12, "end": 2599.12, "text": " So transfer encoder multi-headed attention. So the question is what, what we want to look at multiple places in the sentence at once?", "tokens": [407, 5003, 2058, 19866, 4825, 12, 28409, 3202, 13, 407, 264, 1168, 307, 437, 11, 437, 321, 528, 281, 574, 412, 3866, 3190, 294, 264, 8174, 412, 1564, 30], "temperature": 0.0, "avg_logprob": -0.16555569761542863, "compression_ratio": 1.7268722466960353, "no_speech_prob": 4.26358928962145e-05}, {"id": 412, "seek": 259912, "start": 2599.12, "end": 2608.12, "text": " It's possible to do that, you know, with self attention, with normal self attention. But think about this. Where do you end up looking in self attention?", "tokens": [467, 311, 1944, 281, 360, 300, 11, 291, 458, 11, 365, 2698, 3202, 11, 365, 2710, 2698, 3202, 13, 583, 519, 466, 341, 13, 2305, 360, 291, 917, 493, 1237, 294, 2698, 3202, 30], "temperature": 0.0, "avg_logprob": -0.17158529731664765, "compression_ratio": 1.7352941176470589, "no_speech_prob": 6.500691233668476e-05}, {"id": 413, "seek": 259912, "start": 2608.12, "end": 2623.12, "text": " You end up looking where the dot products of XI, your q matrix transpose your key matrix XJ is high. So those are sort of the XIJ pairs, those are the IJ pairs that end up interacting with each other.", "tokens": [509, 917, 493, 1237, 689, 264, 5893, 3383, 295, 1783, 40, 11, 428, 9505, 8141, 25167, 428, 2141, 8141, 1783, 41, 307, 1090, 13, 407, 729, 366, 1333, 295, 264, 1783, 40, 41, 15494, 11, 729, 366, 264, 286, 41, 15494, 300, 917, 493, 18017, 365, 1184, 661, 13], "temperature": 0.0, "avg_logprob": -0.17158529731664765, "compression_ratio": 1.7352941176470589, "no_speech_prob": 6.500691233668476e-05}, {"id": 414, "seek": 262312, "start": 2623.12, "end": 2632.12, "text": " But maybe for some query, for some word in the out, in, in, for some word you want to focus on different other words in the sentence for different reasons.", "tokens": [583, 1310, 337, 512, 14581, 11, 337, 512, 1349, 294, 264, 484, 11, 294, 11, 294, 11, 337, 512, 1349, 291, 528, 281, 1879, 322, 819, 661, 2283, 294, 264, 8174, 337, 819, 4112, 13], "temperature": 0.0, "avg_logprob": -0.12351545502867879, "compression_ratio": 1.7323232323232323, "no_speech_prob": 4.610102405422367e-05}, {"id": 415, "seek": 262312, "start": 2632.12, "end": 2643.12, "text": " The way that you can encode this is by having multiple query key and value matrices, which all encode different things about the XI. They all trans, are learned different transformations.", "tokens": [440, 636, 300, 291, 393, 2058, 1429, 341, 307, 538, 1419, 3866, 14581, 2141, 293, 2158, 32284, 11, 597, 439, 2058, 1429, 819, 721, 466, 264, 1783, 40, 13, 814, 439, 1145, 11, 366, 3264, 819, 34852, 13], "temperature": 0.0, "avg_logprob": -0.12351545502867879, "compression_ratio": 1.7323232323232323, "no_speech_prob": 4.610102405422367e-05}, {"id": 416, "seek": 264312, "start": 2643.12, "end": 2658.12, "text": " So instead of a single q, a single K, and a single V, what we get are a Q sub L, K sub L, V sub L, all of a different dimensionality now. So by their dimensionality D by D over H, where H is the number of heads.", "tokens": [407, 2602, 295, 257, 2167, 9505, 11, 257, 2167, 591, 11, 293, 257, 2167, 691, 11, 437, 321, 483, 366, 257, 1249, 1422, 441, 11, 591, 1422, 441, 11, 691, 1422, 441, 11, 439, 295, 257, 819, 10139, 1860, 586, 13, 407, 538, 641, 10139, 1860, 413, 538, 413, 670, 389, 11, 689, 389, 307, 264, 1230, 295, 8050, 13], "temperature": 0.0, "avg_logprob": -0.11694810745563913, "compression_ratio": 1.71875, "no_speech_prob": 4.75629058200866e-05}, {"id": 417, "seek": 264312, "start": 2658.12, "end": 2667.12, "text": " So they're going to still apply to the X matrix, but they're going to transform it to a smaller dimensionality D by H.", "tokens": [407, 436, 434, 516, 281, 920, 3079, 281, 264, 1783, 8141, 11, 457, 436, 434, 516, 281, 4088, 309, 281, 257, 4356, 10139, 1860, 413, 538, 389, 13], "temperature": 0.0, "avg_logprob": -0.11694810745563913, "compression_ratio": 1.71875, "no_speech_prob": 4.75629058200866e-05}, {"id": 418, "seek": 266712, "start": 2667.12, "end": 2681.12, "text": " And then each attention head is going to perform attention independently. It's like you just did it a whole bunch of times. Right? So output L is equal to softmax of, you know, here's your QK, but now it's in L form.", "tokens": [400, 550, 1184, 3202, 1378, 307, 516, 281, 2042, 3202, 21761, 13, 467, 311, 411, 291, 445, 630, 309, 257, 1379, 3840, 295, 1413, 13, 1779, 30, 407, 5598, 441, 307, 2681, 281, 2787, 41167, 295, 11, 291, 458, 11, 510, 311, 428, 1249, 42, 11, 457, 586, 309, 311, 294, 441, 1254, 13], "temperature": 0.0, "avg_logprob": -0.14316481557385674, "compression_ratio": 1.3584905660377358, "no_speech_prob": 0.00012530166713986546}, {"id": 419, "seek": 268112, "start": 2681.12, "end": 2698.12, "text": " So now you have X, VL, and now you have sort of these indexed outputs. And in order to sort of have the output dimensionality be equal to the input dimensionality and sort of mixed things around, combine all the information from the different heads, you concatenate the heads.", "tokens": [407, 586, 291, 362, 1783, 11, 691, 43, 11, 293, 586, 291, 362, 1333, 295, 613, 8186, 292, 23930, 13, 400, 294, 1668, 281, 1333, 295, 362, 264, 5598, 10139, 1860, 312, 2681, 281, 264, 4846, 10139, 1860, 293, 1333, 295, 7467, 721, 926, 11, 10432, 439, 264, 1589, 490, 264, 819, 8050, 11, 291, 1588, 7186, 473, 264, 8050, 13], "temperature": 0.0, "avg_logprob": -0.25480904212364786, "compression_ratio": 1.6428571428571428, "no_speech_prob": 2.58636282524094e-05}, {"id": 420, "seek": 269812, "start": 2698.12, "end": 2717.12, "text": " And then through output H, stack them together. Now the dimensionality of this is equal to the dimensionality of X again. And then we use a learned matrix Y, in order to sort of do the mixing Y is D by D. And that's the output of multi headed attention, multi headed self attention.", "tokens": [400, 550, 807, 5598, 389, 11, 8630, 552, 1214, 13, 823, 264, 10139, 1860, 295, 341, 307, 2681, 281, 264, 10139, 1860, 295, 1783, 797, 13, 400, 550, 321, 764, 257, 3264, 8141, 398, 11, 294, 1668, 281, 1333, 295, 360, 264, 11983, 398, 307, 413, 538, 413, 13, 400, 300, 311, 264, 5598, 295, 4825, 12798, 3202, 11, 4825, 12798, 2698, 3202, 13], "temperature": 0.0, "avg_logprob": -0.17619747274062214, "compression_ratio": 1.6114285714285714, "no_speech_prob": 4.005262235295959e-05}, {"id": 421, "seek": 271712, "start": 2717.12, "end": 2733.12, "text": " And so because different, so each head gets to look at different things, right? Because they can all sort of the linear transformations can you can say focus on different parts of the X vectors. And the value vectors also get to be different as well.", "tokens": [400, 370, 570, 819, 11, 370, 1184, 1378, 2170, 281, 574, 412, 819, 721, 11, 558, 30, 1436, 436, 393, 439, 1333, 295, 264, 8213, 34852, 393, 291, 393, 584, 1879, 322, 819, 3166, 295, 264, 1783, 18875, 13, 400, 264, 2158, 18875, 611, 483, 281, 312, 819, 382, 731, 13], "temperature": 0.0, "avg_logprob": -0.14468957727605647, "compression_ratio": 1.5723270440251573, "no_speech_prob": 3.647314588306472e-05}, {"id": 422, "seek": 273312, "start": 2733.12, "end": 2751.12, "text": " So pictorially, this is what we had before single headed attention. You had X multiplied by Q in order to get XQ. And what's interesting, and you can see this, you know, you can see this from this diagram, I think, is that multi headed attention doesn't necessarily have to be more, more work.", "tokens": [407, 2317, 284, 2270, 11, 341, 307, 437, 321, 632, 949, 2167, 12798, 3202, 13, 509, 632, 1783, 17207, 538, 1249, 294, 1668, 281, 483, 1783, 48, 13, 400, 437, 311, 1880, 11, 293, 291, 393, 536, 341, 11, 291, 458, 11, 291, 393, 536, 341, 490, 341, 10686, 11, 286, 519, 11, 307, 300, 4825, 12798, 3202, 1177, 380, 4725, 362, 281, 312, 544, 11, 544, 589, 13], "temperature": 0.0, "avg_logprob": -0.13619251773781973, "compression_ratio": 1.5668449197860963, "no_speech_prob": 3.882005330524407e-05}, {"id": 423, "seek": 275112, "start": 2751.12, "end": 2770.12, "text": " And we saw that the QK and V matrices in multi headed attention have a lower output dimensionality. So here's two of them right here. Here's Q1 and Q2. The same size is Q. And then you get outputs XQ1 and XQ2.", "tokens": [400, 321, 1866, 300, 264, 1249, 42, 293, 691, 32284, 294, 4825, 12798, 3202, 362, 257, 3126, 5598, 10139, 1860, 13, 407, 510, 311, 732, 295, 552, 558, 510, 13, 1692, 311, 1249, 16, 293, 1249, 17, 13, 440, 912, 2744, 307, 1249, 13, 400, 550, 291, 483, 23930, 1783, 48, 16, 293, 1783, 48, 17, 13], "temperature": 0.0, "avg_logprob": -0.15677760077304528, "compression_ratio": 1.375, "no_speech_prob": 4.330819137976505e-05}, {"id": 424, "seek": 277012, "start": 2770.12, "end": 2783.12, "text": " And so you're effectively doing the same amount of computation as before. But now you're sort of doing, you have different attention distributions for each of the different heads. This is pretty cool.", "tokens": [400, 370, 291, 434, 8659, 884, 264, 912, 2372, 295, 24903, 382, 949, 13, 583, 586, 291, 434, 1333, 295, 884, 11, 291, 362, 819, 3202, 37870, 337, 1184, 295, 264, 819, 8050, 13, 639, 307, 1238, 1627, 13], "temperature": 0.0, "avg_logprob": -0.11248207092285156, "compression_ratio": 1.408450704225352, "no_speech_prob": 1.6440873878309503e-05}, {"id": 425, "seek": 278312, "start": 2783.12, "end": 2803.12, "text": " So those are the main modeling differences, right? We did key query value attention. That's how that's how we got the key queries and values from the X vectors. And we saw how to implement that in the matrices that we're looking at.", "tokens": [407, 729, 366, 264, 2135, 15983, 7300, 11, 558, 30, 492, 630, 2141, 14581, 2158, 3202, 13, 663, 311, 577, 300, 311, 577, 321, 658, 264, 2141, 24109, 293, 4190, 490, 264, 1783, 18875, 13, 400, 321, 1866, 577, 281, 4445, 300, 294, 264, 32284, 300, 321, 434, 1237, 412, 13], "temperature": 0.0, "avg_logprob": -0.07194108096036043, "compression_ratio": 1.4591194968553458, "no_speech_prob": 1.2218300071253907e-05}, {"id": 426, "seek": 280312, "start": 2803.12, "end": 2827.12, "text": " And then we looked at the multi headed attention, which allows us to look in different places in the sequence to in order to have more flexibility within a given layer. Now we're going to talk about our training tricks. These are really important. It turns out. And so, yeah, maybe thinking about them, I think, is something that we don't do enough in the field. And so let's really walk through them.", "tokens": [400, 550, 321, 2956, 412, 264, 4825, 12798, 3202, 11, 597, 4045, 505, 281, 574, 294, 819, 3190, 294, 264, 8310, 281, 294, 1668, 281, 362, 544, 12635, 1951, 257, 2212, 4583, 13, 823, 321, 434, 516, 281, 751, 466, 527, 3097, 11733, 13, 1981, 366, 534, 1021, 13, 467, 4523, 484, 13, 400, 370, 11, 1338, 11, 1310, 1953, 466, 552, 11, 286, 519, 11, 307, 746, 300, 321, 500, 380, 360, 1547, 294, 264, 2519, 13, 400, 370, 718, 311, 534, 1792, 807, 552, 13], "temperature": 0.0, "avg_logprob": -0.13268854329874227, "compression_ratio": 1.5912698412698412, "no_speech_prob": 1.6696914826752618e-05}, {"id": 427, "seek": 282712, "start": 2827.12, "end": 2838.12, "text": " So residual connections residual connections have been around residual connections. You can think of them as helping the model train better for number number of reasons. Let's look at what they're doing first.", "tokens": [407, 27980, 9271, 27980, 9271, 362, 668, 926, 27980, 9271, 13, 509, 393, 519, 295, 552, 382, 4315, 264, 2316, 3847, 1101, 337, 1230, 1230, 295, 4112, 13, 961, 311, 574, 412, 437, 436, 434, 884, 700, 13], "temperature": 0.0, "avg_logprob": -0.16344904899597168, "compression_ratio": 1.748768472906404, "no_speech_prob": 0.00017127569299191236}, {"id": 428, "seek": 282712, "start": 2838.12, "end": 2849.12, "text": " Our residual connection looks like this. So you have a normal layer. X in some layer, IIs representing sort of the layer in depth in the network.", "tokens": [2621, 27980, 4984, 1542, 411, 341, 13, 407, 291, 362, 257, 2710, 4583, 13, 1783, 294, 512, 4583, 11, 286, 6802, 13460, 1333, 295, 264, 4583, 294, 7161, 294, 264, 3209, 13], "temperature": 0.0, "avg_logprob": -0.16344904899597168, "compression_ratio": 1.748768472906404, "no_speech_prob": 0.00017127569299191236}, {"id": 429, "seek": 284912, "start": 2849.12, "end": 2860.12, "text": " So X i is equal to some layer of X i minus one. So you had, right, you had, I don't know what this layer is doing necessarily, but this layer is a function of the previous layer.", "tokens": [407, 1783, 741, 307, 2681, 281, 512, 4583, 295, 1783, 741, 3175, 472, 13, 407, 291, 632, 11, 558, 11, 291, 632, 11, 286, 500, 380, 458, 437, 341, 4583, 307, 884, 4725, 11, 457, 341, 4583, 307, 257, 2445, 295, 264, 3894, 4583, 13], "temperature": 0.0, "avg_logprob": -0.16520946025848388, "compression_ratio": 1.6065573770491803, "no_speech_prob": 6.107916124165058e-05}, {"id": 430, "seek": 284912, "start": 2860.12, "end": 2868.12, "text": " Okay. And so you got this. So again, I want to abstract over what the layer is doing, but you just pass it through.", "tokens": [1033, 13, 400, 370, 291, 658, 341, 13, 407, 797, 11, 286, 528, 281, 12649, 670, 437, 264, 4583, 307, 884, 11, 457, 291, 445, 1320, 309, 807, 13], "temperature": 0.0, "avg_logprob": -0.16520946025848388, "compression_ratio": 1.6065573770491803, "no_speech_prob": 6.107916124165058e-05}, {"id": 431, "seek": 286812, "start": 2868.12, "end": 2880.12, "text": " So the actual connection is doing something very simple. It's saying, okay, I'm going to take the function I was computing at my previous layer before, and then I'm going to add it to the previous layer.", "tokens": [407, 264, 3539, 4984, 307, 884, 746, 588, 2199, 13, 467, 311, 1566, 11, 1392, 11, 286, 478, 516, 281, 747, 264, 2445, 286, 390, 15866, 412, 452, 3894, 4583, 949, 11, 293, 550, 286, 478, 516, 281, 909, 309, 281, 264, 3894, 4583, 13], "temperature": 0.0, "avg_logprob": -0.12877046543618906, "compression_ratio": 1.797979797979798, "no_speech_prob": 8.348747360287234e-05}, {"id": 432, "seek": 286812, "start": 2880.12, "end": 2891.12, "text": " So now, X i is not equal to layer of X i minus one. It's equal to X i minus one plus layer of X i minus one. This is it. These are residual connections.", "tokens": [407, 586, 11, 1783, 741, 307, 406, 2681, 281, 4583, 295, 1783, 741, 3175, 472, 13, 467, 311, 2681, 281, 1783, 741, 3175, 472, 1804, 4583, 295, 1783, 741, 3175, 472, 13, 639, 307, 309, 13, 1981, 366, 27980, 9271, 13], "temperature": 0.0, "avg_logprob": -0.12877046543618906, "compression_ratio": 1.797979797979798, "no_speech_prob": 8.348747360287234e-05}, {"id": 433, "seek": 289112, "start": 2891.12, "end": 2906.12, "text": " And the intuition, right, is that like before you started learning anything sort of, you have this notion that you should be learning only how layer i should be different from layer i minus one.", "tokens": [400, 264, 24002, 11, 558, 11, 307, 300, 411, 949, 291, 1409, 2539, 1340, 1333, 295, 11, 291, 362, 341, 10710, 300, 291, 820, 312, 2539, 787, 577, 4583, 741, 820, 312, 819, 490, 4583, 741, 3175, 472, 13], "temperature": 0.0, "avg_logprob": -0.0998871543190696, "compression_ratio": 1.7552083333333333, "no_speech_prob": 7.721201836830005e-05}, {"id": 434, "seek": 289112, "start": 2906.12, "end": 2914.12, "text": " And instead of learning from scratch, what it should look like. So this value here, layer of X i minus one, should be something in some sense.", "tokens": [400, 2602, 295, 2539, 490, 8459, 11, 437, 309, 820, 574, 411, 13, 407, 341, 2158, 510, 11, 4583, 295, 1783, 741, 3175, 472, 11, 820, 312, 746, 294, 512, 2020, 13], "temperature": 0.0, "avg_logprob": -0.0998871543190696, "compression_ratio": 1.7552083333333333, "no_speech_prob": 7.721201836830005e-05}, {"id": 435, "seek": 291412, "start": 2914.12, "end": 2925.12, "text": " And you have to learn how it's different from the previous layer. This is sort of a nice inducted bias. So here, you can kind of represent it as you have this layer. X i minus one goes to the layer.", "tokens": [400, 291, 362, 281, 1466, 577, 309, 311, 819, 490, 264, 3894, 4583, 13, 639, 307, 1333, 295, 257, 1481, 31612, 292, 12577, 13, 407, 510, 11, 291, 393, 733, 295, 2906, 309, 382, 291, 362, 341, 4583, 13, 1783, 741, 3175, 472, 1709, 281, 264, 4583, 13], "temperature": 0.0, "avg_logprob": -0.14135803178299305, "compression_ratio": 1.5509259259259258, "no_speech_prob": 2.9308899684110656e-05}, {"id": 436, "seek": 291412, "start": 2925.12, "end": 2934.12, "text": " It also goes around and just gets added in. Now, think about the gradients, right. We talk about vanishing gradients. There are problem.", "tokens": [467, 611, 1709, 926, 293, 445, 2170, 3869, 294, 13, 823, 11, 519, 466, 264, 2771, 2448, 11, 558, 13, 492, 751, 466, 3161, 3807, 2771, 2448, 13, 821, 366, 1154, 13], "temperature": 0.0, "avg_logprob": -0.14135803178299305, "compression_ratio": 1.5509259259259258, "no_speech_prob": 2.9308899684110656e-05}, {"id": 437, "seek": 293412, "start": 2934.12, "end": 2946.12, "text": " The gradient of this connection here is beautiful, right. Even if everything is saturating, all of your sigmoids are saturating or your ray loos are all negative. So the gradients are all zero.", "tokens": [440, 16235, 295, 341, 4984, 510, 307, 2238, 11, 558, 13, 2754, 498, 1203, 307, 21160, 990, 11, 439, 295, 428, 4556, 3280, 3742, 366, 21160, 990, 420, 428, 18592, 450, 329, 366, 439, 3671, 13, 407, 264, 2771, 2448, 366, 439, 4018, 13], "temperature": 0.0, "avg_logprob": -0.14796399153195894, "compression_ratio": 1.7366412213740459, "no_speech_prob": 4.6832796215312555e-05}, {"id": 438, "seek": 293412, "start": 2946.12, "end": 2952.12, "text": " You get gradients propagating back through the rest of the network anyway through this connection here. That's pretty cool.", "tokens": [509, 483, 2771, 2448, 12425, 990, 646, 807, 264, 1472, 295, 264, 3209, 4033, 807, 341, 4984, 510, 13, 663, 311, 1238, 1627, 13], "temperature": 0.0, "avg_logprob": -0.14796399153195894, "compression_ratio": 1.7366412213740459, "no_speech_prob": 4.6832796215312555e-05}, {"id": 439, "seek": 293412, "start": 2952.12, "end": 2962.12, "text": " Turns out to be massively useful. And just to take a quick visualization, this plot just never ceases to look really, really interesting.", "tokens": [29524, 484, 281, 312, 29379, 4420, 13, 400, 445, 281, 747, 257, 1702, 25801, 11, 341, 7542, 445, 1128, 1769, 1957, 281, 574, 534, 11, 534, 1880, 13], "temperature": 0.0, "avg_logprob": -0.14796399153195894, "compression_ratio": 1.7366412213740459, "no_speech_prob": 4.6832796215312555e-05}, {"id": 440, "seek": 296212, "start": 2962.12, "end": 2976.12, "text": " Here is sort of a visualization of a loss landscape. So each sort of point in the 2D plane is like a, is a sort of a setting of a parameters of your network.", "tokens": [1692, 307, 1333, 295, 257, 25801, 295, 257, 4470, 9661, 13, 407, 1184, 1333, 295, 935, 294, 264, 568, 35, 5720, 307, 411, 257, 11, 307, 257, 1333, 295, 257, 3287, 295, 257, 9834, 295, 428, 3209, 13], "temperature": 0.0, "avg_logprob": -0.15334956429221414, "compression_ratio": 1.8177966101694916, "no_speech_prob": 8.884912676876411e-05}, {"id": 441, "seek": 296212, "start": 2976.12, "end": 2982.12, "text": " And then sort of the z-axis is the loss of the network that is being optimized for, right.", "tokens": [400, 550, 1333, 295, 264, 710, 12, 24633, 307, 264, 4470, 295, 264, 3209, 300, 307, 885, 26941, 337, 11, 558, 13], "temperature": 0.0, "avg_logprob": -0.15334956429221414, "compression_ratio": 1.8177966101694916, "no_speech_prob": 8.884912676876411e-05}, {"id": 442, "seek": 296212, "start": 2982.12, "end": 2991.12, "text": " And here's a network with no residuals. And you have to have to gradient descent. And you sort of have to find a local minimum. And it's really hard to find the nice local minimum.", "tokens": [400, 510, 311, 257, 3209, 365, 572, 27980, 82, 13, 400, 291, 362, 281, 362, 281, 16235, 23475, 13, 400, 291, 1333, 295, 362, 281, 915, 257, 2654, 7285, 13, 400, 309, 311, 534, 1152, 281, 915, 264, 1481, 2654, 7285, 13], "temperature": 0.0, "avg_logprob": -0.15334956429221414, "compression_ratio": 1.8177966101694916, "no_speech_prob": 8.884912676876411e-05}, {"id": 443, "seek": 299112, "start": 2991.12, "end": 3003.12, "text": " And then with the residual network, you know, it's much smoother. So you can imagine how is the cast of gradient descent is sort of walking down here to this nice, very low local minimum.", "tokens": [400, 550, 365, 264, 27980, 3209, 11, 291, 458, 11, 309, 311, 709, 28640, 13, 407, 291, 393, 3811, 577, 307, 264, 4193, 295, 16235, 23475, 307, 1333, 295, 4494, 760, 510, 281, 341, 1481, 11, 588, 2295, 2654, 7285, 13], "temperature": 0.0, "avg_logprob": -0.12516523611665975, "compression_ratio": 1.7551867219917012, "no_speech_prob": 4.468575571081601e-05}, {"id": 444, "seek": 299112, "start": 3003.12, "end": 3009.12, "text": " This is a paper that was trying to explain why residual connections are so useful.", "tokens": [639, 307, 257, 3035, 300, 390, 1382, 281, 2903, 983, 27980, 9271, 366, 370, 4420, 13], "temperature": 0.0, "avg_logprob": -0.12516523611665975, "compression_ratio": 1.7551867219917012, "no_speech_prob": 4.468575571081601e-05}, {"id": 445, "seek": 299112, "start": 3009.12, "end": 3019.12, "text": " So this might be an intuition that might be useful for you. So this is, you know, this is a so called loss landscape. So those are residual connections.", "tokens": [407, 341, 1062, 312, 364, 24002, 300, 1062, 312, 4420, 337, 291, 13, 407, 341, 307, 11, 291, 458, 11, 341, 307, 257, 370, 1219, 4470, 9661, 13, 407, 729, 366, 27980, 9271, 13], "temperature": 0.0, "avg_logprob": -0.12516523611665975, "compression_ratio": 1.7551867219917012, "no_speech_prob": 4.468575571081601e-05}, {"id": 446, "seek": 301912, "start": 3019.12, "end": 3024.12, "text": " And it's, they seem simple, but a lot of simple ideas end up being super useful in deep learning.", "tokens": [400, 309, 311, 11, 436, 1643, 2199, 11, 457, 257, 688, 295, 2199, 3487, 917, 493, 885, 1687, 4420, 294, 2452, 2539, 13], "temperature": 0.0, "avg_logprob": -0.09196006373355263, "compression_ratio": 1.706140350877193, "no_speech_prob": 5.389347279560752e-05}, {"id": 447, "seek": 301912, "start": 3024.12, "end": 3033.12, "text": " So in layer normalization, we're doing something sort of similar. We're trying to help the network train better.", "tokens": [407, 294, 4583, 2710, 2144, 11, 321, 434, 884, 746, 1333, 295, 2531, 13, 492, 434, 1382, 281, 854, 264, 3209, 3847, 1101, 13], "temperature": 0.0, "avg_logprob": -0.09196006373355263, "compression_ratio": 1.706140350877193, "no_speech_prob": 5.389347279560752e-05}, {"id": 448, "seek": 301912, "start": 3033.12, "end": 3045.12, "text": " But we're doing it via a pretty different intuition. So layer normalization is thought to say, at different times in my network, when I'm training it, I'm doing the forward pass.", "tokens": [583, 321, 434, 884, 309, 5766, 257, 1238, 819, 24002, 13, 407, 4583, 2710, 2144, 307, 1194, 281, 584, 11, 412, 819, 1413, 294, 452, 3209, 11, 562, 286, 478, 3097, 309, 11, 286, 478, 884, 264, 2128, 1320, 13], "temperature": 0.0, "avg_logprob": -0.09196006373355263, "compression_ratio": 1.706140350877193, "no_speech_prob": 5.389347279560752e-05}, {"id": 449, "seek": 304512, "start": 3045.12, "end": 3053.12, "text": " There's a lot of variation in what the forward pass looks like. And a lot of is uninformative. And that can harm training.", "tokens": [821, 311, 257, 688, 295, 12990, 294, 437, 264, 2128, 1320, 1542, 411, 13, 400, 257, 688, 295, 307, 517, 37811, 1166, 13, 400, 300, 393, 6491, 3097, 13], "temperature": 0.0, "avg_logprob": -0.12084460258483887, "compression_ratio": 1.7699530516431925, "no_speech_prob": 3.704796472447924e-05}, {"id": 450, "seek": 304512, "start": 3053.12, "end": 3066.12, "text": " But if we normalize within a layer to a single to unit mean and standard deviation, then that sort of cuts down on all this sort of uninformative variation.", "tokens": [583, 498, 321, 2710, 1125, 1951, 257, 4583, 281, 257, 2167, 281, 4985, 914, 293, 3832, 25163, 11, 550, 300, 1333, 295, 9992, 760, 322, 439, 341, 1333, 295, 517, 37811, 1166, 12990, 13], "temperature": 0.0, "avg_logprob": -0.12084460258483887, "compression_ratio": 1.7699530516431925, "no_speech_prob": 3.704796472447924e-05}, {"id": 451, "seek": 304512, "start": 3066.12, "end": 3072.12, "text": " And the informative variation sort of how the units were different from each other is maintained.", "tokens": [400, 264, 27759, 12990, 1333, 295, 577, 264, 6815, 645, 819, 490, 1184, 661, 307, 17578, 13], "temperature": 0.0, "avg_logprob": -0.12084460258483887, "compression_ratio": 1.7699530516431925, "no_speech_prob": 3.704796472447924e-05}, {"id": 452, "seek": 307212, "start": 3072.12, "end": 3084.12, "text": " So it's also thought that the successive layer norm, and there's been a lot of successive layer norm has been due actually to helping normalize the gradients of each layer. This is recent work.", "tokens": [407, 309, 311, 611, 1194, 300, 264, 48043, 4583, 2026, 11, 293, 456, 311, 668, 257, 688, 295, 48043, 4583, 2026, 575, 668, 3462, 767, 281, 4315, 2710, 1125, 264, 2771, 2448, 295, 1184, 4583, 13, 639, 307, 5162, 589, 13], "temperature": 0.0, "avg_logprob": -0.10214798102218113, "compression_ratio": 1.6774193548387097, "no_speech_prob": 6.50203219265677e-05}, {"id": 453, "seek": 307212, "start": 3084.12, "end": 3095.12, "text": " So let's talk about how it's implemented. So we're going to go back to X and not going to index it here. So just X is some vector, some word vector in in our transformer.", "tokens": [407, 718, 311, 751, 466, 577, 309, 311, 12270, 13, 407, 321, 434, 516, 281, 352, 646, 281, 1783, 293, 406, 516, 281, 8186, 309, 510, 13, 407, 445, 1783, 307, 512, 8062, 11, 512, 1349, 8062, 294, 294, 527, 31782, 13], "temperature": 0.0, "avg_logprob": -0.10214798102218113, "compression_ratio": 1.6774193548387097, "no_speech_prob": 6.50203219265677e-05}, {"id": 454, "seek": 309512, "start": 3095.12, "end": 3105.12, "text": " We're going to compute an estimate of the mean. Just by summing the hidden units, we're going to compute an estimate of the standard deviation.", "tokens": [492, 434, 516, 281, 14722, 364, 12539, 295, 264, 914, 13, 1449, 538, 2408, 2810, 264, 7633, 6815, 11, 321, 434, 516, 281, 14722, 364, 12539, 295, 264, 3832, 25163, 13], "temperature": 0.0, "avg_logprob": -0.16509128624284772, "compression_ratio": 1.89171974522293, "no_speech_prob": 0.00017393891175743192}, {"id": 455, "seek": 309512, "start": 3105.12, "end": 3116.12, "text": " Similarly, so like you've taken a single RDE vector, you just sum them, you compute the mean, you estimate the mean, you estimate the standard deviation.", "tokens": [13157, 11, 370, 411, 291, 600, 2726, 257, 2167, 497, 22296, 8062, 11, 291, 445, 2408, 552, 11, 291, 14722, 264, 914, 11, 291, 12539, 264, 914, 11, 291, 12539, 264, 3832, 25163, 13], "temperature": 0.0, "avg_logprob": -0.16509128624284772, "compression_ratio": 1.89171974522293, "no_speech_prob": 0.00017393891175743192}, {"id": 456, "seek": 311612, "start": 3116.12, "end": 3137.12, "text": " Now, you also, potentially, and this is optional, learn element wise, gain and bias parameters to try to sort of rescale things if certain hidden units sort of should have larger value in general, or should be multiplicatively larger in general.", "tokens": [823, 11, 291, 611, 11, 7263, 11, 293, 341, 307, 17312, 11, 1466, 4478, 10829, 11, 6052, 293, 12577, 9834, 281, 853, 281, 1333, 295, 9610, 1220, 721, 498, 1629, 7633, 6815, 1333, 295, 820, 362, 4833, 2158, 294, 2674, 11, 420, 820, 312, 17596, 19020, 4833, 294, 2674, 13], "temperature": 0.0, "avg_logprob": -0.14763785291601111, "compression_ratio": 1.5408805031446542, "no_speech_prob": 2.8849106456618756e-05}, {"id": 457, "seek": 313712, "start": 3137.12, "end": 3149.12, "text": " So these are vectors in RDE, just like X was a vector in RDE. And then here's what layer normalization computes. You have your output, which is going to be in RDE, just like your input.", "tokens": [407, 613, 366, 18875, 294, 497, 22296, 11, 445, 411, 1783, 390, 257, 8062, 294, 497, 22296, 13, 400, 550, 510, 311, 437, 4583, 2710, 2144, 715, 1819, 13, 509, 362, 428, 5598, 11, 597, 307, 516, 281, 312, 294, 497, 22296, 11, 445, 411, 428, 4846, 13], "temperature": 0.0, "avg_logprob": -0.14704398105019018, "compression_ratio": 1.559782608695652, "no_speech_prob": 0.00032998432288877666}, {"id": 458, "seek": 313712, "start": 3149.12, "end": 3160.12, "text": " And you take your vector X, you subtract the mean from all of them, you divide by standard deviation.", "tokens": [400, 291, 747, 428, 8062, 1783, 11, 291, 16390, 264, 914, 490, 439, 295, 552, 11, 291, 9845, 538, 3832, 25163, 13], "temperature": 0.0, "avg_logprob": -0.14704398105019018, "compression_ratio": 1.559782608695652, "no_speech_prob": 0.00032998432288877666}, {"id": 459, "seek": 316012, "start": 3160.12, "end": 3179.12, "text": " So you add an epsilon that's small in order if the standard deviation becomes very small, you don't want this to denominator to become too, too, too small because then you get huge numbers and then your network goes to NAN and doesn't train.", "tokens": [407, 291, 909, 364, 17889, 300, 311, 1359, 294, 1668, 498, 264, 3832, 25163, 3643, 588, 1359, 11, 291, 500, 380, 528, 341, 281, 20687, 281, 1813, 886, 11, 886, 11, 886, 1359, 570, 550, 291, 483, 2603, 3547, 293, 550, 428, 3209, 1709, 281, 426, 1770, 293, 1177, 380, 3847, 13], "temperature": 0.0, "avg_logprob": -0.2949948651450021, "compression_ratio": 1.535031847133758, "no_speech_prob": 8.091284689726308e-05}, {"id": 460, "seek": 317912, "start": 3179.12, "end": 3191.12, "text": " So you have some sort of tolerance there. And then so you normalize there, and then our element wise gain and bias, now remember this fraction, X is a vector, everything is being done sort of element wise here, right?", "tokens": [407, 291, 362, 512, 1333, 295, 23368, 456, 13, 400, 550, 370, 291, 2710, 1125, 456, 11, 293, 550, 527, 4478, 10829, 6052, 293, 12577, 11, 586, 1604, 341, 14135, 11, 1783, 307, 257, 8062, 11, 1203, 307, 885, 1096, 1333, 295, 4478, 10829, 510, 11, 558, 30], "temperature": 0.0, "avg_logprob": -0.19880798884800502, "compression_ratio": 1.7462686567164178, "no_speech_prob": 6.107355147833005e-05}, {"id": 461, "seek": 317912, "start": 3191.12, "end": 3199.12, "text": " So this is our D, and then you have this element wise multiplication, this how to mark product with your gain, then you add the bias.", "tokens": [407, 341, 307, 527, 413, 11, 293, 550, 291, 362, 341, 4478, 10829, 27290, 11, 341, 577, 281, 1491, 1674, 365, 428, 6052, 11, 550, 291, 909, 264, 12577, 13], "temperature": 0.0, "avg_logprob": -0.19880798884800502, "compression_ratio": 1.7462686567164178, "no_speech_prob": 6.107355147833005e-05}, {"id": 462, "seek": 319912, "start": 3199.12, "end": 3216.12, "text": " Whether the gain and bias are necessary is unclear, this paper here suggests that they're not helpful, but they're frequently used. So this is sort of an engineering question at this point, and a science question, whether we can figure out why in general.", "tokens": [8503, 264, 6052, 293, 12577, 366, 4818, 307, 25636, 11, 341, 3035, 510, 13409, 300, 436, 434, 406, 4961, 11, 457, 436, 434, 10374, 1143, 13, 407, 341, 307, 1333, 295, 364, 7043, 1168, 412, 341, 935, 11, 293, 257, 3497, 1168, 11, 1968, 321, 393, 2573, 484, 983, 294, 2674, 13], "temperature": 0.0, "avg_logprob": -0.16618214334760392, "compression_ratio": 1.536144578313253, "no_speech_prob": 5.3059768106322736e-05}, {"id": 463, "seek": 321612, "start": 3216.12, "end": 3230.12, "text": " But yes, that's layer normalization, and it ends up being very important in transformers, you remove it, and they really don't train very well. Okay, so that's our second trick.", "tokens": [583, 2086, 11, 300, 311, 4583, 2710, 2144, 11, 293, 309, 5314, 493, 885, 588, 1021, 294, 4088, 433, 11, 291, 4159, 309, 11, 293, 436, 534, 500, 380, 3847, 588, 731, 13, 1033, 11, 370, 300, 311, 527, 1150, 4282, 13], "temperature": 0.0, "avg_logprob": -0.11561927588089653, "compression_ratio": 1.330827067669173, "no_speech_prob": 0.00010384232882643119}, {"id": 464, "seek": 323012, "start": 3230.12, "end": 3256.12, "text": " The third trick is probably the simplest one, but it's useful to know, and it's just, you can call it scaled dot product attention, because we're going to scale the dot products, like so. Okay, so what we're going to do is we're going to have this intuition that our dimensionality D, and really big neural networks, is going to become very large.", "tokens": [440, 2636, 4282, 307, 1391, 264, 22811, 472, 11, 457, 309, 311, 4420, 281, 458, 11, 293, 309, 311, 445, 11, 291, 393, 818, 309, 36039, 5893, 1674, 3202, 11, 570, 321, 434, 516, 281, 4373, 264, 5893, 3383, 11, 411, 370, 13, 1033, 11, 370, 437, 321, 434, 516, 281, 360, 307, 321, 434, 516, 281, 362, 341, 24002, 300, 527, 10139, 1860, 413, 11, 293, 534, 955, 18161, 9590, 11, 307, 516, 281, 1813, 588, 2416, 13], "temperature": 0.0, "avg_logprob": -0.1264634649437594, "compression_ratio": 1.6367924528301887, "no_speech_prob": 5.918607712374069e-05}, {"id": 465, "seek": 325612, "start": 3256.12, "end": 3263.12, "text": " So maybe our hidden layer in our transformer is a thousand or 2000 or 3000 anyway, it gets big.", "tokens": [407, 1310, 527, 7633, 4583, 294, 527, 31782, 307, 257, 4714, 420, 8132, 420, 20984, 4033, 11, 309, 2170, 955, 13], "temperature": 0.0, "avg_logprob": -0.15670505322908101, "compression_ratio": 1.6616915422885572, "no_speech_prob": 0.00036244766670279205}, {"id": 466, "seek": 325612, "start": 3263.12, "end": 3269.12, "text": " And when the dimensionality becomes large, the dot products between vectors tend to become large.", "tokens": [400, 562, 264, 10139, 1860, 3643, 2416, 11, 264, 5893, 3383, 1296, 18875, 3928, 281, 1813, 2416, 13], "temperature": 0.0, "avg_logprob": -0.15670505322908101, "compression_ratio": 1.6616915422885572, "no_speech_prob": 0.00036244766670279205}, {"id": 467, "seek": 325612, "start": 3269.12, "end": 3278.12, "text": " So for example, if you take the dot product between two random vectors in RD, it grows quite quickly, their dot product grows quite quickly.", "tokens": [407, 337, 1365, 11, 498, 291, 747, 264, 5893, 1674, 1296, 732, 4974, 18875, 294, 49488, 11, 309, 13156, 1596, 2661, 11, 641, 5893, 1674, 13156, 1596, 2661, 13], "temperature": 0.0, "avg_logprob": -0.15670505322908101, "compression_ratio": 1.6616915422885572, "no_speech_prob": 0.00036244766670279205}, {"id": 468, "seek": 327812, "start": 3278.12, "end": 3289.12, "text": " Now, are the vectors random in transformers? Well, they're not uniform random, but you can imagine there's sort of a lot of variation, and in general, as the dimensionality is growing, all these dot products are getting pretty big.", "tokens": [823, 11, 366, 264, 18875, 4974, 294, 4088, 433, 30, 1042, 11, 436, 434, 406, 9452, 4974, 11, 457, 291, 393, 3811, 456, 311, 1333, 295, 257, 688, 295, 12990, 11, 293, 294, 2674, 11, 382, 264, 10139, 1860, 307, 4194, 11, 439, 613, 5893, 3383, 366, 1242, 1238, 955, 13], "temperature": 0.0, "avg_logprob": -0.10665788543358277, "compression_ratio": 1.6753246753246753, "no_speech_prob": 4.2642455809982494e-05}, {"id": 469, "seek": 327812, "start": 3289.12, "end": 3298.12, "text": " And this can become a problem for the following reason, right? We're taking all these dot products directly, and taking them putting them into the softmax.", "tokens": [400, 341, 393, 1813, 257, 1154, 337, 264, 3480, 1778, 11, 558, 30, 492, 434, 1940, 439, 613, 5893, 3383, 3838, 11, 293, 1940, 552, 3372, 552, 666, 264, 2787, 41167, 13], "temperature": 0.0, "avg_logprob": -0.10665788543358277, "compression_ratio": 1.6753246753246753, "no_speech_prob": 4.2642455809982494e-05}, {"id": 470, "seek": 329812, "start": 3298.12, "end": 3315.12, "text": " So if there's variation in the dot products, and some of them are very large, then the softmax can become very peaky, putting most of its probability mass on a small number of things, which makes the gradient small for everything else, effectively, right?", "tokens": [407, 498, 456, 311, 12990, 294, 264, 5893, 3383, 11, 293, 512, 295, 552, 366, 588, 2416, 11, 550, 264, 2787, 41167, 393, 1813, 588, 520, 15681, 11, 3372, 881, 295, 1080, 8482, 2758, 322, 257, 1359, 1230, 295, 721, 11, 597, 1669, 264, 16235, 1359, 337, 1203, 1646, 11, 8659, 11, 558, 30], "temperature": 0.0, "avg_logprob": -0.1111780281724601, "compression_ratio": 1.5, "no_speech_prob": 4.0682018152438104e-05}, {"id": 471, "seek": 331512, "start": 3315.12, "end": 3328.12, "text": " Because the softmax is trying to be, well, it's a soft arg max, right? So it's sort of saying, which one of these is like the max, or, you know, weight these sort of relative to how close they are to the max of the function.", "tokens": [1436, 264, 2787, 41167, 307, 1382, 281, 312, 11, 731, 11, 309, 311, 257, 2787, 3882, 11469, 11, 558, 30, 407, 309, 311, 1333, 295, 1566, 11, 597, 472, 295, 613, 307, 411, 264, 11469, 11, 420, 11, 291, 458, 11, 3364, 613, 1333, 295, 4972, 281, 577, 1998, 436, 366, 281, 264, 11469, 295, 264, 2445, 13], "temperature": 0.0, "avg_logprob": -0.08962526945310219, "compression_ratio": 1.712, "no_speech_prob": 0.00014198398275766522}, {"id": 472, "seek": 331512, "start": 3328.12, "end": 3340.12, "text": " And so if some of them are very, very large, you sort of just zero out the connections to everything that's not being attended to that has low probability distribution, and then they don't get gradients.", "tokens": [400, 370, 498, 512, 295, 552, 366, 588, 11, 588, 2416, 11, 291, 1333, 295, 445, 4018, 484, 264, 9271, 281, 1203, 300, 311, 406, 885, 15990, 281, 300, 575, 2295, 8482, 7316, 11, 293, 550, 436, 500, 380, 483, 2771, 2448, 13], "temperature": 0.0, "avg_logprob": -0.08962526945310219, "compression_ratio": 1.712, "no_speech_prob": 0.00014198398275766522}, {"id": 473, "seek": 334012, "start": 3340.12, "end": 3340.12, "text": " And so here is the sil", "tokens": [400, 370, 510, 307, 264, 3425, 50272, 50358], "temperature": 0.0, "avg_logprob": -0.6230930884679159, "compression_ratio": 0.8367346938775511, "no_speech_prob": 0.00023775322188157588}, {"id": 474, "seek": 334012, "start": 3340.12, "end": 3340.12, "text": " And so here's the sil", "tokens": [400, 370, 510, 311, 264, 3425, 50272, 50358], "temperature": 0.6, "avg_logprob": -0.4766427186819223, "compression_ratio": 1.348993288590604, "no_speech_prob": 0.11492278426885605}, {"id": 475, "seek": 334012, "start": 3358.12, "end": 3364.12, "text": " And all I'm going to do is, well, the things that I'm going to dot together are vectors of dimensionality D over H, because of the multi-headed attention again.", "tokens": [400, 439, 286, 478, 516, 281, 360, 307, 11, 731, 11, 264, 721, 300, 286, 478, 516, 281, 5893, 1214, 366, 18875, 295, 10139, 1860, 413, 670, 389, 11, 570, 295, 264, 4825, 12, 28409, 3202, 797, 13], "temperature": 0.6, "avg_logprob": -0.4766427186819223, "compression_ratio": 1.348993288590604, "no_speech_prob": 0.11492278426885605}, {"id": 476, "seek": 336412, "start": 3364.12, "end": 3369.6, "text": " again. And in order to stop them from growing the doc products from growing too", "tokens": [797, 13, 400, 294, 1668, 281, 1590, 552, 490, 4194, 264, 3211, 3383, 490, 4194, 886], "temperature": 0.0, "avg_logprob": -0.27342794455733954, "compression_ratio": 1.7067307692307692, "no_speech_prob": 0.05910593271255493}, {"id": 477, "seek": 336412, "start": 3369.6, "end": 3378.7599999999998, "text": " large, I'm just going to divide all of my scores. So remember up here, xq, k top, x top is a t by", "tokens": [2416, 11, 286, 478, 445, 516, 281, 9845, 439, 295, 452, 13444, 13, 407, 1604, 493, 510, 11, 2031, 80, 11, 350, 1192, 11, 2031, 1192, 307, 257, 256, 538], "temperature": 0.0, "avg_logprob": -0.27342794455733954, "compression_ratio": 1.7067307692307692, "no_speech_prob": 0.05910593271255493}, {"id": 478, "seek": 336412, "start": 3378.7599999999998, "end": 3385.7999999999997, "text": " t matrix of scores. I'm going to divide them all by d over h. And as d grows, d over h grows,", "tokens": [256, 8141, 295, 13444, 13, 286, 478, 516, 281, 9845, 552, 439, 538, 274, 670, 276, 13, 400, 382, 274, 13156, 11, 274, 670, 276, 13156, 11], "temperature": 0.0, "avg_logprob": -0.27342794455733954, "compression_ratio": 1.7067307692307692, "no_speech_prob": 0.05910593271255493}, {"id": 479, "seek": 338580, "start": 3385.8, "end": 3398.88, "text": " right? And so your doc products don't grow and this ends up being helpful as well. Okay. Any", "tokens": [558, 30, 400, 370, 428, 3211, 3383, 500, 380, 1852, 293, 341, 5314, 493, 885, 4961, 382, 731, 13, 1033, 13, 2639], "temperature": 0.0, "avg_logprob": -0.3982189814249674, "compression_ratio": 1.0842105263157895, "no_speech_prob": 0.0012420465936884284}, {"id": 480, "seek": 338580, "start": 3398.88, "end": 3402.0, "text": " questions?", "tokens": [1651, 30], "temperature": 0.0, "avg_logprob": -0.3982189814249674, "compression_ratio": 1.0842105263157895, "no_speech_prob": 0.0012420465936884284}, {"id": 481, "seek": 340200, "start": 3402.0, "end": 3410.48, "text": " Yeah. John, could you go through interesting questions? When you're doing the decoder attention,", "tokens": [865, 13, 2619, 11, 727, 291, 352, 807, 1880, 1651, 30, 1133, 291, 434, 884, 264, 979, 19866, 3202, 11], "temperature": 0.0, "avg_logprob": -0.41822144644601006, "compression_ratio": 1.6545454545454545, "no_speech_prob": 0.0016474801814183593}, {"id": 482, "seek": 340200, "start": 3410.48, "end": 3416.64, "text": " do you only do the maximum in the first layer or do you do the maximum in the decoder?", "tokens": [360, 291, 787, 360, 264, 6674, 294, 264, 700, 4583, 420, 360, 291, 360, 264, 6674, 294, 264, 979, 19866, 30], "temperature": 0.0, "avg_logprob": -0.41822144644601006, "compression_ratio": 1.6545454545454545, "no_speech_prob": 0.0016474801814183593}, {"id": 483, "seek": 340200, "start": 3416.64, "end": 3427.88, "text": " Yeah, nice. So if we were to only do masking in the first layer, we would get information", "tokens": [865, 11, 1481, 13, 407, 498, 321, 645, 281, 787, 360, 31226, 294, 264, 700, 4583, 11, 321, 576, 483, 1589], "temperature": 0.0, "avg_logprob": -0.41822144644601006, "compression_ratio": 1.6545454545454545, "no_speech_prob": 0.0016474801814183593}, {"id": 484, "seek": 342788, "start": 3427.88, "end": 3438.92, "text": " leakage in the later layers. So if we look at this, if we were to look at this diagram again,", "tokens": [47799, 294, 264, 1780, 7914, 13, 407, 498, 321, 574, 412, 341, 11, 498, 321, 645, 281, 574, 412, 341, 10686, 797, 11], "temperature": 0.0, "avg_logprob": -0.12994590638175843, "compression_ratio": 1.896694214876033, "no_speech_prob": 0.00023046735441312194}, {"id": 485, "seek": 342788, "start": 3438.92, "end": 3443.28, "text": " right? So here's the first layer of the decoder. And we said that there's masking, right? And", "tokens": [558, 30, 407, 510, 311, 264, 700, 4583, 295, 264, 979, 19866, 13, 400, 321, 848, 300, 456, 311, 31226, 11, 558, 30, 400], "temperature": 0.0, "avg_logprob": -0.12994590638175843, "compression_ratio": 1.896694214876033, "no_speech_prob": 0.00023046735441312194}, {"id": 486, "seek": 342788, "start": 3443.28, "end": 3447.1600000000003, "text": " you're able to look at any of the encoder states and you're only able to look at the previous", "tokens": [291, 434, 1075, 281, 574, 412, 604, 295, 264, 2058, 19866, 4368, 293, 291, 434, 787, 1075, 281, 574, 412, 264, 3894], "temperature": 0.0, "avg_logprob": -0.12994590638175843, "compression_ratio": 1.896694214876033, "no_speech_prob": 0.00023046735441312194}, {"id": 487, "seek": 342788, "start": 3447.1600000000003, "end": 3452.44, "text": " words in the decoder. In the second layer, if I'm suddenly allowed to look at all of the", "tokens": [2283, 294, 264, 979, 19866, 13, 682, 264, 1150, 4583, 11, 498, 286, 478, 5800, 4350, 281, 574, 412, 439, 295, 264], "temperature": 0.0, "avg_logprob": -0.12994590638175843, "compression_ratio": 1.896694214876033, "no_speech_prob": 0.00023046735441312194}, {"id": 488, "seek": 342788, "start": 3452.44, "end": 3456.88, "text": " future words now, hey, even though I didn't in the first layer, it's just as good that I", "tokens": [2027, 2283, 586, 11, 4177, 11, 754, 1673, 286, 994, 380, 294, 264, 700, 4583, 11, 309, 311, 445, 382, 665, 300, 286], "temperature": 0.0, "avg_logprob": -0.12994590638175843, "compression_ratio": 1.896694214876033, "no_speech_prob": 0.00023046735441312194}, {"id": 489, "seek": 345688, "start": 3456.88, "end": 3461.08, "text": " can in the second layer. And so I can just learn to look right at what my word is supposed", "tokens": [393, 294, 264, 1150, 4583, 13, 400, 370, 286, 393, 445, 1466, 281, 574, 558, 412, 437, 452, 1349, 307, 3442], "temperature": 0.0, "avg_logprob": -0.16902881510117473, "compression_ratio": 1.4269005847953216, "no_speech_prob": 3.647517223726027e-05}, {"id": 490, "seek": 345688, "start": 3461.08, "end": 3466.6, "text": " to be. So every single layer of the decoder has to have that masking or it's sort of moot.", "tokens": [281, 312, 13, 407, 633, 2167, 4583, 295, 264, 979, 19866, 575, 281, 362, 300, 31226, 420, 309, 311, 1333, 295, 705, 310, 13], "temperature": 0.0, "avg_logprob": -0.16902881510117473, "compression_ratio": 1.4269005847953216, "no_speech_prob": 3.647517223726027e-05}, {"id": 491, "seek": 345688, "start": 3466.6, "end": 3475.08, "text": " Like it says if you didn't mask it at all effectively. Thanks.", "tokens": [1743, 309, 1619, 498, 291, 994, 380, 6094, 309, 412, 439, 8659, 13, 2561, 13], "temperature": 0.0, "avg_logprob": -0.16902881510117473, "compression_ratio": 1.4269005847953216, "no_speech_prob": 3.647517223726027e-05}, {"id": 492, "seek": 347508, "start": 3475.08, "end": 3490.7599999999998, "text": " Okay, so scaled dot product in the bag. We've got it. So let's look back at our full", "tokens": [1033, 11, 370, 36039, 5893, 1674, 294, 264, 3411, 13, 492, 600, 658, 309, 13, 407, 718, 311, 574, 646, 412, 527, 1577], "temperature": 0.0, "avg_logprob": -0.18383313607478488, "compression_ratio": 1.4855491329479769, "no_speech_prob": 6.013697202433832e-05}, {"id": 493, "seek": 347508, "start": 3490.7599999999998, "end": 3497.2, "text": " transformer encoder decoder framework. We've looked at the encoder blocks themselves.", "tokens": [31782, 2058, 19866, 979, 19866, 8388, 13, 492, 600, 2956, 412, 264, 2058, 19866, 8474, 2969, 13], "temperature": 0.0, "avg_logprob": -0.18383313607478488, "compression_ratio": 1.4855491329479769, "no_speech_prob": 6.013697202433832e-05}, {"id": 494, "seek": 347508, "start": 3497.2, "end": 3502.16, "text": " So let's sort of expand one of these zoom in enhance. And we've got our word embedding", "tokens": [407, 718, 311, 1333, 295, 5268, 472, 295, 613, 8863, 294, 11985, 13, 400, 321, 600, 658, 527, 1349, 12240, 3584], "temperature": 0.0, "avg_logprob": -0.18383313607478488, "compression_ratio": 1.4855491329479769, "no_speech_prob": 6.013697202433832e-05}, {"id": 495, "seek": 350216, "start": 3502.16, "end": 3507.6, "text": " position representations. And first we put it through a multi-headed attention. So we've", "tokens": [2535, 33358, 13, 400, 700, 321, 829, 309, 807, 257, 4825, 12, 28409, 3202, 13, 407, 321, 600], "temperature": 0.0, "avg_logprob": -0.20859684990447702, "compression_ratio": 1.9270386266094421, "no_speech_prob": 5.738317486247979e-05}, {"id": 496, "seek": 350216, "start": 3507.6, "end": 3514.16, "text": " seen that. We put it through a residual layer and layer norm. So, right? So you have the", "tokens": [1612, 300, 13, 492, 829, 309, 807, 257, 27980, 4583, 293, 4583, 2026, 13, 407, 11, 558, 30, 407, 291, 362, 264], "temperature": 0.0, "avg_logprob": -0.20859684990447702, "compression_ratio": 1.9270386266094421, "no_speech_prob": 5.738317486247979e-05}, {"id": 497, "seek": 350216, "start": 3514.16, "end": 3519.3199999999997, "text": " word embedding to the piston representations going through the residual connection here.", "tokens": [1349, 12240, 3584, 281, 264, 30002, 33358, 516, 807, 264, 27980, 4984, 510, 13], "temperature": 0.0, "avg_logprob": -0.20859684990447702, "compression_ratio": 1.9270386266094421, "no_speech_prob": 5.738317486247979e-05}, {"id": 498, "seek": 350216, "start": 3519.3199999999997, "end": 3525.24, "text": " And also going through multi-headed attention. Add them layer norm. Next, you put the result", "tokens": [400, 611, 516, 807, 4825, 12, 28409, 3202, 13, 5349, 552, 4583, 2026, 13, 3087, 11, 291, 829, 264, 1874], "temperature": 0.0, "avg_logprob": -0.20859684990447702, "compression_ratio": 1.9270386266094421, "no_speech_prob": 5.738317486247979e-05}, {"id": 499, "seek": 350216, "start": 3525.24, "end": 3530.3199999999997, "text": " of that through a feed forward network. There should be an error between the feed forward", "tokens": [295, 300, 807, 257, 3154, 2128, 3209, 13, 821, 820, 312, 364, 6713, 1296, 264, 3154, 2128], "temperature": 0.0, "avg_logprob": -0.20859684990447702, "compression_ratio": 1.9270386266094421, "no_speech_prob": 5.738317486247979e-05}, {"id": 500, "seek": 353032, "start": 3530.32, "end": 3536.1600000000003, "text": " and the next residual layer. But the output of this residual layer norm is added into that", "tokens": [293, 264, 958, 27980, 4583, 13, 583, 264, 5598, 295, 341, 27980, 4583, 2026, 307, 3869, 666, 300], "temperature": 0.0, "avg_logprob": -0.14017247236691988, "compression_ratio": 1.9777777777777779, "no_speech_prob": 1.4738140635017771e-05}, {"id": 501, "seek": 353032, "start": 3536.1600000000003, "end": 3540.84, "text": " residual in layer norm along with the output of the feed forward. And then the output of", "tokens": [27980, 294, 4583, 2026, 2051, 365, 264, 5598, 295, 264, 3154, 2128, 13, 400, 550, 264, 5598, 295], "temperature": 0.0, "avg_logprob": -0.14017247236691988, "compression_ratio": 1.9777777777777779, "no_speech_prob": 1.4738140635017771e-05}, {"id": 502, "seek": 353032, "start": 3540.84, "end": 3546.76, "text": " this residual in layer norm is the output of the transformer encoder block. So when we had", "tokens": [341, 27980, 294, 4583, 2026, 307, 264, 5598, 295, 264, 31782, 2058, 19866, 3461, 13, 407, 562, 321, 632], "temperature": 0.0, "avg_logprob": -0.14017247236691988, "compression_ratio": 1.9777777777777779, "no_speech_prob": 1.4738140635017771e-05}, {"id": 503, "seek": 353032, "start": 3546.76, "end": 3550.88, "text": " each of these encoders here internally each one of them was just this. And we've seen", "tokens": [1184, 295, 613, 2058, 378, 433, 510, 19501, 1184, 472, 295, 552, 390, 445, 341, 13, 400, 321, 600, 1612], "temperature": 0.0, "avg_logprob": -0.14017247236691988, "compression_ratio": 1.9777777777777779, "no_speech_prob": 1.4738140635017771e-05}, {"id": 504, "seek": 353032, "start": 3550.88, "end": 3558.2400000000002, "text": " all these building blocks before. And this is multi-headed scaled dot product attention.", "tokens": [439, 613, 2390, 8474, 949, 13, 400, 341, 307, 4825, 12, 28409, 36039, 5893, 1674, 3202, 13], "temperature": 0.0, "avg_logprob": -0.14017247236691988, "compression_ratio": 1.9777777777777779, "no_speech_prob": 1.4738140635017771e-05}, {"id": 505, "seek": 355824, "start": 3558.24, "end": 3564.9599999999996, "text": " I admit the scaled word. So this is the block. And notice interestingly how you're doing", "tokens": [286, 9796, 264, 36039, 1349, 13, 407, 341, 307, 264, 3461, 13, 400, 3449, 25873, 577, 291, 434, 884], "temperature": 0.0, "avg_logprob": -0.20317043166562734, "compression_ratio": 1.5454545454545454, "no_speech_prob": 1.9221308320993558e-05}, {"id": 506, "seek": 355824, "start": 3564.9599999999996, "end": 3572.9599999999996, "text": " residual layer norm after the initial multi-headed attention as well as after the feed forward.", "tokens": [27980, 4583, 2026, 934, 264, 5883, 4825, 12, 28409, 3202, 382, 731, 382, 934, 264, 3154, 2128, 13], "temperature": 0.0, "avg_logprob": -0.20317043166562734, "compression_ratio": 1.5454545454545454, "no_speech_prob": 1.9221308320993558e-05}, {"id": 507, "seek": 355824, "start": 3572.9599999999996, "end": 3577.72, "text": " So each one of these is just identical, right? Different parameters for the different", "tokens": [407, 1184, 472, 295, 613, 307, 445, 14800, 11, 558, 30, 20825, 9834, 337, 264, 819], "temperature": 0.0, "avg_logprob": -0.20317043166562734, "compression_ratio": 1.5454545454545454, "no_speech_prob": 1.9221308320993558e-05}, {"id": 508, "seek": 355824, "start": 3577.72, "end": 3583.16, "text": " layers. But the same things that we've seen. Now let's look at the transformer decoder", "tokens": [7914, 13, 583, 264, 912, 721, 300, 321, 600, 1612, 13, 823, 718, 311, 574, 412, 264, 31782, 979, 19866], "temperature": 0.0, "avg_logprob": -0.20317043166562734, "compression_ratio": 1.5454545454545454, "no_speech_prob": 1.9221308320993558e-05}, {"id": 509, "seek": 358316, "start": 3583.16, "end": 3590.48, "text": " block. So this is actually more complex. In particular you've got that masked multi-head", "tokens": [3461, 13, 407, 341, 307, 767, 544, 3997, 13, 682, 1729, 291, 600, 658, 300, 45249, 4825, 12, 1934], "temperature": 0.0, "avg_logprob": -0.15950023918821102, "compression_ratio": 1.788, "no_speech_prob": 4.264387462171726e-05}, {"id": 510, "seek": 358316, "start": 3590.48, "end": 3594.08, "text": " self-attention. And now remember this is not just for the first one. This is for all", "tokens": [2698, 12, 1591, 1251, 13, 400, 586, 1604, 341, 307, 406, 445, 337, 264, 700, 472, 13, 639, 307, 337, 439], "temperature": 0.0, "avg_logprob": -0.15950023918821102, "compression_ratio": 1.788, "no_speech_prob": 4.264387462171726e-05}, {"id": 511, "seek": 358316, "start": 3594.08, "end": 3597.3599999999997, "text": " of the transformer blocks. So you've got masked multi-headed self-attention where we can't", "tokens": [295, 264, 31782, 8474, 13, 407, 291, 600, 658, 45249, 4825, 12, 28409, 2698, 12, 1591, 1251, 689, 321, 393, 380], "temperature": 0.0, "avg_logprob": -0.15950023918821102, "compression_ratio": 1.788, "no_speech_prob": 4.264387462171726e-05}, {"id": 512, "seek": 358316, "start": 3597.3599999999997, "end": 3602.2, "text": " look at the future because we've added negative infinity to the negative infinity to the", "tokens": [574, 412, 264, 2027, 570, 321, 600, 3869, 3671, 13202, 281, 264, 3671, 13202, 281, 264], "temperature": 0.0, "avg_logprob": -0.15950023918821102, "compression_ratio": 1.788, "no_speech_prob": 4.264387462171726e-05}, {"id": 513, "seek": 358316, "start": 3602.2, "end": 3609.24, "text": " affinity scores. Residual in layer norm like we did for the encoder. Now we've got multi-head", "tokens": [2096, 11540, 13444, 13, 5015, 327, 901, 294, 4583, 2026, 411, 321, 630, 337, 264, 2058, 19866, 13, 823, 321, 600, 658, 4825, 12, 1934], "temperature": 0.0, "avg_logprob": -0.15950023918821102, "compression_ratio": 1.788, "no_speech_prob": 4.264387462171726e-05}, {"id": 514, "seek": 360924, "start": 3609.24, "end": 3613.7599999999998, "text": " cross-attention. So this connection to the transformer encoder. This is actually a lot", "tokens": [3278, 12, 1591, 1251, 13, 407, 341, 4984, 281, 264, 31782, 2058, 19866, 13, 639, 307, 767, 257, 688], "temperature": 0.0, "avg_logprob": -0.12821937393356156, "compression_ratio": 1.7658536585365854, "no_speech_prob": 7.141319656511769e-05}, {"id": 515, "seek": 360924, "start": 3613.7599999999998, "end": 3622.08, "text": " like what we saw in attention so far, right? We're attending from the decoder to the encoder.", "tokens": [411, 437, 321, 1866, 294, 3202, 370, 1400, 11, 558, 30, 492, 434, 15862, 490, 264, 979, 19866, 281, 264, 2058, 19866, 13], "temperature": 0.0, "avg_logprob": -0.12821937393356156, "compression_ratio": 1.7658536585365854, "no_speech_prob": 7.141319656511769e-05}, {"id": 516, "seek": 360924, "start": 3622.08, "end": 3627.12, "text": " So we actually in each transformer decoder block we've got two different attention functions", "tokens": [407, 321, 767, 294, 1184, 31782, 979, 19866, 3461, 321, 600, 658, 732, 819, 3202, 6828], "temperature": 0.0, "avg_logprob": -0.12821937393356156, "compression_ratio": 1.7658536585365854, "no_speech_prob": 7.141319656511769e-05}, {"id": 517, "seek": 360924, "start": 3627.12, "end": 3635.2, "text": " going on. So we do the cross-attention. We add the result to the residual in layer norm.", "tokens": [516, 322, 13, 407, 321, 360, 264, 3278, 12, 1591, 1251, 13, 492, 909, 264, 1874, 281, 264, 27980, 294, 4583, 2026, 13], "temperature": 0.0, "avg_logprob": -0.12821937393356156, "compression_ratio": 1.7658536585365854, "no_speech_prob": 7.141319656511769e-05}, {"id": 518, "seek": 363520, "start": 3635.2, "end": 3640.96, "text": " Two the next residual in layer norm along with that of the multi-head cross-attention.", "tokens": [4453, 264, 958, 27980, 294, 4583, 2026, 2051, 365, 300, 295, 264, 4825, 12, 1934, 3278, 12, 1591, 1251, 13], "temperature": 0.0, "avg_logprob": -0.20796719034209507, "compression_ratio": 2.1176470588235294, "no_speech_prob": 5.4754113079980016e-05}, {"id": 519, "seek": 363520, "start": 3640.96, "end": 3645.9199999999996, "text": " And only after both of those applications of attention. Next we do the feed forward", "tokens": [400, 787, 934, 1293, 295, 729, 5821, 295, 3202, 13, 3087, 321, 360, 264, 3154, 2128], "temperature": 0.0, "avg_logprob": -0.20796719034209507, "compression_ratio": 2.1176470588235294, "no_speech_prob": 5.4754113079980016e-05}, {"id": 520, "seek": 363520, "start": 3645.9199999999996, "end": 3652.52, "text": " and residual and layer norm where the residual is coming. So the xi minus 1 is the residual", "tokens": [293, 27980, 293, 4583, 2026, 689, 264, 27980, 307, 1348, 13, 407, 264, 2031, 72, 3175, 502, 307, 264, 27980], "temperature": 0.0, "avg_logprob": -0.20796719034209507, "compression_ratio": 2.1176470588235294, "no_speech_prob": 5.4754113079980016e-05}, {"id": 521, "seek": 363520, "start": 3652.52, "end": 3657.12, "text": " in layer norm here goes into this one along with the feed forward. And so you can think", "tokens": [294, 4583, 2026, 510, 1709, 666, 341, 472, 2051, 365, 264, 3154, 2128, 13, 400, 370, 291, 393, 519], "temperature": 0.0, "avg_logprob": -0.20796719034209507, "compression_ratio": 2.1176470588235294, "no_speech_prob": 5.4754113079980016e-05}, {"id": 522, "seek": 363520, "start": 3657.12, "end": 3660.4399999999996, "text": " of the residual in layer norm is coming after each of the interesting things we're doing.", "tokens": [295, 264, 27980, 294, 4583, 2026, 307, 1348, 934, 1184, 295, 264, 1880, 721, 321, 434, 884, 13], "temperature": 0.0, "avg_logprob": -0.20796719034209507, "compression_ratio": 2.1176470588235294, "no_speech_prob": 5.4754113079980016e-05}, {"id": 523, "seek": 363520, "start": 3660.4399999999996, "end": 3665.16, "text": " We're doing one interesting thing here. Multi-head masked self-attention. We've got cross-attention", "tokens": [492, 434, 884, 472, 1880, 551, 510, 13, 29238, 12, 1934, 45249, 2698, 12, 1591, 1251, 13, 492, 600, 658, 3278, 12, 1591, 1251], "temperature": 0.0, "avg_logprob": -0.20796719034209507, "compression_ratio": 2.1176470588235294, "no_speech_prob": 5.4754113079980016e-05}, {"id": 524, "seek": 366516, "start": 3665.16, "end": 3671.72, "text": " after each one. Do residual in layer norm. Help the gradients pass, et cetera, et cetera.", "tokens": [934, 1184, 472, 13, 1144, 27980, 294, 4583, 2026, 13, 10773, 264, 2771, 2448, 1320, 11, 1030, 11458, 11, 1030, 11458, 13], "temperature": 0.0, "avg_logprob": -0.14432246344430105, "compression_ratio": 1.6748466257668713, "no_speech_prob": 3.943554111174308e-05}, {"id": 525, "seek": 366516, "start": 3671.72, "end": 3676.3599999999997, "text": " And then the output of this residual in layer norm is the output of the transformer decoder.", "tokens": [400, 550, 264, 5598, 295, 341, 27980, 294, 4583, 2026, 307, 264, 5598, 295, 264, 31782, 979, 19866, 13], "temperature": 0.0, "avg_logprob": -0.14432246344430105, "compression_ratio": 1.6748466257668713, "no_speech_prob": 3.943554111174308e-05}, {"id": 526, "seek": 366516, "start": 3676.3599999999997, "end": 3682.68, "text": " And so the only thing so far that we really haven't seen in this lecture is the multi-head", "tokens": [400, 370, 264, 787, 551, 370, 1400, 300, 321, 534, 2378, 380, 1612, 294, 341, 7991, 307, 264, 4825, 12, 1934], "temperature": 0.0, "avg_logprob": -0.14432246344430105, "compression_ratio": 1.6748466257668713, "no_speech_prob": 3.943554111174308e-05}, {"id": 527, "seek": 368268, "start": 3682.68, "end": 3695.3199999999997, "text": " cross-attention. And I want to go over it. It is the same equations as the multi-headed", "tokens": [3278, 12, 1591, 1251, 13, 400, 286, 528, 281, 352, 670, 309, 13, 467, 307, 264, 912, 11787, 382, 264, 4825, 12, 28409], "temperature": 0.0, "avg_logprob": -0.17465047521905586, "compression_ratio": 1.6069651741293531, "no_speech_prob": 3.2188389013754204e-05}, {"id": 528, "seek": 368268, "start": 3695.3199999999997, "end": 3698.48, "text": " self-attention, but the inputs are coming from different places. And so I want to be", "tokens": [2698, 12, 1591, 1251, 11, 457, 264, 15743, 366, 1348, 490, 819, 3190, 13, 400, 370, 286, 528, 281, 312], "temperature": 0.0, "avg_logprob": -0.17465047521905586, "compression_ratio": 1.6069651741293531, "no_speech_prob": 3.2188389013754204e-05}, {"id": 529, "seek": 368268, "start": 3698.48, "end": 3704.56, "text": " precise about it. Let's take a look. Cross-attention details.", "tokens": [13600, 466, 309, 13, 961, 311, 747, 257, 574, 13, 11623, 12, 1591, 1251, 4365, 13], "temperature": 0.0, "avg_logprob": -0.17465047521905586, "compression_ratio": 1.6069651741293531, "no_speech_prob": 3.2188389013754204e-05}, {"id": 530, "seek": 368268, "start": 3704.56, "end": 3709.8599999999997, "text": " So right, self-attention recall is that when we're taking the keys, the queries, and the", "tokens": [407, 558, 11, 2698, 12, 1591, 1251, 9901, 307, 300, 562, 321, 434, 1940, 264, 9317, 11, 264, 24109, 11, 293, 264], "temperature": 0.0, "avg_logprob": -0.17465047521905586, "compression_ratio": 1.6069651741293531, "no_speech_prob": 3.2188389013754204e-05}, {"id": 531, "seek": 370986, "start": 3709.86, "end": 3716.04, "text": " values of attention from the same information source like the same sentence, for example.", "tokens": [4190, 295, 3202, 490, 264, 912, 1589, 4009, 411, 264, 912, 8174, 11, 337, 1365, 13], "temperature": 0.0, "avg_logprob": -0.1830611058643886, "compression_ratio": 1.7670682730923695, "no_speech_prob": 3.3210984838660806e-05}, {"id": 532, "seek": 370986, "start": 3716.04, "end": 3720.28, "text": " And we saw last week attention from the decoder to the encoder. So this is going to look", "tokens": [400, 321, 1866, 1036, 1243, 3202, 490, 264, 979, 19866, 281, 264, 2058, 19866, 13, 407, 341, 307, 516, 281, 574], "temperature": 0.0, "avg_logprob": -0.1830611058643886, "compression_ratio": 1.7670682730923695, "no_speech_prob": 3.3210984838660806e-05}, {"id": 533, "seek": 370986, "start": 3720.28, "end": 3725.84, "text": " similar. Let's use some different notation. So we're going to have h1 to ht, the output", "tokens": [2531, 13, 961, 311, 764, 512, 819, 24657, 13, 407, 321, 434, 516, 281, 362, 276, 16, 281, 276, 83, 11, 264, 5598], "temperature": 0.0, "avg_logprob": -0.1830611058643886, "compression_ratio": 1.7670682730923695, "no_speech_prob": 3.3210984838660806e-05}, {"id": 534, "seek": 370986, "start": 3725.84, "end": 3733.7000000000003, "text": " vectors from the transformer encoder, which are all x i and r d. Now remember, this is", "tokens": [18875, 490, 264, 31782, 2058, 19866, 11, 597, 366, 439, 2031, 741, 293, 367, 274, 13, 823, 1604, 11, 341, 307], "temperature": 0.0, "avg_logprob": -0.1830611058643886, "compression_ratio": 1.7670682730923695, "no_speech_prob": 3.3210984838660806e-05}, {"id": 535, "seek": 370986, "start": 3733.7000000000003, "end": 3739.48, "text": " the last transformer encoder here. You never attend to the middle encoder blocks. It's", "tokens": [264, 1036, 31782, 2058, 19866, 510, 13, 509, 1128, 6888, 281, 264, 2808, 2058, 19866, 8474, 13, 467, 311], "temperature": 0.0, "avg_logprob": -0.1830611058643886, "compression_ratio": 1.7670682730923695, "no_speech_prob": 3.3210984838660806e-05}, {"id": 536, "seek": 373948, "start": 3739.48, "end": 3743.8, "text": " the output of the last encoder block. So those are the output vectors from the last transformer", "tokens": [264, 5598, 295, 264, 1036, 2058, 19866, 3461, 13, 407, 729, 366, 264, 5598, 18875, 490, 264, 1036, 31782], "temperature": 0.0, "avg_logprob": -0.20725380195366158, "compression_ratio": 1.8333333333333333, "no_speech_prob": 3.591019776649773e-05}, {"id": 537, "seek": 373948, "start": 3743.8, "end": 3750.88, "text": " encoder block. And now we have z1 to zt, the input vectors from the transformer decoder.", "tokens": [2058, 19866, 3461, 13, 400, 586, 321, 362, 710, 16, 281, 710, 83, 11, 264, 4846, 18875, 490, 264, 31782, 979, 19866, 13], "temperature": 0.0, "avg_logprob": -0.20725380195366158, "compression_ratio": 1.8333333333333333, "no_speech_prob": 3.591019776649773e-05}, {"id": 538, "seek": 373948, "start": 3750.88, "end": 3756.72, "text": " So here maybe that is, you know, the input is the word embedding is plus the position", "tokens": [407, 510, 1310, 300, 307, 11, 291, 458, 11, 264, 4846, 307, 264, 1349, 12240, 3584, 307, 1804, 264, 2535], "temperature": 0.0, "avg_logprob": -0.20725380195366158, "compression_ratio": 1.8333333333333333, "no_speech_prob": 3.591019776649773e-05}, {"id": 539, "seek": 373948, "start": 3756.72, "end": 3762.04, "text": " of representations. Or, right, it's actually the output of the previous transformer decoder.", "tokens": [295, 33358, 13, 1610, 11, 558, 11, 309, 311, 767, 264, 5598, 295, 264, 3894, 31782, 979, 19866, 13], "temperature": 0.0, "avg_logprob": -0.20725380195366158, "compression_ratio": 1.8333333333333333, "no_speech_prob": 3.591019776649773e-05}, {"id": 540, "seek": 376204, "start": 3762.04, "end": 3769.88, "text": " We're going to be the inputs for the next one. So, yeah, we've got our z1 to zt. And we're", "tokens": [492, 434, 516, 281, 312, 264, 15743, 337, 264, 958, 472, 13, 407, 11, 1338, 11, 321, 600, 658, 527, 710, 16, 281, 710, 83, 13, 400, 321, 434], "temperature": 0.0, "avg_logprob": -0.256632080078125, "compression_ratio": 1.614678899082569, "no_speech_prob": 1.4969492440286558e-05}, {"id": 541, "seek": 376204, "start": 3769.88, "end": 3775.08, "text": " letting them be the same sequence like the nt and t, just for simplicity. These are also", "tokens": [8295, 552, 312, 264, 912, 8310, 411, 264, 297, 83, 293, 256, 11, 445, 337, 25632, 13, 1981, 366, 611], "temperature": 0.0, "avg_logprob": -0.256632080078125, "compression_ratio": 1.614678899082569, "no_speech_prob": 1.4969492440286558e-05}, {"id": 542, "seek": 376204, "start": 3775.08, "end": 3780.96, "text": " vectors z i and r d. And then the keys and the queries, sorry, the keys and the values", "tokens": [18875, 710, 741, 293, 367, 274, 13, 400, 550, 264, 9317, 293, 264, 24109, 11, 2597, 11, 264, 9317, 293, 264, 4190], "temperature": 0.0, "avg_logprob": -0.256632080078125, "compression_ratio": 1.614678899082569, "no_speech_prob": 1.4969492440286558e-05}, {"id": 543, "seek": 376204, "start": 3780.96, "end": 3788.08, "text": " are all drawn from the encoder. So when we're talking about attention, as allowing us", "tokens": [366, 439, 10117, 490, 264, 2058, 19866, 13, 407, 562, 321, 434, 1417, 466, 3202, 11, 382, 8293, 505], "temperature": 0.0, "avg_logprob": -0.256632080078125, "compression_ratio": 1.614678899082569, "no_speech_prob": 1.4969492440286558e-05}, {"id": 544, "seek": 378808, "start": 3788.08, "end": 3795.52, "text": " to sort of access a memory, right, the memory is sort of what the value vectors are encoding.", "tokens": [281, 1333, 295, 2105, 257, 4675, 11, 558, 11, 264, 4675, 307, 1333, 295, 437, 264, 2158, 18875, 366, 43430, 13], "temperature": 0.0, "avg_logprob": -0.1442637684369328, "compression_ratio": 1.8514851485148516, "no_speech_prob": 2.178041177103296e-05}, {"id": 545, "seek": 378808, "start": 3795.52, "end": 3802.2, "text": " And the way that the values are sort of indexed or able to be accessed is through the keys.", "tokens": [400, 264, 636, 300, 264, 4190, 366, 1333, 295, 8186, 292, 420, 1075, 281, 312, 34211, 307, 807, 264, 9317, 13], "temperature": 0.0, "avg_logprob": -0.1442637684369328, "compression_ratio": 1.8514851485148516, "no_speech_prob": 2.178041177103296e-05}, {"id": 546, "seek": 378808, "start": 3802.2, "end": 3808.08, "text": " And then the queries are, you know, what you're, what you're using to try to look for something.", "tokens": [400, 550, 264, 24109, 366, 11, 291, 458, 11, 437, 291, 434, 11, 437, 291, 434, 1228, 281, 853, 281, 574, 337, 746, 13], "temperature": 0.0, "avg_logprob": -0.1442637684369328, "compression_ratio": 1.8514851485148516, "no_speech_prob": 2.178041177103296e-05}, {"id": 547, "seek": 378808, "start": 3808.08, "end": 3812.88, "text": " Right, so we're looking into the encoder as a memory. And we're using keys from the decoder", "tokens": [1779, 11, 370, 321, 434, 1237, 666, 264, 2058, 19866, 382, 257, 4675, 13, 400, 321, 434, 1228, 9317, 490, 264, 979, 19866], "temperature": 0.0, "avg_logprob": -0.1442637684369328, "compression_ratio": 1.8514851485148516, "no_speech_prob": 2.178041177103296e-05}, {"id": 548, "seek": 381288, "start": 3812.88, "end": 3819.7200000000003, "text": " to figure out where to look for each one. So, pictorially, again, we can look at how", "tokens": [281, 2573, 484, 689, 281, 574, 337, 1184, 472, 13, 407, 11, 2317, 284, 2270, 11, 797, 11, 321, 393, 574, 412, 577], "temperature": 0.0, "avg_logprob": -0.135185791015625, "compression_ratio": 1.7171314741035857, "no_speech_prob": 2.282636341988109e-05}, {"id": 549, "seek": 381288, "start": 3819.7200000000003, "end": 3823.96, "text": " cross-attention is computed in matrices like we did for self-attention. So we've got", "tokens": [3278, 12, 1591, 1251, 307, 40610, 294, 32284, 411, 321, 630, 337, 2698, 12, 1591, 1251, 13, 407, 321, 600, 658], "temperature": 0.0, "avg_logprob": -0.135185791015625, "compression_ratio": 1.7171314741035857, "no_speech_prob": 2.282636341988109e-05}, {"id": 550, "seek": 381288, "start": 3823.96, "end": 3829.0, "text": " the same thing here before we had x. Now we have h. These are the encoder vectors. These", "tokens": [264, 912, 551, 510, 949, 321, 632, 2031, 13, 823, 321, 362, 276, 13, 1981, 366, 264, 2058, 19866, 18875, 13, 1981], "temperature": 0.0, "avg_logprob": -0.135185791015625, "compression_ratio": 1.7171314741035857, "no_speech_prob": 2.282636341988109e-05}, {"id": 551, "seek": 381288, "start": 3829.0, "end": 3835.6, "text": " are going to be rt by d. Likewise, we have z. Notice we have two of these before. Before", "tokens": [366, 516, 281, 312, 367, 83, 538, 274, 13, 30269, 11, 321, 362, 710, 13, 13428, 321, 362, 732, 295, 613, 949, 13, 4546], "temperature": 0.0, "avg_logprob": -0.135185791015625, "compression_ratio": 1.7171314741035857, "no_speech_prob": 2.282636341988109e-05}, {"id": 552, "seek": 381288, "start": 3835.6, "end": 3839.76, "text": " we just had x, right, we had x because x was going to be for the keys, the queries,", "tokens": [321, 445, 632, 2031, 11, 558, 11, 321, 632, 2031, 570, 2031, 390, 516, 281, 312, 337, 264, 9317, 11, 264, 24109, 11], "temperature": 0.0, "avg_logprob": -0.135185791015625, "compression_ratio": 1.7171314741035857, "no_speech_prob": 2.282636341988109e-05}, {"id": 553, "seek": 383976, "start": 3839.76, "end": 3847.8, "text": " and the values. Now we have h and z. Both are in rt by d. And the output is going to be,", "tokens": [293, 264, 4190, 13, 823, 321, 362, 276, 293, 710, 13, 6767, 366, 294, 367, 83, 538, 274, 13, 400, 264, 5598, 307, 516, 281, 312, 11], "temperature": 0.0, "avg_logprob": -0.20051074264073135, "compression_ratio": 1.703883495145631, "no_speech_prob": 1.7229836885235272e-05}, {"id": 554, "seek": 383976, "start": 3847.8, "end": 3854.2000000000003, "text": " well, you take your z for the queries, right, z is being multiplied by the queries. You", "tokens": [731, 11, 291, 747, 428, 710, 337, 264, 24109, 11, 558, 11, 710, 307, 885, 17207, 538, 264, 24109, 13, 509], "temperature": 0.0, "avg_logprob": -0.20051074264073135, "compression_ratio": 1.703883495145631, "no_speech_prob": 1.7229836885235272e-05}, {"id": 555, "seek": 383976, "start": 3854.2000000000003, "end": 3861.92, "text": " take your h for the keys and your h for the v's. So you are trying to take the query,", "tokens": [747, 428, 276, 337, 264, 9317, 293, 428, 276, 337, 264, 371, 311, 13, 407, 291, 366, 1382, 281, 747, 264, 14581, 11], "temperature": 0.0, "avg_logprob": -0.20051074264073135, "compression_ratio": 1.703883495145631, "no_speech_prob": 1.7229836885235272e-05}, {"id": 556, "seek": 383976, "start": 3861.92, "end": 3866.88, "text": " the query, key dot products, all t squared of them, in one matrix multiplication. So the", "tokens": [264, 14581, 11, 2141, 5893, 3383, 11, 439, 256, 8889, 295, 552, 11, 294, 472, 8141, 27290, 13, 407, 264], "temperature": 0.0, "avg_logprob": -0.20051074264073135, "compression_ratio": 1.703883495145631, "no_speech_prob": 1.7229836885235272e-05}, {"id": 557, "seek": 386688, "start": 3866.88, "end": 3874.0, "text": " purple is saying this is coming from the d-coder. The brown is saying, or is saying it's", "tokens": [9656, 307, 1566, 341, 307, 1348, 490, 264, 274, 12, 66, 19866, 13, 440, 6292, 307, 1566, 11, 420, 307, 1566, 309, 311], "temperature": 0.0, "avg_logprob": -0.1647898998666317, "compression_ratio": 1.7414634146341463, "no_speech_prob": 5.474745557876304e-05}, {"id": 558, "seek": 386688, "start": 3874.0, "end": 3881.6800000000003, "text": " coming from the encoder. Now you've got your dot products, softmax them as you did before,", "tokens": [1348, 490, 264, 2058, 19866, 13, 823, 291, 600, 658, 428, 5893, 3383, 11, 2787, 41167, 552, 382, 291, 630, 949, 11], "temperature": 0.0, "avg_logprob": -0.1647898998666317, "compression_ratio": 1.7414634146341463, "no_speech_prob": 5.474745557876304e-05}, {"id": 559, "seek": 386688, "start": 3881.6800000000003, "end": 3887.6400000000003, "text": " and now your values are also coming from the encoder. So, again, same operation, different", "tokens": [293, 586, 428, 4190, 366, 611, 1348, 490, 264, 2058, 19866, 13, 407, 11, 797, 11, 912, 6916, 11, 819], "temperature": 0.0, "avg_logprob": -0.1647898998666317, "compression_ratio": 1.7414634146341463, "no_speech_prob": 5.474745557876304e-05}, {"id": 560, "seek": 386688, "start": 3887.6400000000003, "end": 3892.96, "text": " sources for the inputs. And now you've got your output, which again is just an average", "tokens": [7139, 337, 264, 15743, 13, 400, 586, 291, 600, 658, 428, 5598, 11, 597, 797, 307, 445, 364, 4274], "temperature": 0.0, "avg_logprob": -0.1647898998666317, "compression_ratio": 1.7414634146341463, "no_speech_prob": 5.474745557876304e-05}, {"id": 561, "seek": 389296, "start": 3892.96, "end": 3902.36, "text": " of the value vectors from the encoder hv, the average is determined by your weights.", "tokens": [295, 264, 2158, 18875, 490, 264, 2058, 19866, 276, 85, 11, 264, 4274, 307, 9540, 538, 428, 17443, 13], "temperature": 0.0, "avg_logprob": -0.2905817609844786, "compression_ratio": 1.463276836158192, "no_speech_prob": 4.005859955213964e-05}, {"id": 562, "seek": 389296, "start": 3902.36, "end": 3912.56, "text": " Okay, so results with transformers. First off was machine translation. So we built our", "tokens": [1033, 11, 370, 3542, 365, 4088, 433, 13, 2386, 766, 390, 3479, 12853, 13, 407, 321, 3094, 527], "temperature": 0.0, "avg_logprob": -0.2905817609844786, "compression_ratio": 1.463276836158192, "no_speech_prob": 4.005859955213964e-05}, {"id": 563, "seek": 389296, "start": 3912.56, "end": 3918.88, "text": " entire encoder, decoder, transformer block, and how does it work? It works really well.", "tokens": [2302, 2058, 19866, 11, 979, 19866, 11, 31782, 3461, 11, 293, 577, 775, 309, 589, 30, 467, 1985, 534, 731, 13], "temperature": 0.0, "avg_logprob": -0.2905817609844786, "compression_ratio": 1.463276836158192, "no_speech_prob": 4.005859955213964e-05}, {"id": 564, "seek": 391888, "start": 3918.88, "end": 3923.56, "text": " So these are a bunch of machine translation systems that were out when the original attention", "tokens": [407, 613, 366, 257, 3840, 295, 3479, 12853, 3652, 300, 645, 484, 562, 264, 3380, 3202], "temperature": 0.0, "avg_logprob": -0.15504293343455522, "compression_ratio": 1.7244094488188977, "no_speech_prob": 9.913490794133395e-05}, {"id": 565, "seek": 391888, "start": 3923.56, "end": 3929.2400000000002, "text": " is all you need, transformers paper came out. And first, you saw that transformers were", "tokens": [307, 439, 291, 643, 11, 4088, 433, 3035, 1361, 484, 13, 400, 700, 11, 291, 1866, 300, 4088, 433, 645], "temperature": 0.0, "avg_logprob": -0.15504293343455522, "compression_ratio": 1.7244094488188977, "no_speech_prob": 9.913490794133395e-05}, {"id": 566, "seek": 391888, "start": 3929.2400000000002, "end": 3933.04, "text": " getting really good blue scores. So this is on the workshop on machine translation", "tokens": [1242, 534, 665, 3344, 13444, 13, 407, 341, 307, 322, 264, 13541, 322, 3479, 12853], "temperature": 0.0, "avg_logprob": -0.15504293343455522, "compression_ratio": 1.7244094488188977, "no_speech_prob": 9.913490794133395e-05}, {"id": 567, "seek": 391888, "start": 3933.04, "end": 3940.82, "text": " 2014, English German and English French test sets. You get higher blue scores, which", "tokens": [8227, 11, 3669, 6521, 293, 3669, 5522, 1500, 6352, 13, 509, 483, 2946, 3344, 13444, 11, 597], "temperature": 0.0, "avg_logprob": -0.15504293343455522, "compression_ratio": 1.7244094488188977, "no_speech_prob": 9.913490794133395e-05}, {"id": 568, "seek": 391888, "start": 3940.82, "end": 3944.36, "text": " means better translations, right? Notice how our blue scores in this are higher than for", "tokens": [1355, 1101, 37578, 11, 558, 30, 13428, 577, 527, 3344, 13444, 294, 341, 366, 2946, 813, 337], "temperature": 0.0, "avg_logprob": -0.15504293343455522, "compression_ratio": 1.7244094488188977, "no_speech_prob": 9.913490794133395e-05}, {"id": 569, "seek": 394436, "start": 3944.36, "end": 3949.32, "text": " assignment four, lots more training data here, for example. But then also not only do", "tokens": [15187, 1451, 11, 3195, 544, 3097, 1412, 510, 11, 337, 1365, 13, 583, 550, 611, 406, 787, 360], "temperature": 0.0, "avg_logprob": -0.16649811484596946, "compression_ratio": 1.6934865900383143, "no_speech_prob": 0.00012726405111607164}, {"id": 570, "seek": 394436, "start": 3949.32, "end": 3955.52, "text": " you get better blue scores, you also had more efficient training, right? And we had", "tokens": [291, 483, 1101, 3344, 13444, 11, 291, 611, 632, 544, 7148, 3097, 11, 558, 30, 400, 321, 632], "temperature": 0.0, "avg_logprob": -0.16649811484596946, "compression_ratio": 1.6934865900383143, "no_speech_prob": 0.00012726405111607164}, {"id": 571, "seek": 394436, "start": 3955.52, "end": 3959.36, "text": " a lot of tricks that went into getting training to work better, right? So you have more efficient", "tokens": [257, 688, 295, 11733, 300, 1437, 666, 1242, 3097, 281, 589, 1101, 11, 558, 30, 407, 291, 362, 544, 7148], "temperature": 0.0, "avg_logprob": -0.16649811484596946, "compression_ratio": 1.6934865900383143, "no_speech_prob": 0.00012726405111607164}, {"id": 572, "seek": 394436, "start": 3959.36, "end": 3965.8, "text": " training here. Okay, so that's a nice result. That was in the original paper. You know,", "tokens": [3097, 510, 13, 1033, 11, 370, 300, 311, 257, 1481, 1874, 13, 663, 390, 294, 264, 3380, 3035, 13, 509, 458, 11], "temperature": 0.0, "avg_logprob": -0.16649811484596946, "compression_ratio": 1.6934865900383143, "no_speech_prob": 0.00012726405111607164}, {"id": 573, "seek": 394436, "start": 3965.8, "end": 3971.52, "text": " past that, there are a number of interesting results. Summarization is one of them. So", "tokens": [1791, 300, 11, 456, 366, 257, 1230, 295, 1880, 3542, 13, 8626, 6209, 2144, 307, 472, 295, 552, 13, 407], "temperature": 0.0, "avg_logprob": -0.16649811484596946, "compression_ratio": 1.6934865900383143, "no_speech_prob": 0.00012726405111607164}, {"id": 574, "seek": 397152, "start": 3971.52, "end": 3976.64, "text": " because here's the result on summarization. These are sort of part of a larger summarization", "tokens": [570, 510, 311, 264, 1874, 322, 14611, 2144, 13, 1981, 366, 1333, 295, 644, 295, 257, 4833, 14611, 2144], "temperature": 0.0, "avg_logprob": -0.22799671560093976, "compression_ratio": 1.8299319727891157, "no_speech_prob": 5.474710633279756e-05}, {"id": 575, "seek": 397152, "start": 3976.64, "end": 3980.2, "text": " system. But you know, you have, I like this table because you have sort of seek to seek", "tokens": [1185, 13, 583, 291, 458, 11, 291, 362, 11, 286, 411, 341, 3199, 570, 291, 362, 1333, 295, 8075, 281, 8075], "temperature": 0.0, "avg_logprob": -0.22799671560093976, "compression_ratio": 1.8299319727891157, "no_speech_prob": 5.474710633279756e-05}, {"id": 576, "seek": 397152, "start": 3980.2, "end": 3985.08, "text": " with attention, which we saw before. And it got perplexity lower, it's better with perplexity,", "tokens": [365, 3202, 11, 597, 321, 1866, 949, 13, 400, 309, 658, 680, 18945, 507, 3126, 11, 309, 311, 1101, 365, 680, 18945, 507, 11], "temperature": 0.0, "avg_logprob": -0.22799671560093976, "compression_ratio": 1.8299319727891157, "no_speech_prob": 5.474710633279756e-05}, {"id": 577, "seek": 397152, "start": 3985.08, "end": 3991.88, "text": " higher is better with rouge on this wiki sum data set. And then sort of like a bunch of", "tokens": [2946, 307, 1101, 365, 40605, 322, 341, 261, 9850, 2408, 1412, 992, 13, 400, 550, 1333, 295, 411, 257, 3840, 295], "temperature": 0.0, "avg_logprob": -0.22799671560093976, "compression_ratio": 1.8299319727891157, "no_speech_prob": 5.474710633279756e-05}, {"id": 578, "seek": 397152, "start": 3991.88, "end": 3996.0, "text": " transformer models they tried. And sort of at a certain point it becomes transformers", "tokens": [31782, 5245, 436, 3031, 13, 400, 1333, 295, 412, 257, 1629, 935, 309, 3643, 4088, 433], "temperature": 0.0, "avg_logprob": -0.22799671560093976, "compression_ratio": 1.8299319727891157, "no_speech_prob": 5.474710633279756e-05}, {"id": 579, "seek": 397152, "start": 3996.0, "end": 4001.44, "text": " all the way down. And sort of the old standard of R&N sort of falls out of practice. And", "tokens": [439, 264, 636, 760, 13, 400, 1333, 295, 264, 1331, 3832, 295, 497, 5, 45, 1333, 295, 8804, 484, 295, 3124, 13, 400], "temperature": 0.0, "avg_logprob": -0.22799671560093976, "compression_ratio": 1.8299319727891157, "no_speech_prob": 5.474710633279756e-05}, {"id": 580, "seek": 400144, "start": 4001.44, "end": 4005.6, "text": " actually before too long, right, transformers became dominant for an entirely different", "tokens": [767, 949, 886, 938, 11, 558, 11, 4088, 433, 3062, 15657, 337, 364, 7696, 819], "temperature": 0.0, "avg_logprob": -0.17006487165178572, "compression_ratio": 1.6457564575645756, "no_speech_prob": 5.306071034283377e-05}, {"id": 581, "seek": 400144, "start": 4005.6, "end": 4010.08, "text": " reason, which was related more to their parallelizability. Because they're allowed you to", "tokens": [1778, 11, 597, 390, 4077, 544, 281, 641, 8952, 590, 2310, 13, 1436, 436, 434, 4350, 291, 281], "temperature": 0.0, "avg_logprob": -0.17006487165178572, "compression_ratio": 1.6457564575645756, "no_speech_prob": 5.306071034283377e-05}, {"id": 582, "seek": 400144, "start": 4010.08, "end": 4017.92, "text": " pre-train on just a ton of data very quickly. And this has made them the de facto standard.", "tokens": [659, 12, 83, 7146, 322, 445, 257, 2952, 295, 1412, 588, 2661, 13, 400, 341, 575, 1027, 552, 264, 368, 42225, 3832, 13], "temperature": 0.0, "avg_logprob": -0.17006487165178572, "compression_ratio": 1.6457564575645756, "no_speech_prob": 5.306071034283377e-05}, {"id": 583, "seek": 400144, "start": 4017.92, "end": 4022.7200000000003, "text": " So there's a lot of results recently with transformers include pre-training. And I'm sort", "tokens": [407, 456, 311, 257, 688, 295, 3542, 3938, 365, 4088, 433, 4090, 659, 12, 17227, 1760, 13, 400, 286, 478, 1333], "temperature": 0.0, "avg_logprob": -0.17006487165178572, "compression_ratio": 1.6457564575645756, "no_speech_prob": 5.306071034283377e-05}, {"id": 584, "seek": 400144, "start": 4022.7200000000003, "end": 4026.48, "text": " of intentionally sort of excluding them from this lecture so that you come to the next", "tokens": [295, 22062, 1333, 295, 49999, 552, 490, 341, 7991, 370, 300, 291, 808, 281, 264, 958], "temperature": 0.0, "avg_logprob": -0.17006487165178572, "compression_ratio": 1.6457564575645756, "no_speech_prob": 5.306071034283377e-05}, {"id": 585, "seek": 402648, "start": 4026.48, "end": 4031.72, "text": " lecture and learn about pre-training. But there's a popular aggregate benchmark. This took", "tokens": [7991, 293, 1466, 466, 659, 12, 17227, 1760, 13, 583, 456, 311, 257, 3743, 26118, 18927, 13, 639, 1890], "temperature": 0.0, "avg_logprob": -0.1744812745314378, "compression_ratio": 1.7225806451612904, "no_speech_prob": 2.1108433429617435e-05}, {"id": 586, "seek": 402648, "start": 4031.72, "end": 4035.92, "text": " a bunch of very difficult tasks and said, you know, do well on all of them if you want", "tokens": [257, 3840, 295, 588, 2252, 9608, 293, 848, 11, 291, 458, 11, 360, 731, 322, 439, 295, 552, 498, 291, 528], "temperature": 0.0, "avg_logprob": -0.1744812745314378, "compression_ratio": 1.7225806451612904, "no_speech_prob": 2.1108433429617435e-05}, {"id": 587, "seek": 402648, "start": 4035.92, "end": 4039.96, "text": " to score highly on our leaderboard. And you know, the names of these models you can look", "tokens": [281, 6175, 5405, 322, 527, 5263, 3787, 13, 400, 291, 458, 11, 264, 5288, 295, 613, 5245, 291, 393, 574], "temperature": 0.0, "avg_logprob": -0.1744812745314378, "compression_ratio": 1.7225806451612904, "no_speech_prob": 2.1108433429617435e-05}, {"id": 588, "seek": 402648, "start": 4039.96, "end": 4043.76, "text": " up if you're interested, but all of them are transformer based after a certain point.", "tokens": [493, 498, 291, 434, 3102, 11, 457, 439, 295, 552, 366, 31782, 2361, 934, 257, 1629, 935, 13], "temperature": 0.0, "avg_logprob": -0.1744812745314378, "compression_ratio": 1.7225806451612904, "no_speech_prob": 2.1108433429617435e-05}, {"id": 589, "seek": 402648, "start": 4043.76, "end": 4049.16, "text": " The benchmarks call it glue. It has a successor called super glue. Everything is just transformers", "tokens": [440, 43751, 818, 309, 8998, 13, 467, 575, 257, 31864, 1219, 1687, 8998, 13, 5471, 307, 445, 4088, 433], "temperature": 0.0, "avg_logprob": -0.1744812745314378, "compression_ratio": 1.7225806451612904, "no_speech_prob": 2.1108433429617435e-05}, {"id": 590, "seek": 402648, "start": 4049.16, "end": 4056.04, "text": " after a certain sort of time period. Partly because of their pre-training ability.", "tokens": [934, 257, 1629, 1333, 295, 565, 2896, 13, 4100, 356, 570, 295, 641, 659, 12, 17227, 1760, 3485, 13], "temperature": 0.0, "avg_logprob": -0.1744812745314378, "compression_ratio": 1.7225806451612904, "no_speech_prob": 2.1108433429617435e-05}, {"id": 591, "seek": 405604, "start": 4056.04, "end": 4067.6, "text": " Okay. Great. So we'll discuss pre-training more on Thursday. And so our transformers", "tokens": [1033, 13, 3769, 13, 407, 321, 603, 2248, 659, 12, 17227, 1760, 544, 322, 10383, 13, 400, 370, 527, 4088, 433], "temperature": 0.0, "avg_logprob": -0.1850643365279488, "compression_ratio": 1.5462555066079295, "no_speech_prob": 0.00012143061758251861}, {"id": 592, "seek": 405604, "start": 4067.6, "end": 4073.52, "text": " it. Like the way that we described the attention is all you need paper. So the transformer", "tokens": [309, 13, 1743, 264, 636, 300, 321, 7619, 264, 3202, 307, 439, 291, 643, 3035, 13, 407, 264, 31782], "temperature": 0.0, "avg_logprob": -0.1850643365279488, "compression_ratio": 1.5462555066079295, "no_speech_prob": 0.00012143061758251861}, {"id": 593, "seek": 405604, "start": 4073.52, "end": 4080.64, "text": " encoder to coder we saw was from that paper. And at some point, you know, we want to", "tokens": [2058, 19866, 281, 17656, 260, 321, 1866, 390, 490, 300, 3035, 13, 400, 412, 512, 935, 11, 291, 458, 11, 321, 528, 281], "temperature": 0.0, "avg_logprob": -0.1850643365279488, "compression_ratio": 1.5462555066079295, "no_speech_prob": 0.00012143061758251861}, {"id": 594, "seek": 405604, "start": 4080.64, "end": 4083.96, "text": " build new systems. What are some drawbacks? And we've already started. People have already", "tokens": [1322, 777, 3652, 13, 708, 366, 512, 2642, 17758, 30, 400, 321, 600, 1217, 1409, 13, 3432, 362, 1217], "temperature": 0.0, "avg_logprob": -0.1850643365279488, "compression_ratio": 1.5462555066079295, "no_speech_prob": 0.00012143061758251861}, {"id": 595, "seek": 408396, "start": 4083.96, "end": 4088.7200000000003, "text": " started to build variants of transformers that will go into today. And you know, it definitely", "tokens": [1409, 281, 1322, 21669, 295, 4088, 433, 300, 486, 352, 666, 965, 13, 400, 291, 458, 11, 309, 2138], "temperature": 0.0, "avg_logprob": -0.21304583549499512, "compression_ratio": 1.5964912280701755, "no_speech_prob": 0.00011582542356336489}, {"id": 596, "seek": 408396, "start": 4088.7200000000003, "end": 4096.04, "text": " has issues that we can try to work on. So I can also take a question if anyone wants to", "tokens": [575, 2663, 300, 321, 393, 853, 281, 589, 322, 13, 407, 286, 393, 611, 747, 257, 1168, 498, 2878, 2738, 281], "temperature": 0.0, "avg_logprob": -0.21304583549499512, "compression_ratio": 1.5964912280701755, "no_speech_prob": 0.00011582542356336489}, {"id": 597, "seek": 408396, "start": 4096.04, "end": 4104.24, "text": " ask one. I mean, is that a bit that something that there were several questions on was the", "tokens": [1029, 472, 13, 286, 914, 11, 307, 300, 257, 857, 300, 746, 300, 456, 645, 2940, 1651, 322, 390, 264], "temperature": 0.0, "avg_logprob": -0.21304583549499512, "compression_ratio": 1.5964912280701755, "no_speech_prob": 0.00011582542356336489}, {"id": 598, "seek": 408396, "start": 4104.24, "end": 4113.24, "text": " scale dot product? And the questions included why square root of d divided by h as opposed", "tokens": [4373, 5893, 1674, 30, 400, 264, 1651, 5556, 983, 3732, 5593, 295, 274, 6666, 538, 276, 382, 8851], "temperature": 0.0, "avg_logprob": -0.21304583549499512, "compression_ratio": 1.5964912280701755, "no_speech_prob": 0.00011582542356336489}, {"id": 599, "seek": 411324, "start": 4113.24, "end": 4126.12, "text": " to just d divided by h or any other function of d divided by h. And another one was that", "tokens": [281, 445, 274, 6666, 538, 276, 420, 604, 661, 2445, 295, 274, 6666, 538, 276, 13, 400, 1071, 472, 390, 300], "temperature": 0.0, "avg_logprob": -0.26753823897417855, "compression_ratio": 1.5384615384615385, "no_speech_prob": 1.5444738892256282e-05}, {"id": 600, "seek": 411324, "start": 4126.12, "end": 4133.719999999999, "text": " why do you need that at all given that later on? You're going to use lay and all.", "tokens": [983, 360, 291, 643, 300, 412, 439, 2212, 300, 1780, 322, 30, 509, 434, 516, 281, 764, 2360, 293, 439, 13], "temperature": 0.0, "avg_logprob": -0.26753823897417855, "compression_ratio": 1.5384615384615385, "no_speech_prob": 1.5444738892256282e-05}, {"id": 601, "seek": 411324, "start": 4133.719999999999, "end": 4139.36, "text": " The second question is really interesting and not one that I had thought of before. Well,", "tokens": [440, 1150, 1168, 307, 534, 1880, 293, 406, 472, 300, 286, 632, 1194, 295, 949, 13, 1042, 11], "temperature": 0.0, "avg_logprob": -0.26753823897417855, "compression_ratio": 1.5384615384615385, "no_speech_prob": 1.5444738892256282e-05}, {"id": 602, "seek": 413936, "start": 4139.36, "end": 4144.5599999999995, "text": " right. So even if the individual components are small, so let's start with the second", "tokens": [558, 13, 407, 754, 498, 264, 2609, 6677, 366, 1359, 11, 370, 718, 311, 722, 365, 264, 1150], "temperature": 0.0, "avg_logprob": -0.20905674205106847, "compression_ratio": 1.5810810810810811, "no_speech_prob": 8.09173725428991e-05}, {"id": 603, "seek": 413936, "start": 4144.5599999999995, "end": 4149.5199999999995, "text": " question. Why does this matter even if you're going to use layer norm? You know, if layer", "tokens": [1168, 13, 1545, 775, 341, 1871, 754, 498, 291, 434, 516, 281, 764, 4583, 2026, 30, 509, 458, 11, 498, 4583], "temperature": 0.0, "avg_logprob": -0.20905674205106847, "compression_ratio": 1.5810810810810811, "no_speech_prob": 8.09173725428991e-05}, {"id": 604, "seek": 413936, "start": 4149.5199999999995, "end": 4155.88, "text": " norm is averaging everything out, say, making it unit standard deviation and mean, then", "tokens": [2026, 307, 47308, 1203, 484, 11, 584, 11, 1455, 309, 4985, 3832, 25163, 293, 914, 11, 550], "temperature": 0.0, "avg_logprob": -0.20905674205106847, "compression_ratio": 1.5810810810810811, "no_speech_prob": 8.09173725428991e-05}, {"id": 605, "seek": 413936, "start": 4155.88, "end": 4159.96, "text": " actually, right, nothing is going to get too small in those vectors either. So when you", "tokens": [767, 11, 558, 11, 1825, 307, 516, 281, 483, 886, 1359, 294, 729, 18875, 2139, 13, 407, 562, 291], "temperature": 0.0, "avg_logprob": -0.20905674205106847, "compression_ratio": 1.5810810810810811, "no_speech_prob": 8.09173725428991e-05}, {"id": 606, "seek": 415996, "start": 4159.96, "end": 4169.88, "text": " have a very, very large vector, all with things aren't too small. Yeah. You're still going", "tokens": [362, 257, 588, 11, 588, 2416, 8062, 11, 439, 365, 721, 3212, 380, 886, 1359, 13, 865, 13, 509, 434, 920, 516], "temperature": 0.0, "avg_logprob": -0.1834322879188939, "compression_ratio": 1.6435185185185186, "no_speech_prob": 1.2804217476514168e-05}, {"id": 607, "seek": 415996, "start": 4169.88, "end": 4178.0, "text": " to have the norm of the dot products increase, I think. I think it's a good question. I", "tokens": [281, 362, 264, 2026, 295, 264, 5893, 3383, 3488, 11, 286, 519, 13, 286, 519, 309, 311, 257, 665, 1168, 13, 286], "temperature": 0.0, "avg_logprob": -0.1834322879188939, "compression_ratio": 1.6435185185185186, "no_speech_prob": 1.2804217476514168e-05}, {"id": 608, "seek": 415996, "start": 4178.0, "end": 4182.2, "text": " hadn't thought about it too much. That's my off the cuff answer, but it's what I think", "tokens": [8782, 380, 1194, 466, 309, 886, 709, 13, 663, 311, 452, 766, 264, 35997, 1867, 11, 457, 309, 311, 437, 286, 519], "temperature": 0.0, "avg_logprob": -0.1834322879188939, "compression_ratio": 1.6435185185185186, "no_speech_prob": 1.2804217476514168e-05}, {"id": 609, "seek": 415996, "start": 4182.2, "end": 4189.56, "text": " about more. I think the answer is that the effect you get of kind of losing dynamic range", "tokens": [466, 544, 13, 286, 519, 264, 1867, 307, 300, 264, 1802, 291, 483, 295, 733, 295, 7027, 8546, 3613], "temperature": 0.0, "avg_logprob": -0.1834322879188939, "compression_ratio": 1.6435185185185186, "no_speech_prob": 1.2804217476514168e-05}, {"id": 610, "seek": 418956, "start": 4189.56, "end": 4197.72, "text": " as things get longer, but that's going to happen anyway and lay an norm. Can't fix that.", "tokens": [382, 721, 483, 2854, 11, 457, 300, 311, 516, 281, 1051, 4033, 293, 2360, 364, 2026, 13, 1664, 380, 3191, 300, 13], "temperature": 0.0, "avg_logprob": -0.2309587001800537, "compression_ratio": 1.5714285714285714, "no_speech_prob": 8.663421795063186e-06}, {"id": 611, "seek": 418956, "start": 4197.72, "end": 4204.04, "text": " It's sort of coming along too late. And therefore you gain by doing this scaling.", "tokens": [467, 311, 1333, 295, 1348, 2051, 886, 3469, 13, 400, 4412, 291, 6052, 538, 884, 341, 21589, 13], "temperature": 0.0, "avg_logprob": -0.2309587001800537, "compression_ratio": 1.5714285714285714, "no_speech_prob": 8.663421795063186e-06}, {"id": 612, "seek": 418956, "start": 4204.04, "end": 4208.68, "text": " I think so. But I think it's worth. Yeah. I think it's worth thinking about more. Why", "tokens": [286, 519, 370, 13, 583, 286, 519, 309, 311, 3163, 13, 865, 13, 286, 519, 309, 311, 3163, 1953, 466, 544, 13, 1545], "temperature": 0.0, "avg_logprob": -0.2309587001800537, "compression_ratio": 1.5714285714285714, "no_speech_prob": 8.663421795063186e-06}, {"id": 613, "seek": 418956, "start": 4208.68, "end": 4217.64, "text": " square root? Well, let's see. The norms of the dot product grows with O of D. And so", "tokens": [3732, 5593, 30, 1042, 11, 718, 311, 536, 13, 440, 24357, 295, 264, 5893, 1674, 13156, 365, 422, 295, 413, 13, 400, 370], "temperature": 0.0, "avg_logprob": -0.2309587001800537, "compression_ratio": 1.5714285714285714, "no_speech_prob": 8.663421795063186e-06}, {"id": 614, "seek": 421764, "start": 4217.64, "end": 4222.88, "text": " when you square root one, no, I guess it's square scales with O of root D, I can't remember.", "tokens": [562, 291, 3732, 5593, 472, 11, 572, 11, 286, 2041, 309, 311, 3732, 17408, 365, 422, 295, 5593, 413, 11, 286, 393, 380, 1604, 13], "temperature": 0.0, "avg_logprob": -0.2195719223988207, "compression_ratio": 1.5197740112994351, "no_speech_prob": 3.7046749639557675e-05}, {"id": 615, "seek": 421764, "start": 4222.88, "end": 4226.72, "text": " There's a little note in the attention is all you need paper about why it's root D, but", "tokens": [821, 311, 257, 707, 3637, 294, 264, 3202, 307, 439, 291, 643, 3035, 466, 983, 309, 311, 5593, 413, 11, 457], "temperature": 0.0, "avg_logprob": -0.2195719223988207, "compression_ratio": 1.5197740112994351, "no_speech_prob": 3.7046749639557675e-05}, {"id": 616, "seek": 421764, "start": 4226.72, "end": 4240.68, "text": " I actually can't take it off the top of my head here. So, but it is in that paper. Okay.", "tokens": [286, 767, 393, 380, 747, 309, 766, 264, 1192, 295, 452, 1378, 510, 13, 407, 11, 457, 309, 307, 294, 300, 3035, 13, 1033, 13], "temperature": 0.0, "avg_logprob": -0.2195719223988207, "compression_ratio": 1.5197740112994351, "no_speech_prob": 3.7046749639557675e-05}, {"id": 617, "seek": 424068, "start": 4240.68, "end": 4251.76, "text": " Anything else before you go on? Great. All right. So what would you like to fix? You", "tokens": [11998, 1646, 949, 291, 352, 322, 30, 3769, 13, 1057, 558, 13, 407, 437, 576, 291, 411, 281, 3191, 30, 509], "temperature": 0.0, "avg_logprob": -0.1811504031336585, "compression_ratio": 1.553191489361702, "no_speech_prob": 9.759654494700953e-05}, {"id": 618, "seek": 424068, "start": 4251.76, "end": 4257.0, "text": " know, the thing that that shows up most frequently as a pain point in transformers is actually", "tokens": [458, 11, 264, 551, 300, 300, 3110, 493, 881, 10374, 382, 257, 1822, 935, 294, 4088, 433, 307, 767], "temperature": 0.0, "avg_logprob": -0.1811504031336585, "compression_ratio": 1.553191489361702, "no_speech_prob": 9.759654494700953e-05}, {"id": 619, "seek": 424068, "start": 4257.0, "end": 4263.52, "text": " the quadratic compute in the self attention itself. So we're having all pairs of interactions.", "tokens": [264, 37262, 14722, 294, 264, 2698, 3202, 2564, 13, 407, 321, 434, 1419, 439, 15494, 295, 13280, 13], "temperature": 0.0, "avg_logprob": -0.1811504031336585, "compression_ratio": 1.553191489361702, "no_speech_prob": 9.759654494700953e-05}, {"id": 620, "seek": 424068, "start": 4263.52, "end": 4268.84, "text": " We had that T by T matrix that was computed by taking these dot products between all pairs", "tokens": [492, 632, 300, 314, 538, 314, 8141, 300, 390, 40610, 538, 1940, 613, 5893, 3383, 1296, 439, 15494], "temperature": 0.0, "avg_logprob": -0.1811504031336585, "compression_ratio": 1.553191489361702, "no_speech_prob": 9.759654494700953e-05}, {"id": 621, "seek": 426884, "start": 4268.84, "end": 4273.8, "text": " of word vectors. And so even though we argue at the beginning of the class that we don't", "tokens": [295, 1349, 18875, 13, 400, 370, 754, 1673, 321, 9695, 412, 264, 2863, 295, 264, 1508, 300, 321, 500, 380], "temperature": 0.0, "avg_logprob": -0.12176809310913086, "compression_ratio": 1.696875, "no_speech_prob": 6.301690882537514e-05}, {"id": 622, "seek": 426884, "start": 4273.8, "end": 4278.8, "text": " have this sort of temporal dependence in the computation graph that stops us from parallelizing", "tokens": [362, 341, 1333, 295, 30881, 31704, 294, 264, 24903, 4295, 300, 10094, 505, 490, 8952, 3319], "temperature": 0.0, "avg_logprob": -0.12176809310913086, "compression_ratio": 1.696875, "no_speech_prob": 6.301690882537514e-05}, {"id": 623, "seek": 426884, "start": 4278.8, "end": 4283.56, "text": " things, we still need to do all that computation and that grows quadratically. For recurrent", "tokens": [721, 11, 321, 920, 643, 281, 360, 439, 300, 24903, 293, 300, 13156, 10787, 4481, 984, 13, 1171, 18680, 1753], "temperature": 0.0, "avg_logprob": -0.12176809310913086, "compression_ratio": 1.696875, "no_speech_prob": 6.301690882537514e-05}, {"id": 624, "seek": 426884, "start": 4283.56, "end": 4288.92, "text": " models, right, it only grew linearly. Every time you applied the RNN cell, you did sort", "tokens": [5245, 11, 558, 11, 309, 787, 6109, 43586, 13, 2048, 565, 291, 6456, 264, 45702, 45, 2815, 11, 291, 630, 1333], "temperature": 0.0, "avg_logprob": -0.12176809310913086, "compression_ratio": 1.696875, "no_speech_prob": 6.301690882537514e-05}, {"id": 625, "seek": 426884, "start": 4288.92, "end": 4293.360000000001, "text": " of more work, but you're not adding quadratically to the amount of work you have to do as you", "tokens": [295, 544, 589, 11, 457, 291, 434, 406, 5127, 10787, 4481, 984, 281, 264, 2372, 295, 589, 291, 362, 281, 360, 382, 291], "temperature": 0.0, "avg_logprob": -0.12176809310913086, "compression_ratio": 1.696875, "no_speech_prob": 6.301690882537514e-05}, {"id": 626, "seek": 426884, "start": 4293.360000000001, "end": 4297.76, "text": " get to longer sequences. Separately, position representations. I mean, the absolute", "tokens": [483, 281, 2854, 22978, 13, 43480, 1592, 11, 2535, 33358, 13, 286, 914, 11, 264, 8236], "temperature": 0.0, "avg_logprob": -0.12176809310913086, "compression_ratio": 1.696875, "no_speech_prob": 6.301690882537514e-05}, {"id": 627, "seek": 429776, "start": 4297.76, "end": 4305.08, "text": " position of a word is just not, maybe not the best way to represent the structure of", "tokens": [2535, 295, 257, 1349, 307, 445, 406, 11, 1310, 406, 264, 1151, 636, 281, 2906, 264, 3877, 295], "temperature": 0.0, "avg_logprob": -0.1485597115975839, "compression_ratio": 1.6848249027237354, "no_speech_prob": 5.64854963158723e-05}, {"id": 628, "seek": 429776, "start": 4305.08, "end": 4311.24, "text": " a sentence. And so there have been these two, you know, among other advancements in that", "tokens": [257, 8174, 13, 400, 370, 456, 362, 668, 613, 732, 11, 291, 458, 11, 3654, 661, 7295, 1117, 294, 300], "temperature": 0.0, "avg_logprob": -0.1485597115975839, "compression_ratio": 1.6848249027237354, "no_speech_prob": 5.64854963158723e-05}, {"id": 629, "seek": 429776, "start": 4311.24, "end": 4314.8, "text": " that I won't be able to get into today, but you can take a look at these papers and the", "tokens": [300, 286, 1582, 380, 312, 1075, 281, 483, 666, 965, 11, 457, 291, 393, 747, 257, 574, 412, 613, 10577, 293, 264], "temperature": 0.0, "avg_logprob": -0.1485597115975839, "compression_ratio": 1.6848249027237354, "no_speech_prob": 5.64854963158723e-05}, {"id": 630, "seek": 429776, "start": 4314.8, "end": 4318.04, "text": " papers that cite them. There are other ways to represent position. People are working", "tokens": [10577, 300, 37771, 552, 13, 821, 366, 661, 2098, 281, 2906, 2535, 13, 3432, 366, 1364], "temperature": 0.0, "avg_logprob": -0.1485597115975839, "compression_ratio": 1.6848249027237354, "no_speech_prob": 5.64854963158723e-05}, {"id": 631, "seek": 429776, "start": 4318.04, "end": 4325.96, "text": " on it. But I want to focus more today on the problem of the quadratic compute. So how", "tokens": [322, 309, 13, 583, 286, 528, 281, 1879, 544, 965, 322, 264, 1154, 295, 264, 37262, 14722, 13, 407, 577], "temperature": 0.0, "avg_logprob": -0.1485597115975839, "compression_ratio": 1.6848249027237354, "no_speech_prob": 5.64854963158723e-05}, {"id": 632, "seek": 432596, "start": 4325.96, "end": 4331.2, "text": " do we get, like, how do we reason about this? Why is this a problem? Right, so it's highly", "tokens": [360, 321, 483, 11, 411, 11, 577, 360, 321, 1778, 466, 341, 30, 1545, 307, 341, 257, 1154, 30, 1779, 11, 370, 309, 311, 5405], "temperature": 0.0, "avg_logprob": -0.17206786473592123, "compression_ratio": 1.6481481481481481, "no_speech_prob": 6.011919322190806e-05}, {"id": 633, "seek": 432596, "start": 4331.2, "end": 4334.88, "text": " parallelizable, but we still have to do these operations. We have t squared, that's the", "tokens": [8952, 22395, 11, 457, 321, 920, 362, 281, 360, 613, 7705, 13, 492, 362, 256, 8889, 11, 300, 311, 264], "temperature": 0.0, "avg_logprob": -0.17206786473592123, "compression_ratio": 1.6481481481481481, "no_speech_prob": 6.011919322190806e-05}, {"id": 634, "seek": 432596, "start": 4334.88, "end": 4339.4800000000005, "text": " sequence length, and then d is the dimensionality. And so in computing this matrix, we have", "tokens": [8310, 4641, 11, 293, 550, 274, 307, 264, 10139, 1860, 13, 400, 370, 294, 15866, 341, 8141, 11, 321, 362], "temperature": 0.0, "avg_logprob": -0.17206786473592123, "compression_ratio": 1.6481481481481481, "no_speech_prob": 6.011919322190806e-05}, {"id": 635, "seek": 432596, "start": 4339.4800000000005, "end": 4345.32, "text": " o of t squared d computations that our GPU needs to chunk through. If we think of d is", "tokens": [277, 295, 256, 8889, 274, 2807, 763, 300, 527, 18407, 2203, 281, 16635, 807, 13, 759, 321, 519, 295, 274, 307], "temperature": 0.0, "avg_logprob": -0.17206786473592123, "compression_ratio": 1.6481481481481481, "no_speech_prob": 6.011919322190806e-05}, {"id": 636, "seek": 432596, "start": 4345.32, "end": 4351.6, "text": " at the round of thousand, or two, or three thousand, if we had sort of single, shortish", "tokens": [412, 264, 3098, 295, 4714, 11, 420, 732, 11, 420, 1045, 4714, 11, 498, 321, 632, 1333, 295, 2167, 11, 2099, 742], "temperature": 0.0, "avg_logprob": -0.17206786473592123, "compression_ratio": 1.6481481481481481, "no_speech_prob": 6.011919322190806e-05}, {"id": 637, "seek": 435160, "start": 4351.6, "end": 4356.56, "text": " sentences, then maybe t is like 30-ish, and then t squared is 900, so it's like, yeah,", "tokens": [16579, 11, 550, 1310, 256, 307, 411, 2217, 12, 742, 11, 293, 550, 256, 8889, 307, 22016, 11, 370, 309, 311, 411, 11, 1338, 11], "temperature": 0.0, "avg_logprob": -0.1952340545654297, "compression_ratio": 1.6204379562043796, "no_speech_prob": 5.142909867572598e-05}, {"id": 638, "seek": 435160, "start": 4356.56, "end": 4361.8, "text": " it's actually not that big a deal. And in practice, for a lot of models, we'll set an actual", "tokens": [309, 311, 767, 406, 300, 955, 257, 2028, 13, 400, 294, 3124, 11, 337, 257, 688, 295, 5245, 11, 321, 603, 992, 364, 3539], "temperature": 0.0, "avg_logprob": -0.1952340545654297, "compression_ratio": 1.6204379562043796, "no_speech_prob": 5.142909867572598e-05}, {"id": 639, "seek": 435160, "start": 4361.8, "end": 4367.120000000001, "text": " bound like 512. So if your document is longer than 512 words, you're out of luck. You're", "tokens": [5472, 411, 1025, 4762, 13, 407, 498, 428, 4166, 307, 2854, 813, 1025, 4762, 2283, 11, 291, 434, 484, 295, 3668, 13, 509, 434], "temperature": 0.0, "avg_logprob": -0.1952340545654297, "compression_ratio": 1.6204379562043796, "no_speech_prob": 5.142909867572598e-05}, {"id": 640, "seek": 435160, "start": 4367.120000000001, "end": 4373.120000000001, "text": " chunked it or something. But what if we want to work on documents that are 10,000 words", "tokens": [16635, 292, 309, 420, 746, 13, 583, 437, 498, 321, 528, 281, 589, 322, 8512, 300, 366, 1266, 11, 1360, 2283], "temperature": 0.0, "avg_logprob": -0.1952340545654297, "compression_ratio": 1.6204379562043796, "no_speech_prob": 5.142909867572598e-05}, {"id": 641, "seek": 435160, "start": 4373.120000000001, "end": 4379.56, "text": " or greater, 10,000 squared is not feasible. So we have to somehow remove the dependence", "tokens": [420, 5044, 11, 1266, 11, 1360, 8889, 307, 406, 26648, 13, 407, 321, 362, 281, 6063, 4159, 264, 31704], "temperature": 0.0, "avg_logprob": -0.1952340545654297, "compression_ratio": 1.6204379562043796, "no_speech_prob": 5.142909867572598e-05}, {"id": 642, "seek": 437956, "start": 4379.56, "end": 4385.0, "text": " on t squared if we're going to work with these. There are a couple of ways that have been", "tokens": [322, 256, 8889, 498, 321, 434, 516, 281, 589, 365, 613, 13, 821, 366, 257, 1916, 295, 2098, 300, 362, 668], "temperature": 0.0, "avg_logprob": -0.16468611785343715, "compression_ratio": 1.6628787878787878, "no_speech_prob": 1.496972436143551e-05}, {"id": 643, "seek": 437956, "start": 4385.0, "end": 4388.72, "text": " taught to do this. This is all very, very recent work, and it's only a smattering of the", "tokens": [5928, 281, 360, 341, 13, 639, 307, 439, 588, 11, 588, 5162, 589, 11, 293, 309, 311, 787, 257, 899, 14849, 295, 264], "temperature": 0.0, "avg_logprob": -0.16468611785343715, "compression_ratio": 1.6628787878787878, "no_speech_prob": 1.496972436143551e-05}, {"id": 644, "seek": 437956, "start": 4388.72, "end": 4394.400000000001, "text": " efforts that have come up. So the question is, can we build models like transformers that", "tokens": [6484, 300, 362, 808, 493, 13, 407, 264, 1168, 307, 11, 393, 321, 1322, 5245, 411, 4088, 433, 300], "temperature": 0.0, "avg_logprob": -0.16468611785343715, "compression_ratio": 1.6628787878787878, "no_speech_prob": 1.496972436143551e-05}, {"id": 645, "seek": 437956, "start": 4394.400000000001, "end": 4401.160000000001, "text": " get away without the o of t squared, all pairs interactions cost? One example is the", "tokens": [483, 1314, 1553, 264, 277, 295, 256, 8889, 11, 439, 15494, 13280, 2063, 30, 1485, 1365, 307, 264], "temperature": 0.0, "avg_logprob": -0.16468611785343715, "compression_ratio": 1.6628787878787878, "no_speech_prob": 1.496972436143551e-05}, {"id": 646, "seek": 437956, "start": 4401.160000000001, "end": 4407.56, "text": " linformer. And the idea here is that you're going to actually map the sequence length", "tokens": [22896, 837, 260, 13, 400, 264, 1558, 510, 307, 300, 291, 434, 516, 281, 767, 4471, 264, 8310, 4641], "temperature": 0.0, "avg_logprob": -0.16468611785343715, "compression_ratio": 1.6628787878787878, "no_speech_prob": 1.496972436143551e-05}, {"id": 647, "seek": 440756, "start": 4407.56, "end": 4414.52, "text": " dimension to a lower dimensional space for values and keys. So you had values, keys and", "tokens": [10139, 281, 257, 3126, 18795, 1901, 337, 4190, 293, 9317, 13, 407, 291, 632, 4190, 11, 9317, 293], "temperature": 0.0, "avg_logprob": -0.16055497756371132, "compression_ratio": 1.8237704918032787, "no_speech_prob": 1.496908316767076e-05}, {"id": 648, "seek": 440756, "start": 4414.52, "end": 4418.88, "text": " queries, and you had your normal linear layers. Now you're going to project to a much lower", "tokens": [24109, 11, 293, 291, 632, 428, 2710, 8213, 7914, 13, 823, 291, 434, 516, 281, 1716, 281, 257, 709, 3126], "temperature": 0.0, "avg_logprob": -0.16055497756371132, "compression_ratio": 1.8237704918032787, "no_speech_prob": 1.496908316767076e-05}, {"id": 649, "seek": 440756, "start": 4418.88, "end": 4425.240000000001, "text": " dimension than the sequence length. And in doing so, you're sort of getting rid of that", "tokens": [10139, 813, 264, 8310, 4641, 13, 400, 294, 884, 370, 11, 291, 434, 1333, 295, 1242, 3973, 295, 300], "temperature": 0.0, "avg_logprob": -0.16055497756371132, "compression_ratio": 1.8237704918032787, "no_speech_prob": 1.496908316767076e-05}, {"id": 650, "seek": 440756, "start": 4425.240000000001, "end": 4430.4800000000005, "text": " t by mapping it to something smaller, you're just saying, combine all the information from", "tokens": [256, 538, 18350, 309, 281, 746, 4356, 11, 291, 434, 445, 1566, 11, 10432, 439, 264, 1589, 490], "temperature": 0.0, "avg_logprob": -0.16055497756371132, "compression_ratio": 1.8237704918032787, "no_speech_prob": 1.496908316767076e-05}, {"id": 651, "seek": 440756, "start": 4430.4800000000005, "end": 4434.88, "text": " all these time steps into something that's lower dimensional. And so in this plot from", "tokens": [439, 613, 565, 4439, 666, 746, 300, 311, 3126, 18795, 13, 400, 370, 294, 341, 7542, 490], "temperature": 0.0, "avg_logprob": -0.16055497756371132, "compression_ratio": 1.8237704918032787, "no_speech_prob": 1.496908316767076e-05}, {"id": 652, "seek": 443488, "start": 4434.88, "end": 4441.0, "text": " the paper, as the sequence length goes from 512, the batch size of 128 to the sequence", "tokens": [264, 3035, 11, 382, 264, 8310, 4641, 1709, 490, 1025, 4762, 11, 264, 15245, 2744, 295, 29810, 281, 264, 8310], "temperature": 0.0, "avg_logprob": -0.2359613811268526, "compression_ratio": 1.5941176470588236, "no_speech_prob": 2.3918710212456062e-05}, {"id": 653, "seek": 443488, "start": 4441.0, "end": 4447.64, "text": " length being 65,000 with the batch size of 1, you get the transformer inference time growing", "tokens": [4641, 885, 11624, 11, 1360, 365, 264, 15245, 2744, 295, 502, 11, 291, 483, 264, 31782, 38253, 565, 4194], "temperature": 0.0, "avg_logprob": -0.2359613811268526, "compression_ratio": 1.5941176470588236, "no_speech_prob": 2.3918710212456062e-05}, {"id": 654, "seek": 443488, "start": 4447.64, "end": 4455.8, "text": " very large, and then the linformer with various bottleneck dimensionalities, keys 128, 256,", "tokens": [588, 2416, 11, 293, 550, 264, 22896, 837, 260, 365, 3683, 44641, 547, 10139, 16110, 11, 9317, 29810, 11, 38882, 11], "temperature": 0.0, "avg_logprob": -0.2359613811268526, "compression_ratio": 1.5941176470588236, "no_speech_prob": 2.3918710212456062e-05}, {"id": 655, "seek": 445580, "start": 4455.8, "end": 4465.12, "text": " and doing much, much better. A separate option has been to take a totally different take", "tokens": [293, 884, 709, 11, 709, 1101, 13, 316, 4994, 3614, 575, 668, 281, 747, 257, 3879, 819, 747], "temperature": 0.0, "avg_logprob": -0.17619681585402716, "compression_ratio": 1.6884615384615385, "no_speech_prob": 2.0459157894947566e-05}, {"id": 656, "seek": 445580, "start": 4465.12, "end": 4470.320000000001, "text": " on can we get away without these all pairs interactions, which is the following. Do we", "tokens": [322, 393, 321, 483, 1314, 1553, 613, 439, 15494, 13280, 11, 597, 307, 264, 3480, 13, 1144, 321], "temperature": 0.0, "avg_logprob": -0.17619681585402716, "compression_ratio": 1.6884615384615385, "no_speech_prob": 2.0459157894947566e-05}, {"id": 657, "seek": 445580, "start": 4470.320000000001, "end": 4474.68, "text": " need to even try to compute all pairs of interactions if we can do sort of a bunch", "tokens": [643, 281, 754, 853, 281, 14722, 439, 15494, 295, 13280, 498, 321, 393, 360, 1333, 295, 257, 3840], "temperature": 0.0, "avg_logprob": -0.17619681585402716, "compression_ratio": 1.6884615384615385, "no_speech_prob": 2.0459157894947566e-05}, {"id": 658, "seek": 445580, "start": 4474.68, "end": 4480.400000000001, "text": " of other stuff that's going to be more efficient to compute? So like looking at local windows,", "tokens": [295, 661, 1507, 300, 311, 516, 281, 312, 544, 7148, 281, 14722, 30, 407, 411, 1237, 412, 2654, 9309, 11], "temperature": 0.0, "avg_logprob": -0.17619681585402716, "compression_ratio": 1.6884615384615385, "no_speech_prob": 2.0459157894947566e-05}, {"id": 659, "seek": 445580, "start": 4480.400000000001, "end": 4485.0, "text": " we know that's useful, but not sufficient in some sense. Looking at everything, so if", "tokens": [321, 458, 300, 311, 4420, 11, 457, 406, 11563, 294, 512, 2020, 13, 11053, 412, 1203, 11, 370, 498], "temperature": 0.0, "avg_logprob": -0.17619681585402716, "compression_ratio": 1.6884615384615385, "no_speech_prob": 2.0459157894947566e-05}, {"id": 660, "seek": 448500, "start": 4485.0, "end": 4488.68, "text": " you were to just take like an average of vectors, just all the averaging of vectors, you don't", "tokens": [291, 645, 281, 445, 747, 411, 364, 4274, 295, 18875, 11, 445, 439, 264, 47308, 295, 18875, 11, 291, 500, 380], "temperature": 0.0, "avg_logprob": -0.14308268524879633, "compression_ratio": 1.9963503649635037, "no_speech_prob": 9.167788812192157e-05}, {"id": 661, "seek": 448500, "start": 4488.68, "end": 4493.0, "text": " need to compute interactions for that. And if you look at sort of random pairs, you don't", "tokens": [643, 281, 14722, 13280, 337, 300, 13, 400, 498, 291, 574, 412, 1333, 295, 4974, 15494, 11, 291, 500, 380], "temperature": 0.0, "avg_logprob": -0.14308268524879633, "compression_ratio": 1.9963503649635037, "no_speech_prob": 9.167788812192157e-05}, {"id": 662, "seek": 448500, "start": 4493.0, "end": 4498.24, "text": " need to take all that much time to compute that as well. And so what this paper did is they", "tokens": [643, 281, 747, 439, 300, 709, 565, 281, 14722, 300, 382, 731, 13, 400, 370, 437, 341, 3035, 630, 307, 436], "temperature": 0.0, "avg_logprob": -0.14308268524879633, "compression_ratio": 1.9963503649635037, "no_speech_prob": 9.167788812192157e-05}, {"id": 663, "seek": 448500, "start": 4498.24, "end": 4504.0, "text": " did all of them. So you have random attention, you have a word window attention where you're", "tokens": [630, 439, 295, 552, 13, 407, 291, 362, 4974, 3202, 11, 291, 362, 257, 1349, 4910, 3202, 689, 291, 434], "temperature": 0.0, "avg_logprob": -0.14308268524879633, "compression_ratio": 1.9963503649635037, "no_speech_prob": 9.167788812192157e-05}, {"id": 664, "seek": 448500, "start": 4504.0, "end": 4507.76, "text": " looking at your local neighbors, and you have sort of global attention where you're sort", "tokens": [1237, 412, 428, 2654, 12512, 11, 293, 291, 362, 1333, 295, 4338, 3202, 689, 291, 434, 1333], "temperature": 0.0, "avg_logprob": -0.14308268524879633, "compression_ratio": 1.9963503649635037, "no_speech_prob": 9.167788812192157e-05}, {"id": 665, "seek": 448500, "start": 4507.76, "end": 4512.28, "text": " of, you know, attending without interacting with stuff, attending broadly over the whole", "tokens": [295, 11, 291, 458, 11, 15862, 1553, 18017, 365, 1507, 11, 15862, 19511, 670, 264, 1379], "temperature": 0.0, "avg_logprob": -0.14308268524879633, "compression_ratio": 1.9963503649635037, "no_speech_prob": 9.167788812192157e-05}, {"id": 666, "seek": 451228, "start": 4512.28, "end": 4517.599999999999, "text": " sequence, you do a whole bunch of it, right, and you end up being able to approximate a", "tokens": [8310, 11, 291, 360, 257, 1379, 3840, 295, 309, 11, 558, 11, 293, 291, 917, 493, 885, 1075, 281, 30874, 257], "temperature": 0.0, "avg_logprob": -0.14450031778086786, "compression_ratio": 1.591549295774648, "no_speech_prob": 2.014052188314963e-05}, {"id": 667, "seek": 451228, "start": 4517.599999999999, "end": 4522.88, "text": " lot of good things. These are not, you know, necessarily the answer, the normal transformer", "tokens": [688, 295, 665, 721, 13, 1981, 366, 406, 11, 291, 458, 11, 4725, 264, 1867, 11, 264, 2710, 31782], "temperature": 0.0, "avg_logprob": -0.14450031778086786, "compression_ratio": 1.591549295774648, "no_speech_prob": 2.014052188314963e-05}, {"id": 668, "seek": 451228, "start": 4522.88, "end": 4528.639999999999, "text": " variant is by far the most popular currently, but it's a fascinating question to look into.", "tokens": [17501, 307, 538, 1400, 264, 881, 3743, 4362, 11, 457, 309, 311, 257, 10343, 1168, 281, 574, 666, 13], "temperature": 0.0, "avg_logprob": -0.14450031778086786, "compression_ratio": 1.591549295774648, "no_speech_prob": 2.014052188314963e-05}, {"id": 669, "seek": 451228, "start": 4528.639999999999, "end": 4535.84, "text": " So now as the time, more or less expires, I'll say we're working on pre-training on Thursday,", "tokens": [407, 586, 382, 264, 565, 11, 544, 420, 1570, 1278, 3145, 11, 286, 603, 584, 321, 434, 1364, 322, 659, 12, 17227, 1760, 322, 10383, 11], "temperature": 0.0, "avg_logprob": -0.14450031778086786, "compression_ratio": 1.591549295774648, "no_speech_prob": 2.014052188314963e-05}, {"id": 670, "seek": 451228, "start": 4535.84, "end": 4539.88, "text": " good luck on assignment four, and I remember to work on your project proposal. I think", "tokens": [665, 3668, 322, 15187, 1451, 11, 293, 286, 1604, 281, 589, 322, 428, 1716, 11494, 13, 286, 519], "temperature": 0.0, "avg_logprob": -0.14450031778086786, "compression_ratio": 1.591549295774648, "no_speech_prob": 2.014052188314963e-05}, {"id": 671, "seek": 453988, "start": 4539.88, "end": 4542.68, "text": " we have time for a final question if anyone wants to.", "tokens": [321, 362, 565, 337, 257, 2572, 1168, 498, 2878, 2738, 281, 13], "temperature": 0.0, "avg_logprob": -0.6240400384973597, "compression_ratio": 1.337837837837838, "no_speech_prob": 4.1302613681182265e-05}, {"id": 672, "seek": 453988, "start": 4542.68, "end": 4555.96, "text": " Are you a user or a member of the Santa Fe performance?", "tokens": [2014, 291, 257, 4195, 420, 257, 4006, 295, 264, 9933, 3697, 3389, 30], "temperature": 0.0, "avg_logprob": -0.6240400384973597, "compression_ratio": 1.337837837837838, "no_speech_prob": 4.1302613681182265e-05}, {"id": 673, "seek": 453988, "start": 4555.96, "end": 4565.92, "text": " It's a good question. Yeah, I, I mean, I believe still places in reinforcement learning.", "tokens": [467, 311, 257, 665, 1168, 13, 865, 11, 286, 11, 286, 914, 11, 286, 1697, 920, 3190, 294, 29280, 2539, 13], "temperature": 0.0, "avg_logprob": -0.6240400384973597, "compression_ratio": 1.337837837837838, "no_speech_prob": 4.1302613681182265e-05}, {"id": 674, "seek": 456592, "start": 4565.92, "end": 4572.0, "text": " I mean, places where the recurrent inducted bias is, is clearly well specified or useful.", "tokens": [286, 914, 11, 3190, 689, 264, 18680, 1753, 31612, 292, 12577, 307, 11, 307, 4448, 731, 22206, 420, 4420, 13], "temperature": 0.0, "avg_logprob": -0.15982328367627358, "compression_ratio": 1.6088560885608856, "no_speech_prob": 0.0001213864452438429}, {"id": 675, "seek": 456592, "start": 4572.0, "end": 4579.6, "text": " It was a conversation like, I don't know of places in, in NLP where people are still", "tokens": [467, 390, 257, 3761, 411, 11, 286, 500, 380, 458, 295, 3190, 294, 11, 294, 426, 45196, 689, 561, 366, 920], "temperature": 0.0, "avg_logprob": -0.15982328367627358, "compression_ratio": 1.6088560885608856, "no_speech_prob": 0.0001213864452438429}, {"id": 676, "seek": 456592, "start": 4579.6, "end": 4583.68, "text": " broadly using RNNs. It was thought for a while that transformers took a lot more data", "tokens": [19511, 1228, 45702, 45, 82, 13, 467, 390, 1194, 337, 257, 1339, 300, 4088, 433, 1890, 257, 688, 544, 1412], "temperature": 0.0, "avg_logprob": -0.15982328367627358, "compression_ratio": 1.6088560885608856, "no_speech_prob": 0.0001213864452438429}, {"id": 677, "seek": 456592, "start": 4583.68, "end": 4587.96, "text": " to train than RNNs, and so you sort of should use RNNs on smaller data problems, but with", "tokens": [281, 3847, 813, 45702, 45, 82, 11, 293, 370, 291, 1333, 295, 820, 764, 45702, 45, 82, 322, 4356, 1412, 2740, 11, 457, 365], "temperature": 0.0, "avg_logprob": -0.15982328367627358, "compression_ratio": 1.6088560885608856, "no_speech_prob": 0.0001213864452438429}, {"id": 678, "seek": 456592, "start": 4587.96, "end": 4593.36, "text": " pre-training, I'm not sure that that's the case. I think the answer is yes, there are", "tokens": [659, 12, 17227, 1760, 11, 286, 478, 406, 988, 300, 300, 311, 264, 1389, 13, 286, 519, 264, 1867, 307, 2086, 11, 456, 366], "temperature": 0.0, "avg_logprob": -0.15982328367627358, "compression_ratio": 1.6088560885608856, "no_speech_prob": 0.0001213864452438429}, {"id": 679, "seek": 459336, "start": 4593.36, "end": 4600.679999999999, "text": " still use cases, but it should be where the recurrent seems to really be the thing that", "tokens": [920, 764, 3331, 11, 457, 309, 820, 312, 689, 264, 18680, 1753, 2544, 281, 534, 312, 264, 551, 300], "temperature": 0.0, "avg_logprob": -0.21532776861479788, "compression_ratio": 1.558659217877095, "no_speech_prob": 4.067141708219424e-05}, {"id": 680, "seek": 459336, "start": 4600.679999999999, "end": 4606.679999999999, "text": " is winning you something as opposed to like maybe needing more data or for transformers,", "tokens": [307, 8224, 291, 746, 382, 8851, 281, 411, 1310, 18006, 544, 1412, 420, 337, 4088, 433, 11], "temperature": 0.0, "avg_logprob": -0.21532776861479788, "compression_ratio": 1.558659217877095, "no_speech_prob": 4.067141708219424e-05}, {"id": 681, "seek": 459336, "start": 4606.679999999999, "end": 4609.719999999999, "text": " because it seems like that might not actually be the case even though we thought so back", "tokens": [570, 309, 2544, 411, 300, 1062, 406, 767, 312, 264, 1389, 754, 1673, 321, 1194, 370, 646], "temperature": 0.0, "avg_logprob": -0.21532776861479788, "compression_ratio": 1.558659217877095, "no_speech_prob": 4.067141708219424e-05}, {"id": 682, "seek": 460972, "start": 4609.72, "end": 4625.88, "text": " in like 2017.", "tokens": [50364, 294, 411, 6591, 13, 51172], "temperature": 0.0, "avg_logprob": -0.8512873649597168, "compression_ratio": 0.6190476190476191, "no_speech_prob": 9.742528345668688e-05}], "language": "en"}