{"text": " So we're now starting in week three with lecture five. So unfortunately, the last class, I guess I really got behind and went a bit slowly. I guess I must just enjoy talking about natural languages too much. And so I never really got to the punchline of showing how you could do good things with the new dependency parser. So I'm going to say for the first piece I'll in some sense be finishing the content of last time and talk about neural dependency parsing, which also gives us the opportunity to introduce a simple feed forward neural net classifier. That will then lead into a little bit of just background things that you need to know about neural networks content because the fact of the matter is there is a bunch of stuff you need to know about neural networks. So both of those things are getting to what's really meant to be the topic of today's lecture, which is looking at language modeling and recurrent neural networks. And that's then going to lead into those two things are important topics that will then be talking about really for the whole of next week as well. So there's a couple of reminders before we get underway. The first is that you should have handed in assignment to before you join this class and in turn assignment three is out today. And it's an assignment where you're going to build essentially the new dependency parser that I'm just about to present in PyTorch. So part of the role of this assignment is actually to get you up to speed with PyTorch. So this assignment is highly scaffolded with lots of comments and hints about what to do. And so the hope is that by the time you come to the end of it, you'll feel fairly familiar and comfortable with PyTorch. Don't forget there was also tutorial on PyTorch last week if you didn't catch that at the time you might want to go back and look at the video. Another thing to mention about the assignments is that assignment three is the last assignment where our great team of TAs are happy to look at your code and sort out your bugs for you. So maybe take advantage of that but not too much. But starting an assignment for assignments for five in the final project, the TAs are very happy to help in general, but it's just not going to be their job to be actually sorting out bugs for you. You should be looking at your code and discussing ideas and concepts and reasons why things might not work with them. Okay, so if you remember where we were last time, I'd introduced this idea of transition based dependency parsers and that these were an efficient linear time method for giving the syntactic structure of natural language text. And that they worked pretty well before neural nets came along and took over an old P again, but they had some disadvantages and their biggest disadvantage is that like most machine learning models of that time, they worked with indicator features. So that means that you were specifying some condition and then checking whether it was true of a configuration. So something like the word on the top of the stack is good and it's part of speech is adjective or the next word coming up is a personal pronoun that those are conditions that would be features and conventional. Transition based dependency parser and so what are the problems with doing that well, one problem is that those features are very sparse. So the second problem is the features are incomplete. Well, what I mean by that is depending on what words and configurations occurred in the training data, there are certain features that will exist because you sort of saw a certain word preceding a verb and certain features that just won't exist because that word never occurred before a verb and the training data. So that's the biggest problem and opportunity for doing better with the neural dependency parser is that it turns out that in a symbolic dependency parser, computing all these features just turns out to actually be pretty expensive. But although the actual transition system that I showed last time is fast and efficient to run, you actually have to compute all of these features and what you found was that about 95% of the parsing time of one of these models was spent just computing all of the features of every configuration. So that suggests that perhaps we can do better with a neural approach where we're going to learn a dense and compact feature representation. And so that's what I want to go through now. So this time we're still going to have exactly the same kind of configuration of a stack and a buffer and running exactly the same transition sequence except this time rather than representing the configuration the stack and the buffer by having several million symbolic features, we're instead going to summarize this configuration as a dense vector of dimensionality perhaps approximately a thousand. And now neural approach is going to learn this dense compact feature representation. And so quite explicitly what I'm going to show you now briefly and what you're going to implement is essentially the neural dependency parser that was developed by d'antichern in 2014. And to skip to the advertisement right at the beginning as to how this works so well, these are the kind of results that you got from it using the measures that I introduced at the last time the unlabeled attachment score, whether you attached dependencies correctly to the right word and the labeled attachment scores to whether you also get the type of grammatical relation of that dependency correct. And so essentially this chin and manning parser gave a neural version of something like a transition based dependency parser like malt parser in yellow. And the interesting thing was that taking advantage of a neural classifier and ways that I'm about to explain that that could produce something that was about 2% more accurate than the symbolic dependency parser. And because of the fact that it's not doing all of the symbolic feature computation, despite the fact that you might think at first that there's a lot of real number math and matrix vector multiplies in a neural dependency parser. It actually ran noticeably faster than the symbolic dependency parser because it didn't have all feature computation. The other major approach to dependency parsing that I'm also showing here and I'll get back to at the end is what's referred to as graph based dependency parsing and so that's a different approach to dependency parsing and so these are two symbolic graph based dependency parsers and in the pre neural world, they were somewhat more accurate than the transition based parsers as you could see. But on the other hand, they were close to two orders of magnitude slower. And so essentially with the term manning parser, we were able to provide something that was basically as accurate as the best graph based dependency parsers, which were the best dependency parsers while operating about two orders of magnitude more quickly. And how did we do it? It was actually a very straightforward implementation, which is part of what makes it great for doing for assignment three. But this is how we did it and we got wins. So the first win, which is what we've already talked about extensively starting in week one is to make use of distributed representations. So we represent each word as a word embedding and you've had a lot of experience with that already. And so that means when words weren't seen in a particular configuration, we still know what they're like because they'll be well have seen similar words in the correct configuration. But we don't stop only with word embeddings. The other things that are central to our dependency parser are the parts of speech of words and the dependency labels. And so what we decided to do is that although those are much smaller sets. So the dependency labels are about 40 in number and the parts of speech are around that order of magnitude sometimes less sometimes more than even within those sets of categories. There are ones that are very strongly related. So we also adopted distributed representations for them. So for example, there might be parts of speech for single nouns and plural nouns. And basically most of the time they behave similarly. And there are some kind of magic type of modifiers and numerical modifiers. So these are just numbers like 3, 4, 5. And again, a lot of the time they behave the same that you have both three cows and brown cows. So everything is going to be represented in the distributed representation. So at that point, we have exactly the same kind of configuration where we have our stack, our buffer, and we've started to build some arcs. So the classification decisions of the next transition are going to be made out of a few elements of this configuration. So we're looking at the top thing on the stack, the thing that second on the stack, the first word on the buffer. And then we actually added in some additional features that are then to the extent that we've already built arcs for words on the stack that we can be looking at the dependence on the left and right of those words that are on the stack that are already in the sets of arcs. And so for each of those things, there is a word, there is a part of speech. And for some of them, there is a dependency where it's already connected up to something else. So for example, the left corner of S2 here has an insub-dependency back to the second thing on the stack. So we can take these elements of the configuration and can look up the embedding of each one. So we have word embeddings, part of speech embeddings, and dependency embeddings, and just concatenate them all together, kind of like we did before with the window classifier. And that will give us a newer representation of the configuration. Well, there's a second reason why we can hope to win by using a deep learning classifier to predict the next transition. And we haven't really said much about that yet. So I just wanted to detour and say a little bit more about that. So the simplest kind of classifier that's close to what we've been talking about in neural models is a softmax classifier. So that if we have de-dimensional vectors X and we have Y classes to assign things to. Also Y is an element of a set of C classes to assign things to then we can build a softmax classifier using the softmax distribution that we've seen before where we decide the classes based on having a weight matrix that's C by D. And we train on supervised data, the values of this W weight matrix to minimize our negative log likelihood loss that we've seen before. A loss does also commonly refer to as cross entropy loss a term that you'll see in pie torch among other places. So that is a straightforward machine learning classifier. And if you've done two twenty nine you've seen softmax classifiers. But a simple softmax classifier like this shares with most traditional machine learning classifiers and models include naive base models support vector machines logistic regression. But at the end of the day, they're not very powerful classifiers. They're classifiers that only give linear decision boundaries. And so this can be quite limiting. So if you have a difficult problem like the one I'm indicating in the picture in the bottom left. Well, there's just no way you can divide the green points from the red points by simply drawing a straight line. So you're going to have a quite imperfect classifier. So the second big win of neural classifiers is that they can be much more powerful because they can provide nonlinear classification. So rather than only being able to do something like in the left picture, we can come up with classifiers that do something like in the right picture and therefore can separate the green and the red points. As an aside, I'm these pictures I've taken from Andrea Caparti's ComvNet.js software, which is a kind of a fun little tool to play around with if you've got a bit of spare time. And so there's something subtle going on here is because our more powerful neural net classifiers at the end of the day, what they have at the top of them is a softmax layer. So this softmax class layer is indeed a linear classifier and it's still a linear classifier. But what they have below that is other layers of neural net. And so effectively what happens is that the classification decisions are linear as far as the top softmax is concerned, but nonlinear in the original representation space. So precisely what a neural net can do is warp the space around and move the representation of data points to provide something that at the end of the day can be classified by linear classifier. And so that's what a simple feed forward neural network multi class classifier does. So it starts with an input representation. So these are is some dense representation of the input. It puts it through a hidden layer age with a matrix multiply followed by nonlinearity. So that matrix multiply can transform the space and map things around. And so then the output of that we can then put into a softmax layer and get out softmax probabilities from which we make a classification decisions. And to the extent that our probabilities don't assign one to the correct class, we then get some log loss or cross entropy error, which we back propagate towards the parameters and embeddings of our model. And as the learning that goes on via back propagation, we increasingly well learn parameters of this hidden layer of the model, which learn to re represent the input, they move the inputs around in an intermediate hidden vector space. And so this is the easy classified with what at the end of the day is the linear softmax. So this is basically the whole of a simple feed forward neural network multi class classifier. And if we had something like a visual signal, we just sort of feed straight in here real numbers and we've been done. But normally with human language material, we actually effectively have one more layer that we're feeding in before that because really below this dense input layer, we actually have one hot vectors for what words or parts of speech were involved. And we're doing a lookup process, which you can think of as one more matrix multiply to convert the one hot features into our dense input layer. Okay, in my picture here, the one other thing that's different is I've introduced a different nonlinearity in the hidden layer, which is a rectified linear unit. So we'll be using our neural dependency pauses. It looks like the picture in the bottom right and I'll come back to that in a few minutes. That's one of the extra neural net things to talk about. Okay, so our neural net dependency parser model architecture is essentially exactly that, but applied to the configuration of our transition based dependency parser. So based on our transition based dependency parser configuration, we construct an input layer embedding by looking up on the various elements as I discussed previously. And then we feed it through this hidden layer to the softmax layer to get probabilities out of which we can choose what the next action is, and it's no more complicated than that. What we found is that just simply, you know, in some sense, using the simplest kind of feed forward neural classifier could provide a very accurate dependency parser that determines the structure of sentences supporting meaning interpretation, the kind of way that I suggested last time. Indeed, you know, despite the fact that it was a quite simple architecture in 2014. This was the first successful neural dependency parser. And the dense representations, especially, but also partly the nonlinearity of the classifier gave us this good result that it could both outperform symbolic parsers in terms of accuracy and it could outperform them in terms of speed. So that was 2014 just quickly here a couple more slides on what's happened since then. So lots of people got excited by the success of this neural dependency parser and a number of people, particularly at Google, then set about building a bigger fancier transition based neural dependency parser. So they explored bigger, deeper networks. There's no reason to only have one hidden layer. Two hidden layers, you can do beam search that I briefly mentioned last time. Another thing that I'm not going to talk about now is adding conditional random field style inference over decision sequences. And then led in 2016 for a model that they called parsing MacPars face, which is hard to say with a straight face, which was then about two and a half, three percent more accurate than the model that we had produced. But still in basically the same family of transition based parser with the neural net classifier to choose the next transition. So alternative to transition based parsers as graph based dependency parsers and for a graph based dependency parser. What you're doing is effectively considering every pair of words and considering a word as a dependent of root and you're coming up with a score as to how likely is that. That big is a dependent of root or how likely is big to be dependent of cat and similarly for every other word for the word sat how likely is it to be a dependent of root or a dependent of the etc. And well to do that well, you need to know more than just what the two words involved are. And so what you want to do is understand the context. So you want to have an understanding of the context of big what's to the left or what's to the right of it to understand how you might hook it up into the dependency representations of the sentence. And so while there being previous work and graph based dependency parsing like the mst parser I showed on the earlier results slide. It seemed appealing that we could come up with a much better representation of context using neural nets that look at context and how we do that is actually what I'll be talking about in the end part of the lecture. And so at Stanford, we became interested in trying to work out how to come up with a better graph based dependency parser using context. So I forgot this. This was showing that if we can score each pair wise dependency, we can simply choose the best one. So we can say probably big is a dependent of cat. And to a first of approximation, we're going to want to choose for each word that it is a dependent of the word that seems most likely to be a dependent. But we want to do that with some constraints because we want to get out something that is a tree with a single root of I discussed last time and you can do that by making use of a minimum spanning tree algorithm that uses these scores of how likely different dependencies are. Okay, so then in 2017 another student Tim Dozer and me then worked on saying well, can we now also build a much better neural graph based dependency parser and we developed a novel methods for scoring. And scoring dependency parsers and a graph based model, which I'm not going to get into the details of right now, but that also had a very nice result because using getting back to graph based parsing we could then build a graph based parser that performed about a percent better than the best of the Google transition based neural dependency parsers. And then we'll point out that this is a mixed win because although it's accuracy is better. These graph based parsers are just in squared and performance rather than linear time. So kind of like the earlier results I showed they don't operate nearly as quickly when you're wanting to have a large amounts of text with complex long sentences. Okay, so that's everything you need to know about dependency parsers and to do assignment three so grab it this evening and start to work. I did want to sort of before going on to the next topic just mention a few more things about neural networks since some of you know this well already some of you have seen less of it, but you know, there just are a bunch of things you have to be aware of for building neural networks. Now again for assignment three, essentially we give you everything and if you follow the recipe your parser should work well, but you know what you should have minimally do is actually you know look carefully at some of the things that this parser does, which is questions like how do we initialize our matrices of our neural network. What kind of optimizers do we use and things like that. Because these are all important decisions and so I wanted to say just a few words about that. Okay, so the first thing that we haven't discussed at all is the concept of regularization. So we're building these neural nets we're now building models with a huge number of parameters so essentially just about all neural net models that work well actually their full loss function is a regularized loss function. So this is a loss function here of J well this part here is the part that we've seen before where we're using a softmax classifier and then taking a negative log likelihood loss which within averaging over the different examples, but actually we then stick on the end of it. So this is a regularization term and so this regularization term sums the square of every parameter in the model. And so what that effectively says is you only want to make parameters non zero if they're really useful right so to the extent of the parameters don't help much you're just being penalized here. And they're not going to be extremely non zero but to the extent that the parameters do help you will gain in your estimation of likelihood and therefore it's OK for them to be non zero in particular notice that this penalty is assessed only once per parameter. It's not being assessed separately for each example. Okay, and having this kind of regularization is essential to build new net models that regularize well. So the classic problem is referred to as overfitting. And what overfitting means is that if you have a particular training data set and you start training your model, your error will go down because you'll shift the parameters so they better predict the correct answer for data points in the model and you can keep on doing that and it will keep on reducing your error rate. But if you then look at your partially trained classifier and say how well does this classifier classify independent data, different test data that you weren't training the model on, what you'll find is up until a certain point you'll get better at classifying independent test examples as well. And after that, commonly what will happen is you'll actually start to get worse at classifying independent test examples even though you're continuing to get better at predicting the training examples. And so this was then referred to as your overfitting the training examples that you're fiddling the parameters of the model so they're really good at predicting the training examples which aren't useful things that can then predict on independent examples that you come to at runtime. Okay, that classic view of regularization is sort of actually outmoded and wrong for modern neural networks. So the right way to think of it for the kind of modern big neural networks that we build is that overfitting on the training data isn't a problem but nevertheless you need regularization to make sure that your models generalize well to independent test data. So what you'd like is for your graph not to look like this example with test error starting to head up. You'd like to have it at worst case flatline and best case still be gradually dropping. It'll always be higher than the training error but it's not actually showing a failure to generalize. So when we train big neural nets these days our big neural nets always overfit on the training data they hugely overfit on the training data. In fact in many circumstances our neural nets have so many parameters that you can continue to train them on the training data until the error on the training data is zero. They get every single example right because they can just memorize enough stuff about it to predict the right answer. But in general providing the models are regularized well those models will still also generalize well and predict well an independent data. And so for part of what we want to do for that is to work out how much to regularize. And so this lambda parameter here is the strength of regularization. So if you're making that lambda number big you're getting more regularization and if you're making it small you're getting less. And you don't want to have it be too big or else you won't fit the data well and you don't want it to be too small or else you have the problem that you don't generalize well. Okay so this is classic L2 regularization and it's a starting point but our big neural nets are sufficiently complex and have sufficiently many parameters that essentially L2 regularization doesn't cut it. So the next thing that you should know about and is a very standard good feature for building your own nets is a technique called dropout. So dropout is generally introduced as a sort of a slightly funny process that you do when training to avoid feature co-adaptation. So in dropout what you do is at the time that you're training your model that for each instance or for each batch in your training then for each neuron in the model you drop 50% of its inputs you just treat them as zero and so that you can do by sort of zeroing out elements of the sort of layers. And then at test time you don't drop any of the model weights you keep them all but actually you harble the model weights because you're now keeping twice as many things as you'd used at training data. And so effectively that little recipe prevents what's called feature co-adaptation. So you can't you can't have features that are only useful in the presence of particular other features because the model can't guarantee which features are going to be present for different examples because different features are being randomly dropped all of the time. And so effectively dropout gives you a kind of a middle ground between naive bays and a logistic regression model and a naive bays models all the weights are set independently and a logistic regression model all the weights are set in the context of all the others and here you are aware of other weights but they can randomly disappear from you. It's also related to ensemble models like model bagging because you're using different subsets of the features every time. But after all of those explanations there's actually another way of thinking about dropout which was actually developed here at Stanford as a paper by personally angling students which is to argue that really what dropout gives you is a strong regularizer that isn't a uniform regularizer like L2 that regularizes everything with an L2 last but can learn a feature dependent regularization and so that dropout is just emerged as in general the best way to do regularization for neural nets. I think you've already seen and heard this one but just have it on my slides once. If you want to have your neural networks go fast it's really essential that you make use of vectors matrices tensors and you don't do things with for loop. So here's a teeny example where I'm using time it which is a useful thing that you can use too to see where how faster neural nets run in different ways of writing it and so when I'm doing this doing these dot products here I can either do the dot product in a for loop against each word vector or I can do the dot product with a single word vector matrix and if I do it in a for loop doing each loop takes me almost a second whereas if I do it with a matrix multiply it takes me an order of magnitude less time so you should always be looking to use vectors and matrices not for loops and this is a speed up of about 10 times when you're doing things on a CPU heading forward we're going to be using GPUs and they only further exaggerate the advantages of using vectors and matrices where you'll commonly get two orders of magnitude speed up by doing things that way. Yeah so for the backward pass you are running a backward passes before on the drop down examples right so for the things that were dropped out no gradient is going through them because they weren't present they're not affecting things so in a particular batch you're only training weights for the things that aren't dropped out but then since you for each successive batch you drop out different things that over a bunch of batches you're then training all of the weights of the model and so feature dependent regularizer is meaning that how much a feature the different features can be regularized different amounts to maximize performance so back in this model every feature was just sort of being penalized by taking lambda times at squared value so this is sort of uniform regularization where the end result of this dropout style training is that you end up with some features being regularized much more strongly and some other features being regularized less strongly and how much they regularize depends on how much they're being used so you're regularizing more features that are being used less but I'm I'm not going to get through into the details of how you can understand that perspective that's that that's outside of context what I'm going to get through right now so the final bit is I just wanted to give a little bit of perspective on non-linearities in our neural nets so the first thing to remember is you have to have non-linearities so if you're building a multi-layer neural net and you've just got you know w1 x plus b1 then you put it through w2 x plus b2 and then put through w3 x well I guess they're different hidden layers so I should have said x they should be hidden one hidden two hidden three w3 hidden three plus b3 that multiple linear transformations composed so they can be just collapsed down into a single linear transformation so you don't get any power as a data representation by having multiple linear layers there's a slightly longer story there because you actually do get some interesting learning effects but I'm not going to talk about that now but standardly we have to have some kind of non-linearity to do something interesting in a deep neural network okay so there's a starting a starting point is the most classic non-linearity is the logistic often just called the sigmine non-linearity because of its s shape which we've seen before in previous lectures so this will take any real number and map it on to the range of 0 1 and that was sort of basically what people used in sort of 1980s neural nets now one disadvantage of this non-linearity is that it's moving everything into the positive space because the output was always between 0 and 1 so people then decided that for many purposes it was useful to have this variant sigmois shape of hyperbolic tan which is then being shown in the second picture now you know logistic and hyperbolic tan they sound like they're very different things but actually as you maybe remember from a math class hyperbolic tan can be represented in terms of exponentials as well and if you do a bit of math which possibly we might make you do on an assignment it's actually the case that a hyperbolic tangent is just a rescaled and shifted version of the logistic so it's really exactly the same curve just squeezed a bit so it goes now symmetrically between minus 1 and 1 well these kind of transcendental functions like hyperbolic tangent they're kind of slow and expensive to compute right even on our fast computers calculating exponentials is a bit slow so something people became interested in was well could we do things with much simpler non-linearity so what if we used a so-called hard 10h so the hard 10h at some point up to some point it just flat lines at minus 1 then it is y equals x up until 1 and then it just flat lines again and you know that seems a slightly weird thing to use because if your input is over on the left or over on the right you're sort of not getting any discrimination in everything's giving the same output but somewhat surprisingly I mean I was surprised when people started doing this these kind of models proved to be very successful and so that then led into what's proven to be kind of the most successful and generally widely used non-linearity in a lot of recent deep learning work which was what was being used in the dependency paths model I showed is what's called the rectified linear unit or value so a real U is kind of the simplest kind of non-linearity that you can imagine so if the value of x is negative it's value is 0 so effectively it's just dead it's not doing anything in the computation and if it's value of x is greater than 0 then it's just simply y equals x the value as being passed through and at first sight this might seem really really weird and how could this be useful as a non-linearity but if you sort of think a bit about how you can approximate things with piecewise linear functions very accurately you might kind of start to see how you could use this to do accurate function approximation with piecewise linear functions and that's what value units have been found to do extremely extremely successfully so logistic and tanH are still used in various places you use logistic when you want a probability output we'll see tanH's again very soon when we get to a current neural networks but they're no longer the default when making deep networks that in a lot of places the first thing you should think about trying is relu non-linearities and so in particular that why part of why they're good is that relu non networks train very quickly because you get this sort of very straightforward gradient backflow because providing you on the right hand side of it you then just getting this sort of constant gradient backflow from the slope one and so they train very quickly the somewhat surprising fact is that sort of almost the simplest non-linearity imaginable is still enough to have a very good neural network but it just is people have played around the variance of that so people have then played around with leaky relus where rather than the left hand side just going completely to zero it goes slightly negative on a vertmuch shallower slope and then there's been a parametric relu where you have an extra parameter where you learn the slope of the negative part another thing that's been used recently is this swish non-linearity which looks almost like a relu but it sort of curves down just a little bit there and starts to go up I mean I think it's fair to say that you know none of these have really proven themselves vastly superior there are papers saying I can get better results by using one of these and maybe you can but you know it's not night and day and a vast majority of work that you see around is still just using relus in many places okay a couple more things parameter initialization so in almost all cases you must must must initialize the matrices of your neural nets with small random values neural nets just don't work if you start the matrices off as zero because effectively then everything is symmetric is symmetric nothing can specialize in different ways and you then get sort of you just don't have an ability for a neural net to learn you sort of get this defective solution so standardly you're using some methods such as drawing random numbers uniformly between minus r and r for a small value r and just filling in all the parameters with that exception is with bias weights it's fine to set bias weights to zero and in some sense that's better in terms of choosing what the r value is essentially for traditional neural nets what we want to set that r range for is so that the numbers in our neural network stay you're of a reasonable size they don't get too big and they don't get too small and whether they kind of blow up or not depends on how many connections there are in the neural networks I'm looking at the fan in and fan out of connections in the neural network and so a very common initialization that you'll see in PyTorch is what's called Havier initialization named after a person who suggested that and it's working out a value of based on this fan in fan out of the layers but you can just sort of ask for it say initialize with this initialization and it will this is another area where there have been some subsequent development so around week five we'll start talking about layer normalization and if you're using layer normalization then it sort of doesn't matter the same how you initialize the weights so finally we have to train our models and I've briefly introduced the idea of stochastic gradient descent and you know the good news is that most of the time that if training your networks with stochastic gradient descent works just fine use it and you will get good results however often that requires choosing a suitable learning rate which is my final slide of tips on the next slide but there's been an enormous amount of work on optimization of neural networks and people have come up with the whole series of more sophisticated optimizers and I'm not going again to the details of optimization this class but the very loose idea is that these optimizers are adaptive in that they can kind of keep track of how much slope there was, how much gradient there is for different parameters and therefore based on that make decisions as to how much to adjust the weights when doing the gradient update rather than adjusting it by a constant amount and so in that family of methods there are methods that include eta grad, RMS, prof, atom and then a variance of atom including sparse atom, atom, w etc. The one called atom is a pretty good place to start and a lot of the time that's a good one to use and again from the perspective of PyTorch when you're initializing an optimizer you can just say please use atom and you don't actually need to know much more about it than that. If you are using simple secastic gradient descent you have to change choose a learning rate so that was the eta value of the two multiplied the gradient by for how much to adjust the weights and so I talked about that slightly how you didn't want it to be too big or your model could diverge or bounce around you didn't want it to be too small or else training could take place exceedingly slowly and you'll miss this sign deadline. How big it should be depends on all sorts of details of the model and so you sort of want to try out some different order of magnitude numbers to see what numbers seem to work well for a training stable but reasonably quickly something around 10 to the minus 3 or 10 to the minus 4 is an crazy place to start. In principle you can do fine just using a constant learning rate in SGD in practice people generally find they can get better results by decreasing learning rates as you trained so a very common recipe is that you have the learning rate after every K epox where an epoch means that you've made a pass through the entire set of training data so perhaps something like every three epochs you have the learning rate. And a final little note there in purple is when you make a pass through the data you don't want to go through the data items in the same order each time because that leads you to kind of speed have a sort of patterning of the training examples that the model will sort of fall into that periodicity of those patterns so it's best to shuffle the data before each pass through it. Okay now more sophisticated ways to set learning rates and I won't really get into those now. Fancy optimizers like Adam also have a learning rate so you still have to choose a learning rate value but it's effectively it's an initial learning rate which typically the optimizer shrinks as it runs and so you commonly want to have the number it starts off with beyond the larger size because it'll be shrinking as it goes. Okay so that's all by way of introduction and I'm now ready to start on language models and our own ends so what is language modeling? I mean as two words of English language modeling can mean just about anything but in the natural language processing literature language modeling has a very precise technical definition which you should know so language modeling is the task of predicting the word that comes next. So if you have some context like the students open there you want to be able to predict what words will come next is it their books their laptops their exams their minds and so in particular what you want to be doing is being able to give a probability that different words will occur in this context. So a language model is a probability distribution over next words given a preceding context and a system that does that is called a language model. So as a result of that you can also think of a language model as a system that assigns a probability score to a piece of text. So if we have a piece of text then we can just work out its probability according to a language model. So the probability of a sequence of tokens we can decompose via the chain rule probability of the first times probability of the second given the first etc etc and then we can work that out using our language model provides as a product of each probability of predicting the next word. Okay language models are really the cornerstone of human language technology everything that you do with computers and involves human language you are using language models. So when you're using your phone and it's suggesting whether well or badly what the next word that you probably want to type is that's a language model working to try and predict the likely next words. When the same thing happens in a Google doc and it's suggesting a next word or a next few words that's a language model. You know the main reason why the one in Google Docs works much better than the one on your phone is that for the keyboard phone models they have to be very compact so they can run quickly and not much memory. So there's sort of only mediocre language models whether something like Google Docs can do a much better language modeling job. Queer completion same thing there's a language model. And so then the question is well how do we build language models and so I briefly wanted to first again give the traditional answer since you should have at least some understanding of how NLP was done without a neural network and the traditional answer that powered speech recognition and other applications for at least two decades, three decades really was what we're called NGram language models and these were very simple but still quite effective idea. So we want to give probabilities of next words. So what we're going to work with is what are referred to as Ngrams and so Ngrams is just a chunk of N consecutive words which are usually referred to as unagrams, bi-grams, trigrams and then four grams and five grams. A horrible set of names which would offend any humanist but that's what people normally say. And so effectively what we do is just collect statistics about how often different Ngrams occur in a large amount of text and then use those to build a probability model. So the first thing we do is what's referred to as making a mark off assumption so these are also referred to as mark off models and we decide that the word and position t plus one only depends on the preceding N minus one words. So if we want to predict t plus one given the entire preceding text we actually throw away the early words and just use the preceding N minus one words as context. Well once we've made that simplification we can then just use the definition of conditional probability and say all that conditional probability is the probability of N words divided by the preceding N minus one words and so we have the probability of an Ngram over the probability of an N minus one gram. And so then how do we get these Ngram and N minus one gram probabilities? We simply take a large amount of text and some language and we count how often the different Ngrams occur. And so our crude statistical approximation starts off as the count of the Ngram over the count of the N minus one gram. So here's an example of that. Suppose we are learning a four-gram language model. Okay so we throw away all words apart from the last three words and they're our conditioning. We look in some large, we use the counts from some large training corpus and we see how often did students open their books occur, how often did students open their minds occur and then for each of those counts we divide through by the count of how often students open their occurred and that gives us our probability estimates. So for example if in the corpus students open their occurred a thousand times, students open their books occurred four hundred times, we get a probability estimate of 0.4 for books, if exams occurred a hundred times it gets 0.1 for exams. And we sort of see here already the disadvantage of having made the mark off assumption and have gotten rid of all of this earlier context which would be useful for helping us to predict. The one other point that I'll just mention that I confuse myself on is this count of the Ngram language model. So for a four-gram language model it's called a four-gram language model because in its estimation you're using four grams in the numerator and trigrams in the denominator. So you use the size of the numerator. So that terminology is different to the terminology that's used in mark-off models. So when people talk about the order of a mark-off model that refers to the amount of context you're using so this would correspond to a third order mark-off model. Yeah so someone said is this similar to a naive-based model sort of naive-based models you also estimate the probabilities just by counting. So they're they're related and they're sort of in some sense two different answers. The first difference or specialization is that naive-based models work out probabilities of words independent of their neighbors. So in one part that a naive-based language model is a unagram language model. So you're just using the counts of individual words. But the other part of a naive-based model is you're learning a different set of unagram counts for every class for your classifier. And so you've then got sort of so effectively a naive-based model is you've got class-specific unagram language models. Okay I gave this as a simple statistical model for estimating your probabilities with an engram model. You can't actually get away with just doing that because you have sparsity problems. So you know often will be the case that for many words students open their books or students opened their backpacks just never occurred in the training data. That if you think about it if you have something like 10 to the fifth different words even and you want to have then a sequence of four words are probably and they're 10 to the fifth of each. There's sort of 10 to the 20th different combinations. So unless you're seeing and it's truly astronomical amount of data most forward sequences you've never seen. So then your numerate will be zero and your probability estimate will be zero. And so that's bad. And so the commoners way of solving that is just to add a little delta to every count and then everything is non-zero and that's called smoothing. But well sometimes it's worse than that because sometimes you won't even have seen students open theirs and that's more problematic because that means our denominator if is zero and so the division will be ill-defined and we can't usefully calculate any probabilities in a context that we've never seen. And so the standard solution to that is to shorten the context and that's called back-off. So we condition only on open-there or if we still don't haven't seen open-there we'll condition only on there or we could just forget all conditioning and actually use a unagram model for our probabilities. Yeah. And so as you increase the order N of the N-gram language model these sparsity problems become worse and worse. So in the early days people normally worked with tri-gram models as it became easier to collect billions of words of text. People commonly move to five-gram models but every time you go up an order of conditioning you effectively need to be collecting orders of magnitude more data because of the size of the vocabules of human languages. There's also a problem that these models are huge. So basically have to be caught storing counts of all of these words sequences so you can work out these probabilities. And I mean that's actually had a big effect in terms of what technology is available. So in the 2000s decade up till that whenever it was 2014 that there was already Google translate using probabilistic models included language models of the N-gram language model sort. But the only way they could possibly be run is in the cloud because you needed to have these huge tables of probabilities. But now we have neural nets and you can have Google translate just actually run on your phone and that's possible because neural net models can be massively more compact than these old N-gram language models. But nevertheless before we get onto the neural models let's just sort of look at the example of how these work. So it's trivial to train an N-gram language model because you really just count how often words sequences occur in a corpus and you're ready to go. So these models can be trained in seconds. That's really good. That's not like sitting around for training neural networks. So if I train on my laptop a small language model on you know about 1.7 million words as a tri-gram model I can then ask it to generate text. If I give it a couple of words today I can then get it to sort of suggest a word that might come next. And the way I do that is the language model knows the probability distribution of things that can come next. Now there's a kind of a crude probability distribution. I mean because effectively over this relatively small corpus there were things that occurred once Italian and Emirate. There are things that occurred twice price. There were things that occurred four times company and bank. It's sort of fairly crude and rough but I never let's get probability estimates. I can then say okay based on this let's take this probability distribution and then we'll just sample an X word. So the two most likely words the sample a company or bank but we're rolling the dice and we might get any of the words that had come next. So maybe I sample price. Now I'll condition on price on the price and look up the probability distribution of what comes next the most likely thing is of. And so again I'll sample and maybe this time I'll pick up of and then I will now condition on price of and I will look up the probability distribution of words following that and I get this probability distribution and I'll sample randomly some word from it and maybe this time of sample of rare but possible one like gold and I can keep on going and I'll get out something like this. Today the price of gold per ton while production of shoe lasts and shoe industry the bank intervened just after it considered rejected an IMF demand to rebuild depleted European stocks set 30 in primary 76 cents a share. So what a just a simple tri-gram model can produce over not very much text is actually already kind of interesting like it's actually surprisingly grammatical right there are whole pieces of it while production of shoe lasts and shoe industry the bank intervened just after it considered a rejected an IMF demand it's really actually pretty good grammatical text so it's it's sort of amazing that these simple n-gram models actually can model a lot of human language. On the other hand it's not a very good piece of text it's completely incoherent and makes no sense and so to actually be able to generate text that seems like it makes sense we're going to need a considerably better language model and that's precisely what newer language models have allowed us to build as we'll see later. Okay so how can we build a newer language model and so first of all we're going to do a simple one and then we'll see where we get but to move into a current neural nets might still take us to next time. So we've going to have input sequence of words and we want a probability distribution over the next word. Well the simplest thing that we could try is to say well kind of the only tool we have so far is a window-based classifier so what we can say you know what we've done previously either for our name density recognize in lecture three or what I just showed you for the dependency parser is we have some context window we put it through a neural net and we predict something as a classifier. So before we were predicting a location but maybe instead we could reuse exactly the same technology and say we're going to have a window-based classifier so we're discarding the further away words just like in a n-gram language model but we'll feed this fixed window into a neural net so we can catenate the word embeddings we put it through a hidden layer and then we have a softmax classifier over our vocabulary and so now rather than predicting something like location or left arc and the dependency parser we're going to have a softmax over the entire vocabulary sort of like we did with the skip-gram negative sampling model in the first two lectures and so we're going to see this choice as predicting what word that comes next whether it produces laptops minds books etc. Okay so this is a fairly simple fixed window neural net classifier but this is essentially a famous early model in the use of neural nets for NLP applications so first a 2000 conference paper and then a somewhat later journal paper Yashua Benjiro and colleagues introduced precisely this model as the neural probabilistic language model and they were already able to show that this could give interesting good results for language modeling and so it wasn't a great solution for a neural language modeling but it still had value so it didn't solve the problem of allowing us to have bigger context to predict what words are going to come next it's in that way limited exactly like an end-gram language model is but it does have all the advantages of distributed representations so rather than having these counts for words sequences that are very sparse and very crude we can use distributed representative representations of words which then make predictions that semantically similar words should give similar probability distribution so the idea of that is if we use some other word here like maybe the pupils open there well maybe in our training data we'd seen sentences about students but we've never seen sentences about pupils an end-gram language model then would sort of have no idea what probabilities to use whereas a neural language model can say well pupils is kind of similar to students therefore I can predict similarly to what I would have predicted for students okay so there's now no sparsity problem we don't need to store billions of end-gram counts we simply need to store our word vectors and our W and new matrices but we still have the remaining problems that our fixed windows too small we can try and make the window larger if we do that W the W matrix gets bigger but that also points out another problem with this model not only can the window never be large enough but W is just a trained matrix and so therefore we're learning completely different weights for each position of context the word minus one position the word minus two the word minus three and the word minus four so that there's no sharing in the model as to how it treats words in different positions even though in some sense they will contribute semantic components that are at least somewhat position independent so again for those of if you sort of think back to either a naive based model or what we saw with the word-to-vec model at the beginning the word-to-vec model or naive based model completely ignores word order so it has one set of parameters regardless of what position things occur in that doesn't work well for language modeling because word order is really important in language modeling if the last word is the that's a really good predictor of there being an adjective or noun following where if the word four back is the it doesn't give you the same information so you do want to somewhat make use of word order but this model is at the opposite extreme that each position is being modeled completely independently so what we'd like to have is a neural architecture that can process an arbitrary amount of context and have more sharing of the parameters while still be sensitive to proximity and so that's the idea of recurrent neural networks and I'll say about five minutes about these today and then next time we'll return and do more about neural of recurrent neural networks so for the recurrent neural network rather than having a single hidden layer inside our classifier here that we compute each time for the recurrent neural network we have the hidden layer which often was referred to as the hidden state but we maintain it over time and we feed it back into itself so that's what the word recurrent as meaning that you're sort of feeding the hidden layer back into itself so what we do is based on the first word we compute a hidden representation kind of like before which can be used to predict the next word but then for when we want to predict what comes after the second word we not only feed in the second word we feed in the hidden layer from the previous word to have it help predict the hidden layer above the second word and so formally the way we're doing that is we're taking the hidden layer above the first word multiplying it by a matrix w and then that's going to be going in together with x2 to generate the next hidden step and so we keep on doing that at each time step so that we are kind of repeating a pattern of creating a next hidden layer based on the next input word and the previous hidden state by updating it by multiplying it by a matrix w okay so in my slide here I've still only got forwards of context because it's nice for my slide but you know in principle there could be you know any number of words of context now okay so what we're doing is so that we start off by having input vectors which can be our word vectors that we've looked up for each word so sorry yeah so we can have the one hot vectors for word identity we look up our word embedding so then we've got word embeddings for each word and then we want to compute hidden states so we need to start from somewhere h zero is the initial hidden state and h zero is normally taken as a zero vector so this is actually just initialized the zeros and so for working out the first hidden state we calculated based on the first word embedding by multiplying this embedding by a matrix w e and that gives us the first hidden state but then you know as we go on we want to apply the same formula over again so we have just two parameter matrices in the recurrent neural network one matrix for multiplying input embeddings and one matrix for updating the hidden state of the network and so for the second word from its word embedding we multiply it by the w e matrix we take the previous time steps hidden state and multiply it by the w h matrix and we use the two of those to generate the new hidden state and precisely how we generate the new hidden state is then by shown on this equation on the left so we take the previous hidden state multiply it by w h we take the input embedding multiply it by w e we sum those two we add on a learn bias rate and then we put that through a nonlinearity and although on the slide that nonlinearity is written as sigma by far the most common nonlinearity to use here actually is a tan h nonlinearity and so this is the core equation for a simple recurrent neural network and for each successive time step we're just going to keep on applying that to work out hidden states and then from those hidden states we can use them just like in our window classifier to predict what would be the next word so at any position we can take this hidden vector put it through a softmax layer which is multiplying by you matrix and adding on another bias and then making a softmax distribution out of that and that will then gives the probability distribution over next words what we saw here right this is the entire math of a simple recurrent neural network and next time I'll come back and say more about them but this is the entirety of a of what you need to know in some sense for the computation of the forward model of a simple or a current neural network so the advantages we have now is it can process a text import of any length in theory at least it can use information from any number of steps back we'll talk more about in practice how well that actually works the model size is fixed it doesn't matter how much of a past context there is all we have is our WH and W e parameters and at each time step we use exactly the same weights to update our hidden state so there's a symmetry in how different inputs are processed in producing our predictions our NNs in practice though or these simple RNNs and practice aren't perfect so a disadvantage is that they're actually kind of slow because with this recurrent computation in some sense we are sort of stuck with having to have on the outside of for loop so we can do vector matrix multiplies on the inside here but really we have to do for time to stay up equals one to N calculate these successive hidden states and so that's not a perfect neural net architecture and we'll discuss alternatives to that later and although in theory this model can access information any number of steps back in practice we find that it's pretty imperfect at doing that and that will then lead to more advanced forms of a current neural network that I'll talk about next time that are able to more effectively access past context okay I think I'll stop there for the day", "segments": [{"id": 0, "seek": 0, "start": 0.0, "end": 12.0, "text": " So we're now starting in week three with lecture five.", "tokens": [407, 321, 434, 586, 2891, 294, 1243, 1045, 365, 7991, 1732, 13], "temperature": 0.0, "avg_logprob": -0.18825183337247825, "compression_ratio": 1.5406698564593302, "no_speech_prob": 0.05559883266687393}, {"id": 1, "seek": 0, "start": 12.0, "end": 19.0, "text": " So unfortunately, the last class, I guess I really got behind and went a bit slowly.", "tokens": [407, 7015, 11, 264, 1036, 1508, 11, 286, 2041, 286, 534, 658, 2261, 293, 1437, 257, 857, 5692, 13], "temperature": 0.0, "avg_logprob": -0.18825183337247825, "compression_ratio": 1.5406698564593302, "no_speech_prob": 0.05559883266687393}, {"id": 2, "seek": 0, "start": 19.0, "end": 23.0, "text": " I guess I must just enjoy talking about natural languages too much.", "tokens": [286, 2041, 286, 1633, 445, 2103, 1417, 466, 3303, 8650, 886, 709, 13], "temperature": 0.0, "avg_logprob": -0.18825183337247825, "compression_ratio": 1.5406698564593302, "no_speech_prob": 0.05559883266687393}, {"id": 3, "seek": 0, "start": 23.0, "end": 29.0, "text": " And so I never really got to the punchline of showing how you could do good things with the new dependency parser.", "tokens": [400, 370, 286, 1128, 534, 658, 281, 264, 8135, 1889, 295, 4099, 577, 291, 727, 360, 665, 721, 365, 264, 777, 33621, 21156, 260, 13], "temperature": 0.0, "avg_logprob": -0.18825183337247825, "compression_ratio": 1.5406698564593302, "no_speech_prob": 0.05559883266687393}, {"id": 4, "seek": 2900, "start": 29.0, "end": 44.0, "text": " So I'm going to say for the first piece I'll in some sense be finishing the content of last time and talk about neural dependency parsing, which also gives us the opportunity to introduce a simple feed forward neural net classifier.", "tokens": [407, 286, 478, 516, 281, 584, 337, 264, 700, 2522, 286, 603, 294, 512, 2020, 312, 12693, 264, 2701, 295, 1036, 565, 293, 751, 466, 18161, 33621, 21156, 278, 11, 597, 611, 2709, 505, 264, 2650, 281, 5366, 257, 2199, 3154, 2128, 18161, 2533, 1508, 9902, 13], "temperature": 0.0, "avg_logprob": -0.1554894999453896, "compression_ratio": 1.763779527559055, "no_speech_prob": 8.433580660494044e-05}, {"id": 5, "seek": 2900, "start": 44.0, "end": 56.0, "text": " That will then lead into a little bit of just background things that you need to know about neural networks content because the fact of the matter is there is a bunch of stuff you need to know about neural networks.", "tokens": [663, 486, 550, 1477, 666, 257, 707, 857, 295, 445, 3678, 721, 300, 291, 643, 281, 458, 466, 18161, 9590, 2701, 570, 264, 1186, 295, 264, 1871, 307, 456, 307, 257, 3840, 295, 1507, 291, 643, 281, 458, 466, 18161, 9590, 13], "temperature": 0.0, "avg_logprob": -0.1554894999453896, "compression_ratio": 1.763779527559055, "no_speech_prob": 8.433580660494044e-05}, {"id": 6, "seek": 5600, "start": 56.0, "end": 66.0, "text": " So both of those things are getting to what's really meant to be the topic of today's lecture, which is looking at language modeling and recurrent neural networks.", "tokens": [407, 1293, 295, 729, 721, 366, 1242, 281, 437, 311, 534, 4140, 281, 312, 264, 4829, 295, 965, 311, 7991, 11, 597, 307, 1237, 412, 2856, 15983, 293, 18680, 1753, 18161, 9590, 13], "temperature": 0.0, "avg_logprob": -0.08606316386789516, "compression_ratio": 1.61139896373057, "no_speech_prob": 0.000243618807871826}, {"id": 7, "seek": 5600, "start": 66.0, "end": 77.0, "text": " And that's then going to lead into those two things are important topics that will then be talking about really for the whole of next week as well.", "tokens": [400, 300, 311, 550, 516, 281, 1477, 666, 729, 732, 721, 366, 1021, 8378, 300, 486, 550, 312, 1417, 466, 534, 337, 264, 1379, 295, 958, 1243, 382, 731, 13], "temperature": 0.0, "avg_logprob": -0.08606316386789516, "compression_ratio": 1.61139896373057, "no_speech_prob": 0.000243618807871826}, {"id": 8, "seek": 7700, "start": 77.0, "end": 89.0, "text": " So there's a couple of reminders before we get underway. The first is that you should have handed in assignment to before you join this class and in turn assignment three is out today.", "tokens": [407, 456, 311, 257, 1916, 295, 43458, 949, 321, 483, 27534, 13, 440, 700, 307, 300, 291, 820, 362, 16013, 294, 15187, 281, 949, 291, 3917, 341, 1508, 293, 294, 1261, 15187, 1045, 307, 484, 965, 13], "temperature": 0.0, "avg_logprob": -0.12404177940055115, "compression_ratio": 1.6040609137055837, "no_speech_prob": 0.00012098992738174275}, {"id": 9, "seek": 7700, "start": 89.0, "end": 99.0, "text": " And it's an assignment where you're going to build essentially the new dependency parser that I'm just about to present in PyTorch.", "tokens": [400, 309, 311, 364, 15187, 689, 291, 434, 516, 281, 1322, 4476, 264, 777, 33621, 21156, 260, 300, 286, 478, 445, 466, 281, 1974, 294, 9953, 51, 284, 339, 13], "temperature": 0.0, "avg_logprob": -0.12404177940055115, "compression_ratio": 1.6040609137055837, "no_speech_prob": 0.00012098992738174275}, {"id": 10, "seek": 9900, "start": 99.0, "end": 111.0, "text": " So part of the role of this assignment is actually to get you up to speed with PyTorch. So this assignment is highly scaffolded with lots of comments and hints about what to do.", "tokens": [407, 644, 295, 264, 3090, 295, 341, 15187, 307, 767, 281, 483, 291, 493, 281, 3073, 365, 9953, 51, 284, 339, 13, 407, 341, 15187, 307, 5405, 44094, 292, 365, 3195, 295, 3053, 293, 27271, 466, 437, 281, 360, 13], "temperature": 0.0, "avg_logprob": -0.06780408335997995, "compression_ratio": 1.768, "no_speech_prob": 8.319451444549486e-05}, {"id": 11, "seek": 9900, "start": 111.0, "end": 119.0, "text": " And so the hope is that by the time you come to the end of it, you'll feel fairly familiar and comfortable with PyTorch.", "tokens": [400, 370, 264, 1454, 307, 300, 538, 264, 565, 291, 808, 281, 264, 917, 295, 309, 11, 291, 603, 841, 6457, 4963, 293, 4619, 365, 9953, 51, 284, 339, 13], "temperature": 0.0, "avg_logprob": -0.06780408335997995, "compression_ratio": 1.768, "no_speech_prob": 8.319451444549486e-05}, {"id": 12, "seek": 9900, "start": 119.0, "end": 128.0, "text": " Don't forget there was also tutorial on PyTorch last week if you didn't catch that at the time you might want to go back and look at the video.", "tokens": [1468, 380, 2870, 456, 390, 611, 7073, 322, 9953, 51, 284, 339, 1036, 1243, 498, 291, 994, 380, 3745, 300, 412, 264, 565, 291, 1062, 528, 281, 352, 646, 293, 574, 412, 264, 960, 13], "temperature": 0.0, "avg_logprob": -0.06780408335997995, "compression_ratio": 1.768, "no_speech_prob": 8.319451444549486e-05}, {"id": 13, "seek": 12800, "start": 128.0, "end": 141.0, "text": " Another thing to mention about the assignments is that assignment three is the last assignment where our great team of TAs are happy to look at your code and sort out your bugs for you.", "tokens": [3996, 551, 281, 2152, 466, 264, 22546, 307, 300, 15187, 1045, 307, 264, 1036, 15187, 689, 527, 869, 1469, 295, 314, 10884, 366, 2055, 281, 574, 412, 428, 3089, 293, 1333, 484, 428, 15120, 337, 291, 13], "temperature": 0.0, "avg_logprob": -0.12703668629681622, "compression_ratio": 1.5460526315789473, "no_speech_prob": 0.00023846713884267956}, {"id": 14, "seek": 12800, "start": 141.0, "end": 145.0, "text": " So maybe take advantage of that but not too much.", "tokens": [407, 1310, 747, 5002, 295, 300, 457, 406, 886, 709, 13], "temperature": 0.0, "avg_logprob": -0.12703668629681622, "compression_ratio": 1.5460526315789473, "no_speech_prob": 0.00023846713884267956}, {"id": 15, "seek": 14500, "start": 145.0, "end": 158.0, "text": " But starting an assignment for assignments for five in the final project, the TAs are very happy to help in general, but it's just not going to be their job to be actually sorting out bugs for you.", "tokens": [583, 2891, 364, 15187, 337, 22546, 337, 1732, 294, 264, 2572, 1716, 11, 264, 314, 10884, 366, 588, 2055, 281, 854, 294, 2674, 11, 457, 309, 311, 445, 406, 516, 281, 312, 641, 1691, 281, 312, 767, 32411, 484, 15120, 337, 291, 13], "temperature": 0.0, "avg_logprob": -0.10073912311607683, "compression_ratio": 1.5517241379310345, "no_speech_prob": 5.2968753152526915e-05}, {"id": 16, "seek": 14500, "start": 158.0, "end": 166.0, "text": " You should be looking at your code and discussing ideas and concepts and reasons why things might not work with them.", "tokens": [509, 820, 312, 1237, 412, 428, 3089, 293, 10850, 3487, 293, 10392, 293, 4112, 983, 721, 1062, 406, 589, 365, 552, 13], "temperature": 0.0, "avg_logprob": -0.10073912311607683, "compression_ratio": 1.5517241379310345, "no_speech_prob": 5.2968753152526915e-05}, {"id": 17, "seek": 16600, "start": 166.0, "end": 182.0, "text": " Okay, so if you remember where we were last time, I'd introduced this idea of transition based dependency parsers and that these were an efficient linear time method for giving the syntactic structure of natural language text.", "tokens": [1033, 11, 370, 498, 291, 1604, 689, 321, 645, 1036, 565, 11, 286, 1116, 7268, 341, 1558, 295, 6034, 2361, 33621, 21156, 433, 293, 300, 613, 645, 364, 7148, 8213, 565, 3170, 337, 2902, 264, 23980, 19892, 3877, 295, 3303, 2856, 2487, 13], "temperature": 0.0, "avg_logprob": -0.14790560336823158, "compression_ratio": 1.3950617283950617, "no_speech_prob": 6.704741099383682e-05}, {"id": 18, "seek": 18200, "start": 182.0, "end": 199.0, "text": " And that they worked pretty well before neural nets came along and took over an old P again, but they had some disadvantages and their biggest disadvantage is that like most machine learning models of that time, they worked with indicator features.", "tokens": [400, 300, 436, 2732, 1238, 731, 949, 18161, 36170, 1361, 2051, 293, 1890, 670, 364, 1331, 430, 797, 11, 457, 436, 632, 512, 37431, 293, 641, 3880, 24292, 307, 300, 411, 881, 3479, 2539, 5245, 295, 300, 565, 11, 436, 2732, 365, 16961, 4122, 13], "temperature": 0.0, "avg_logprob": -0.19762444009586255, "compression_ratio": 1.55, "no_speech_prob": 6.0068803577451035e-05}, {"id": 19, "seek": 19900, "start": 199.0, "end": 223.0, "text": " So that means that you were specifying some condition and then checking whether it was true of a configuration. So something like the word on the top of the stack is good and it's part of speech is adjective or the next word coming up is a personal pronoun that those are conditions that would be features and conventional.", "tokens": [407, 300, 1355, 300, 291, 645, 1608, 5489, 512, 4188, 293, 550, 8568, 1968, 309, 390, 2074, 295, 257, 11694, 13, 407, 746, 411, 264, 1349, 322, 264, 1192, 295, 264, 8630, 307, 665, 293, 309, 311, 644, 295, 6218, 307, 44129, 420, 264, 958, 1349, 1348, 493, 307, 257, 2973, 14144, 300, 729, 366, 4487, 300, 576, 312, 4122, 293, 16011, 13], "temperature": 0.0, "avg_logprob": -0.113107304074871, "compression_ratio": 1.6313131313131313, "no_speech_prob": 4.063898813910782e-05}, {"id": 20, "seek": 22300, "start": 223.0, "end": 234.0, "text": " Transition based dependency parser and so what are the problems with doing that well, one problem is that those features are very sparse.", "tokens": [6531, 849, 2361, 33621, 21156, 260, 293, 370, 437, 366, 264, 2740, 365, 884, 300, 731, 11, 472, 1154, 307, 300, 729, 4122, 366, 588, 637, 11668, 13], "temperature": 0.0, "avg_logprob": -0.15484198927879333, "compression_ratio": 1.3047619047619048, "no_speech_prob": 0.00010060627391794696}, {"id": 21, "seek": 23400, "start": 234.0, "end": 259.0, "text": " So the second problem is the features are incomplete. Well, what I mean by that is depending on what words and configurations occurred in the training data, there are certain features that will exist because you sort of saw a certain word preceding a verb and certain features that just won't exist because that word never occurred before a verb and the training data.", "tokens": [407, 264, 1150, 1154, 307, 264, 4122, 366, 31709, 13, 1042, 11, 437, 286, 914, 538, 300, 307, 5413, 322, 437, 2283, 293, 31493, 11068, 294, 264, 3097, 1412, 11, 456, 366, 1629, 4122, 300, 486, 2514, 570, 291, 1333, 295, 1866, 257, 1629, 1349, 16969, 278, 257, 9595, 293, 1629, 4122, 300, 445, 1582, 380, 2514, 570, 300, 1349, 1128, 11068, 949, 257, 9595, 293, 264, 3097, 1412, 13], "temperature": 0.0, "avg_logprob": -0.14708446811985326, "compression_ratio": 1.8217821782178218, "no_speech_prob": 6.29690766800195e-05}, {"id": 22, "seek": 25900, "start": 259.0, "end": 274.0, "text": " So that's the biggest problem and opportunity for doing better with the neural dependency parser is that it turns out that in a symbolic dependency parser, computing all these features just turns out to actually be pretty expensive.", "tokens": [407, 300, 311, 264, 3880, 1154, 293, 2650, 337, 884, 1101, 365, 264, 18161, 33621, 21156, 260, 307, 300, 309, 4523, 484, 300, 294, 257, 25755, 33621, 21156, 260, 11, 15866, 439, 613, 4122, 445, 4523, 484, 281, 767, 312, 1238, 5124, 13], "temperature": 0.0, "avg_logprob": -0.11576950803716132, "compression_ratio": 1.5163398692810457, "no_speech_prob": 0.00018192453717347234}, {"id": 23, "seek": 27400, "start": 274.0, "end": 296.0, "text": " But although the actual transition system that I showed last time is fast and efficient to run, you actually have to compute all of these features and what you found was that about 95% of the parsing time of one of these models was spent just computing all of the features of every configuration.", "tokens": [583, 4878, 264, 3539, 6034, 1185, 300, 286, 4712, 1036, 565, 307, 2370, 293, 7148, 281, 1190, 11, 291, 767, 362, 281, 14722, 439, 295, 613, 4122, 293, 437, 291, 1352, 390, 300, 466, 13420, 4, 295, 264, 21156, 278, 565, 295, 472, 295, 613, 5245, 390, 4418, 445, 15866, 439, 295, 264, 4122, 295, 633, 11694, 13], "temperature": 0.0, "avg_logprob": -0.046387353251057285, "compression_ratio": 1.6174863387978142, "no_speech_prob": 2.245035648229532e-05}, {"id": 24, "seek": 29600, "start": 296.0, "end": 307.0, "text": " So that suggests that perhaps we can do better with a neural approach where we're going to learn a dense and compact feature representation. And so that's what I want to go through now.", "tokens": [407, 300, 13409, 300, 4317, 321, 393, 360, 1101, 365, 257, 18161, 3109, 689, 321, 434, 516, 281, 1466, 257, 18011, 293, 14679, 4111, 10290, 13, 400, 370, 300, 311, 437, 286, 528, 281, 352, 807, 586, 13], "temperature": 0.0, "avg_logprob": -0.08806040173485166, "compression_ratio": 1.3703703703703705, "no_speech_prob": 2.467250669724308e-05}, {"id": 25, "seek": 30700, "start": 307.0, "end": 336.0, "text": " So this time we're still going to have exactly the same kind of configuration of a stack and a buffer and running exactly the same transition sequence except this time rather than representing the configuration the stack and the buffer by having several million symbolic features, we're instead going to summarize this configuration as a dense vector of dimensionality perhaps approximately a thousand.", "tokens": [407, 341, 565, 321, 434, 920, 516, 281, 362, 2293, 264, 912, 733, 295, 11694, 295, 257, 8630, 293, 257, 21762, 293, 2614, 2293, 264, 912, 6034, 8310, 3993, 341, 565, 2831, 813, 13460, 264, 11694, 264, 8630, 293, 264, 21762, 538, 1419, 2940, 2459, 25755, 4122, 11, 321, 434, 2602, 516, 281, 20858, 341, 11694, 382, 257, 18011, 8062, 295, 10139, 1860, 4317, 10447, 257, 4714, 13], "temperature": 0.0, "avg_logprob": -0.09432221121258205, "compression_ratio": 1.7709251101321586, "no_speech_prob": 1.4731355804542545e-05}, {"id": 26, "seek": 33600, "start": 336.0, "end": 342.0, "text": " And now neural approach is going to learn this dense compact feature representation.", "tokens": [400, 586, 18161, 3109, 307, 516, 281, 1466, 341, 18011, 14679, 4111, 10290, 13], "temperature": 0.0, "avg_logprob": -0.2134513693340754, "compression_ratio": 1.4619565217391304, "no_speech_prob": 0.00019962579244747758}, {"id": 27, "seek": 33600, "start": 342.0, "end": 358.0, "text": " And so quite explicitly what I'm going to show you now briefly and what you're going to implement is essentially the neural dependency parser that was developed by d'antichern in 2014.", "tokens": [400, 370, 1596, 20803, 437, 286, 478, 516, 281, 855, 291, 586, 10515, 293, 437, 291, 434, 516, 281, 4445, 307, 4476, 264, 18161, 33621, 21156, 260, 300, 390, 4743, 538, 274, 6, 394, 480, 1248, 294, 8227, 13], "temperature": 0.0, "avg_logprob": -0.2134513693340754, "compression_ratio": 1.4619565217391304, "no_speech_prob": 0.00019962579244747758}, {"id": 28, "seek": 35800, "start": 358.0, "end": 385.0, "text": " And to skip to the advertisement right at the beginning as to how this works so well, these are the kind of results that you got from it using the measures that I introduced at the last time the unlabeled attachment score, whether you attached dependencies correctly to the right word and the labeled attachment scores to whether you also get the type of grammatical relation of that dependency correct.", "tokens": [400, 281, 10023, 281, 264, 31370, 558, 412, 264, 2863, 382, 281, 577, 341, 1985, 370, 731, 11, 613, 366, 264, 733, 295, 3542, 300, 291, 658, 490, 309, 1228, 264, 8000, 300, 286, 7268, 412, 264, 1036, 565, 264, 32118, 18657, 292, 19431, 6175, 11, 1968, 291, 8570, 36606, 8944, 281, 264, 558, 1349, 293, 264, 21335, 19431, 13444, 281, 1968, 291, 611, 483, 264, 2010, 295, 17570, 267, 804, 9721, 295, 300, 33621, 3006, 13], "temperature": 0.0, "avg_logprob": -0.09349665229703173, "compression_ratio": 1.8153153153153154, "no_speech_prob": 3.3123284083558246e-05}, {"id": 29, "seek": 38500, "start": 385.0, "end": 397.0, "text": " And so essentially this chin and manning parser gave a neural version of something like a transition based dependency parser like malt parser in yellow.", "tokens": [400, 370, 4476, 341, 14210, 293, 587, 773, 21156, 260, 2729, 257, 18161, 3037, 295, 746, 411, 257, 6034, 2361, 33621, 21156, 260, 411, 45654, 21156, 260, 294, 5566, 13], "temperature": 0.0, "avg_logprob": -0.21528332373675177, "compression_ratio": 1.3571428571428572, "no_speech_prob": 3.821437348960899e-05}, {"id": 30, "seek": 39700, "start": 397.0, "end": 413.0, "text": " And the interesting thing was that taking advantage of a neural classifier and ways that I'm about to explain that that could produce something that was about 2% more accurate than the symbolic dependency parser.", "tokens": [400, 264, 1880, 551, 390, 300, 1940, 5002, 295, 257, 18161, 1508, 9902, 293, 2098, 300, 286, 478, 466, 281, 2903, 300, 300, 727, 5258, 746, 300, 390, 466, 568, 4, 544, 8559, 813, 264, 25755, 33621, 21156, 260, 13], "temperature": 0.0, "avg_logprob": -0.10534641959450462, "compression_ratio": 1.4324324324324325, "no_speech_prob": 3.7041430914541706e-05}, {"id": 31, "seek": 41300, "start": 413.0, "end": 427.0, "text": " And because of the fact that it's not doing all of the symbolic feature computation, despite the fact that you might think at first that there's a lot of real number math and matrix vector multiplies in a neural dependency parser.", "tokens": [400, 570, 295, 264, 1186, 300, 309, 311, 406, 884, 439, 295, 264, 25755, 4111, 24903, 11, 7228, 264, 1186, 300, 291, 1062, 519, 412, 700, 300, 456, 311, 257, 688, 295, 957, 1230, 5221, 293, 8141, 8062, 12788, 530, 294, 257, 18161, 33621, 21156, 260, 13], "temperature": 0.0, "avg_logprob": -0.09778710958119985, "compression_ratio": 1.74, "no_speech_prob": 3.759239552891813e-05}, {"id": 32, "seek": 41300, "start": 427.0, "end": 436.0, "text": " It actually ran noticeably faster than the symbolic dependency parser because it didn't have all feature computation.", "tokens": [467, 767, 5872, 3449, 1188, 4663, 813, 264, 25755, 33621, 21156, 260, 570, 309, 994, 380, 362, 439, 4111, 24903, 13], "temperature": 0.0, "avg_logprob": -0.09778710958119985, "compression_ratio": 1.74, "no_speech_prob": 3.759239552891813e-05}, {"id": 33, "seek": 43600, "start": 436.0, "end": 462.0, "text": " The other major approach to dependency parsing that I'm also showing here and I'll get back to at the end is what's referred to as graph based dependency parsing and so that's a different approach to dependency parsing and so these are two symbolic graph based dependency parsers and in the pre neural world, they were somewhat more accurate than the transition based parsers as you could see.", "tokens": [440, 661, 2563, 3109, 281, 33621, 21156, 278, 300, 286, 478, 611, 4099, 510, 293, 286, 603, 483, 646, 281, 412, 264, 917, 307, 437, 311, 10839, 281, 382, 4295, 2361, 33621, 21156, 278, 293, 370, 300, 311, 257, 819, 3109, 281, 33621, 21156, 278, 293, 370, 613, 366, 732, 25755, 4295, 2361, 33621, 21156, 433, 293, 294, 264, 659, 18161, 1002, 11, 436, 645, 8344, 544, 8559, 813, 264, 6034, 2361, 21156, 433, 382, 291, 727, 536, 13], "temperature": 0.0, "avg_logprob": -0.10192154114504895, "compression_ratio": 1.8985507246376812, "no_speech_prob": 3.586667662602849e-05}, {"id": 34, "seek": 46200, "start": 462.0, "end": 483.0, "text": " But on the other hand, they were close to two orders of magnitude slower. And so essentially with the term manning parser, we were able to provide something that was basically as accurate as the best graph based dependency parsers, which were the best dependency parsers while operating about two orders of magnitude more quickly.", "tokens": [583, 322, 264, 661, 1011, 11, 436, 645, 1998, 281, 732, 9470, 295, 15668, 14009, 13, 400, 370, 4476, 365, 264, 1433, 587, 773, 21156, 260, 11, 321, 645, 1075, 281, 2893, 746, 300, 390, 1936, 382, 8559, 382, 264, 1151, 4295, 2361, 33621, 21156, 433, 11, 597, 645, 264, 1151, 33621, 21156, 433, 1339, 7447, 466, 732, 9470, 295, 15668, 544, 2661, 13], "temperature": 0.0, "avg_logprob": -0.1317914794473087, "compression_ratio": 1.7098445595854923, "no_speech_prob": 0.00020017281349282712}, {"id": 35, "seek": 48300, "start": 483.0, "end": 495.0, "text": " And how did we do it? It was actually a very straightforward implementation, which is part of what makes it great for doing for assignment three.", "tokens": [400, 577, 630, 321, 360, 309, 30, 467, 390, 767, 257, 588, 15325, 11420, 11, 597, 307, 644, 295, 437, 1669, 309, 869, 337, 884, 337, 15187, 1045, 13], "temperature": 0.0, "avg_logprob": -0.1404925115180738, "compression_ratio": 1.2393162393162394, "no_speech_prob": 0.00017318838217761368}, {"id": 36, "seek": 49500, "start": 495.0, "end": 513.0, "text": " But this is how we did it and we got wins. So the first win, which is what we've already talked about extensively starting in week one is to make use of distributed representations. So we represent each word as a word embedding and you've had a lot of experience with that already.", "tokens": [583, 341, 307, 577, 321, 630, 309, 293, 321, 658, 10641, 13, 407, 264, 700, 1942, 11, 597, 307, 437, 321, 600, 1217, 2825, 466, 32636, 2891, 294, 1243, 472, 307, 281, 652, 764, 295, 12631, 33358, 13, 407, 321, 2906, 1184, 1349, 382, 257, 1349, 12240, 3584, 293, 291, 600, 632, 257, 688, 295, 1752, 365, 300, 1217, 13], "temperature": 0.0, "avg_logprob": -0.06822618097066879, "compression_ratio": 1.510752688172043, "no_speech_prob": 5.031285763834603e-05}, {"id": 37, "seek": 51300, "start": 513.0, "end": 526.0, "text": " And so that means when words weren't seen in a particular configuration, we still know what they're like because they'll be well have seen similar words in the correct configuration.", "tokens": [400, 370, 300, 1355, 562, 2283, 4999, 380, 1612, 294, 257, 1729, 11694, 11, 321, 920, 458, 437, 436, 434, 411, 570, 436, 603, 312, 731, 362, 1612, 2531, 2283, 294, 264, 3006, 11694, 13], "temperature": 0.0, "avg_logprob": -0.10128149619469276, "compression_ratio": 1.4330708661417322, "no_speech_prob": 3.3616939617786556e-05}, {"id": 38, "seek": 52600, "start": 526.0, "end": 544.0, "text": " But we don't stop only with word embeddings. The other things that are central to our dependency parser are the parts of speech of words and the dependency labels. And so what we decided to do is that although those are much smaller sets.", "tokens": [583, 321, 500, 380, 1590, 787, 365, 1349, 12240, 29432, 13, 440, 661, 721, 300, 366, 5777, 281, 527, 33621, 21156, 260, 366, 264, 3166, 295, 6218, 295, 2283, 293, 264, 33621, 16949, 13, 400, 370, 437, 321, 3047, 281, 360, 307, 300, 4878, 729, 366, 709, 4356, 6352, 13], "temperature": 0.0, "avg_logprob": -0.06578114297654894, "compression_ratio": 1.5063291139240507, "no_speech_prob": 2.9747361622867174e-05}, {"id": 39, "seek": 54400, "start": 544.0, "end": 556.0, "text": " So the dependency labels are about 40 in number and the parts of speech are around that order of magnitude sometimes less sometimes more than even within those sets of categories.", "tokens": [407, 264, 33621, 16949, 366, 466, 3356, 294, 1230, 293, 264, 3166, 295, 6218, 366, 926, 300, 1668, 295, 15668, 2171, 1570, 2171, 544, 813, 754, 1951, 729, 6352, 295, 10479, 13], "temperature": 0.0, "avg_logprob": -0.18469039599100748, "compression_ratio": 1.4206349206349207, "no_speech_prob": 9.597721509635448e-05}, {"id": 40, "seek": 55600, "start": 556.0, "end": 573.0, "text": " There are ones that are very strongly related. So we also adopted distributed representations for them. So for example, there might be parts of speech for single nouns and plural nouns. And basically most of the time they behave similarly. And there are", "tokens": [821, 366, 2306, 300, 366, 588, 10613, 4077, 13, 407, 321, 611, 12175, 12631, 33358, 337, 552, 13, 407, 337, 1365, 11, 456, 1062, 312, 3166, 295, 6218, 337, 2167, 48184, 293, 25377, 48184, 13, 400, 1936, 881, 295, 264, 565, 436, 15158, 14138, 13, 400, 456, 366], "temperature": 0.0, "avg_logprob": -0.13119268417358398, "compression_ratio": 1.505952380952381, "no_speech_prob": 5.6461944041075185e-05}, {"id": 41, "seek": 57300, "start": 573.0, "end": 588.0, "text": " some kind of magic type of modifiers and numerical modifiers. So these are just numbers like 3, 4, 5. And again, a lot of the time they behave the same that you have both three cows and brown cows.", "tokens": [512, 733, 295, 5585, 2010, 295, 1072, 23463, 293, 29054, 1072, 23463, 13, 407, 613, 366, 445, 3547, 411, 805, 11, 1017, 11, 1025, 13, 400, 797, 11, 257, 688, 295, 264, 565, 436, 15158, 264, 912, 300, 291, 362, 1293, 1045, 19148, 293, 6292, 19148, 13], "temperature": 0.0, "avg_logprob": -0.28496287850772634, "compression_ratio": 1.4071428571428573, "no_speech_prob": 3.425105387577787e-05}, {"id": 42, "seek": 58800, "start": 588.0, "end": 604.0, "text": " So everything is going to be represented in the distributed representation. So at that point, we have exactly the same kind of configuration where we have our stack, our buffer, and we've started to build some arcs.", "tokens": [407, 1203, 307, 516, 281, 312, 10379, 294, 264, 12631, 10290, 13, 407, 412, 300, 935, 11, 321, 362, 2293, 264, 912, 733, 295, 11694, 689, 321, 362, 527, 8630, 11, 527, 21762, 11, 293, 321, 600, 1409, 281, 1322, 512, 10346, 82, 13], "temperature": 0.0, "avg_logprob": -0.10279303789138794, "compression_ratio": 1.4625850340136055, "no_speech_prob": 6.496434070868418e-05}, {"id": 43, "seek": 60400, "start": 604.0, "end": 619.0, "text": " So the classification decisions of the next transition are going to be made out of a few elements of this configuration. So we're looking at the top thing on the stack, the thing that second on the stack, the first word on the buffer.", "tokens": [407, 264, 21538, 5327, 295, 264, 958, 6034, 366, 516, 281, 312, 1027, 484, 295, 257, 1326, 4959, 295, 341, 11694, 13, 407, 321, 434, 1237, 412, 264, 1192, 551, 322, 264, 8630, 11, 264, 551, 300, 1150, 322, 264, 8630, 11, 264, 700, 1349, 322, 264, 21762, 13], "temperature": 0.0, "avg_logprob": -0.06584176477396263, "compression_ratio": 1.6137931034482758, "no_speech_prob": 6.083835614845157e-05}, {"id": 44, "seek": 61900, "start": 619.0, "end": 636.0, "text": " And then we actually added in some additional features that are then to the extent that we've already built arcs for words on the stack that we can be looking at the dependence on the left and right of those words that are on the stack that are already in the sets of arcs.", "tokens": [400, 550, 321, 767, 3869, 294, 512, 4497, 4122, 300, 366, 550, 281, 264, 8396, 300, 321, 600, 1217, 3094, 10346, 82, 337, 2283, 322, 264, 8630, 300, 321, 393, 312, 1237, 412, 264, 31704, 322, 264, 1411, 293, 558, 295, 729, 2283, 300, 366, 322, 264, 8630, 300, 366, 1217, 294, 264, 6352, 295, 10346, 82, 13], "temperature": 0.0, "avg_logprob": -0.03888301311000701, "compression_ratio": 1.7278481012658229, "no_speech_prob": 5.295434675645083e-05}, {"id": 45, "seek": 63600, "start": 636.0, "end": 658.0, "text": " And so for each of those things, there is a word, there is a part of speech. And for some of them, there is a dependency where it's already connected up to something else. So for example, the left corner of S2 here has an insub-dependency back to the second thing on the stack.", "tokens": [400, 370, 337, 1184, 295, 729, 721, 11, 456, 307, 257, 1349, 11, 456, 307, 257, 644, 295, 6218, 13, 400, 337, 512, 295, 552, 11, 456, 307, 257, 33621, 689, 309, 311, 1217, 4582, 493, 281, 746, 1646, 13, 407, 337, 1365, 11, 264, 1411, 4538, 295, 318, 17, 510, 575, 364, 1028, 836, 12, 36763, 3020, 646, 281, 264, 1150, 551, 322, 264, 8630, 13], "temperature": 0.0, "avg_logprob": -0.13892701645972025, "compression_ratio": 1.6390532544378698, "no_speech_prob": 3.373077561263926e-05}, {"id": 46, "seek": 65800, "start": 658.0, "end": 675.0, "text": " So we can take these elements of the configuration and can look up the embedding of each one. So we have word embeddings, part of speech embeddings, and dependency embeddings, and just concatenate them all together, kind of like we did before with the window classifier.", "tokens": [407, 321, 393, 747, 613, 4959, 295, 264, 11694, 293, 393, 574, 493, 264, 12240, 3584, 295, 1184, 472, 13, 407, 321, 362, 1349, 12240, 29432, 11, 644, 295, 6218, 12240, 29432, 11, 293, 33621, 12240, 29432, 11, 293, 445, 1588, 7186, 473, 552, 439, 1214, 11, 733, 295, 411, 321, 630, 949, 365, 264, 4910, 1508, 9902, 13], "temperature": 0.0, "avg_logprob": -0.11223009035184786, "compression_ratio": 1.685, "no_speech_prob": 5.3859319450566545e-05}, {"id": 47, "seek": 65800, "start": 675.0, "end": 680.0, "text": " And that will give us a newer representation of the configuration.", "tokens": [400, 300, 486, 976, 505, 257, 17628, 10290, 295, 264, 11694, 13], "temperature": 0.0, "avg_logprob": -0.11223009035184786, "compression_ratio": 1.685, "no_speech_prob": 5.3859319450566545e-05}, {"id": 48, "seek": 68000, "start": 680.0, "end": 694.0, "text": " Well, there's a second reason why we can hope to win by using a deep learning classifier to predict the next transition. And we haven't really said much about that yet. So I just wanted to detour and say a little bit more about that.", "tokens": [1042, 11, 456, 311, 257, 1150, 1778, 983, 321, 393, 1454, 281, 1942, 538, 1228, 257, 2452, 2539, 1508, 9902, 281, 6069, 264, 958, 6034, 13, 400, 321, 2378, 380, 534, 848, 709, 466, 300, 1939, 13, 407, 286, 445, 1415, 281, 1141, 396, 293, 584, 257, 707, 857, 544, 466, 300, 13], "temperature": 0.0, "avg_logprob": -0.08882179594876473, "compression_ratio": 1.420731707317073, "no_speech_prob": 0.00012525053170975298}, {"id": 49, "seek": 69400, "start": 694.0, "end": 714.0, "text": " So the simplest kind of classifier that's close to what we've been talking about in neural models is a softmax classifier. So that if we have de-dimensional vectors X and we have Y classes to assign things to.", "tokens": [407, 264, 22811, 733, 295, 1508, 9902, 300, 311, 1998, 281, 437, 321, 600, 668, 1417, 466, 294, 18161, 5245, 307, 257, 2787, 41167, 1508, 9902, 13, 407, 300, 498, 321, 362, 368, 12, 18759, 18875, 1783, 293, 321, 362, 398, 5359, 281, 6269, 721, 281, 13], "temperature": 0.0, "avg_logprob": -0.13901304731182024, "compression_ratio": 1.4513888888888888, "no_speech_prob": 8.342180808540434e-05}, {"id": 50, "seek": 71400, "start": 714.0, "end": 734.0, "text": " Also Y is an element of a set of C classes to assign things to then we can build a softmax classifier using the softmax distribution that we've seen before where we decide the classes based on having a weight matrix that's C by D.", "tokens": [2743, 398, 307, 364, 4478, 295, 257, 992, 295, 383, 5359, 281, 6269, 721, 281, 550, 321, 393, 1322, 257, 2787, 41167, 1508, 9902, 1228, 264, 2787, 41167, 7316, 300, 321, 600, 1612, 949, 689, 321, 4536, 264, 5359, 2361, 322, 1419, 257, 3364, 8141, 300, 311, 383, 538, 413, 13], "temperature": 0.0, "avg_logprob": -0.12837517478249288, "compression_ratio": 1.5032679738562091, "no_speech_prob": 0.0001353391126031056}, {"id": 51, "seek": 73400, "start": 734.0, "end": 745.0, "text": " And we train on supervised data, the values of this W weight matrix to minimize our negative log likelihood loss that we've seen before.", "tokens": [400, 321, 3847, 322, 46533, 1412, 11, 264, 4190, 295, 341, 343, 3364, 8141, 281, 17522, 527, 3671, 3565, 22119, 4470, 300, 321, 600, 1612, 949, 13], "temperature": 0.0, "avg_logprob": -0.20362659922817297, "compression_ratio": 1.439306358381503, "no_speech_prob": 5.3829448006581515e-05}, {"id": 52, "seek": 73400, "start": 745.0, "end": 752.0, "text": " A loss does also commonly refer to as cross entropy loss a term that you'll see in pie torch among other places.", "tokens": [316, 4470, 775, 611, 12719, 2864, 281, 382, 3278, 30867, 4470, 257, 1433, 300, 291, 603, 536, 294, 1730, 27822, 3654, 661, 3190, 13], "temperature": 0.0, "avg_logprob": -0.20362659922817297, "compression_ratio": 1.439306358381503, "no_speech_prob": 5.3829448006581515e-05}, {"id": 53, "seek": 75200, "start": 752.0, "end": 775.0, "text": " So that is a straightforward machine learning classifier. And if you've done two twenty nine you've seen softmax classifiers. But a simple softmax classifier like this shares with most traditional machine learning classifiers and models include naive base models support vector machines logistic regression.", "tokens": [407, 300, 307, 257, 15325, 3479, 2539, 1508, 9902, 13, 400, 498, 291, 600, 1096, 732, 7699, 4949, 291, 600, 1612, 2787, 41167, 1508, 23463, 13, 583, 257, 2199, 2787, 41167, 1508, 9902, 411, 341, 12182, 365, 881, 5164, 3479, 2539, 1508, 23463, 293, 5245, 4090, 29052, 3096, 5245, 1406, 8062, 8379, 3565, 3142, 24590, 13], "temperature": 0.0, "avg_logprob": -0.1700039227803548, "compression_ratio": 1.6868131868131868, "no_speech_prob": 7.714082312304527e-05}, {"id": 54, "seek": 77500, "start": 775.0, "end": 785.0, "text": " But at the end of the day, they're not very powerful classifiers. They're classifiers that only give linear decision boundaries. And so this can be quite limiting.", "tokens": [583, 412, 264, 917, 295, 264, 786, 11, 436, 434, 406, 588, 4005, 1508, 23463, 13, 814, 434, 1508, 23463, 300, 787, 976, 8213, 3537, 13180, 13, 400, 370, 341, 393, 312, 1596, 22083, 13], "temperature": 0.0, "avg_logprob": -0.08008574330529501, "compression_ratio": 1.5780590717299579, "no_speech_prob": 9.60714096436277e-05}, {"id": 55, "seek": 77500, "start": 785.0, "end": 798.0, "text": " So if you have a difficult problem like the one I'm indicating in the picture in the bottom left. Well, there's just no way you can divide the green points from the red points by simply drawing a straight line.", "tokens": [407, 498, 291, 362, 257, 2252, 1154, 411, 264, 472, 286, 478, 25604, 294, 264, 3036, 294, 264, 2767, 1411, 13, 1042, 11, 456, 311, 445, 572, 636, 291, 393, 9845, 264, 3092, 2793, 490, 264, 2182, 2793, 538, 2935, 6316, 257, 2997, 1622, 13], "temperature": 0.0, "avg_logprob": -0.08008574330529501, "compression_ratio": 1.5780590717299579, "no_speech_prob": 9.60714096436277e-05}, {"id": 56, "seek": 79800, "start": 798.0, "end": 812.0, "text": " So you're going to have a quite imperfect classifier. So the second big win of neural classifiers is that they can be much more powerful because they can provide nonlinear classification.", "tokens": [407, 291, 434, 516, 281, 362, 257, 1596, 26714, 1508, 9902, 13, 407, 264, 1150, 955, 1942, 295, 18161, 1508, 23463, 307, 300, 436, 393, 312, 709, 544, 4005, 570, 436, 393, 2893, 2107, 28263, 21538, 13], "temperature": 0.0, "avg_logprob": -0.062495242981683644, "compression_ratio": 1.7782805429864252, "no_speech_prob": 6.705558917019516e-05}, {"id": 57, "seek": 79800, "start": 812.0, "end": 825.0, "text": " So rather than only being able to do something like in the left picture, we can come up with classifiers that do something like in the right picture and therefore can separate the green and the red points.", "tokens": [407, 2831, 813, 787, 885, 1075, 281, 360, 746, 411, 294, 264, 1411, 3036, 11, 321, 393, 808, 493, 365, 1508, 23463, 300, 360, 746, 411, 294, 264, 558, 3036, 293, 4412, 393, 4994, 264, 3092, 293, 264, 2182, 2793, 13], "temperature": 0.0, "avg_logprob": -0.062495242981683644, "compression_ratio": 1.7782805429864252, "no_speech_prob": 6.705558917019516e-05}, {"id": 58, "seek": 82500, "start": 825.0, "end": 836.0, "text": " As an aside, I'm these pictures I've taken from Andrea Caparti's ComvNet.js software, which is a kind of a fun little tool to play around with if you've got a bit of spare time.", "tokens": [1018, 364, 7359, 11, 286, 478, 613, 5242, 286, 600, 2726, 490, 24215, 8363, 446, 72, 311, 2432, 85, 31890, 13, 25530, 4722, 11, 597, 307, 257, 733, 295, 257, 1019, 707, 2290, 281, 862, 926, 365, 498, 291, 600, 658, 257, 857, 295, 13798, 565, 13], "temperature": 0.0, "avg_logprob": -0.177614979121996, "compression_ratio": 1.5644444444444445, "no_speech_prob": 8.213637192966416e-05}, {"id": 59, "seek": 82500, "start": 836.0, "end": 851.0, "text": " And so there's something subtle going on here is because our more powerful neural net classifiers at the end of the day, what they have at the top of them is a softmax layer.", "tokens": [400, 370, 456, 311, 746, 13743, 516, 322, 510, 307, 570, 527, 544, 4005, 18161, 2533, 1508, 23463, 412, 264, 917, 295, 264, 786, 11, 437, 436, 362, 412, 264, 1192, 295, 552, 307, 257, 2787, 41167, 4583, 13], "temperature": 0.0, "avg_logprob": -0.177614979121996, "compression_ratio": 1.5644444444444445, "no_speech_prob": 8.213637192966416e-05}, {"id": 60, "seek": 85100, "start": 851.0, "end": 863.0, "text": " So this softmax class layer is indeed a linear classifier and it's still a linear classifier. But what they have below that is other layers of neural net.", "tokens": [407, 341, 2787, 41167, 1508, 4583, 307, 6451, 257, 8213, 1508, 9902, 293, 309, 311, 920, 257, 8213, 1508, 9902, 13, 583, 437, 436, 362, 2507, 300, 307, 661, 7914, 295, 18161, 2533, 13], "temperature": 0.0, "avg_logprob": -0.13079866610075297, "compression_ratio": 1.4, "no_speech_prob": 8.210880332626402e-05}, {"id": 61, "seek": 86300, "start": 863.0, "end": 891.0, "text": " And so effectively what happens is that the classification decisions are linear as far as the top softmax is concerned, but nonlinear in the original representation space. So precisely what a neural net can do is warp the space around and move the representation of data points to provide something that at the end of the day can be classified by linear classifier.", "tokens": [400, 370, 8659, 437, 2314, 307, 300, 264, 21538, 5327, 366, 8213, 382, 1400, 382, 264, 1192, 2787, 41167, 307, 5922, 11, 457, 2107, 28263, 294, 264, 3380, 10290, 1901, 13, 407, 13402, 437, 257, 18161, 2533, 393, 360, 307, 36030, 264, 1901, 926, 293, 1286, 264, 10290, 295, 1412, 2793, 281, 2893, 746, 300, 412, 264, 917, 295, 264, 786, 393, 312, 20627, 538, 8213, 1508, 9902, 13], "temperature": 0.0, "avg_logprob": -0.06335860082547959, "compression_ratio": 1.7298578199052133, "no_speech_prob": 8.93322066986002e-06}, {"id": 62, "seek": 89100, "start": 891.0, "end": 905.0, "text": " And so that's what a simple feed forward neural network multi class classifier does. So it starts with an input representation. So these are is some dense representation of the input.", "tokens": [400, 370, 300, 311, 437, 257, 2199, 3154, 2128, 18161, 3209, 4825, 1508, 1508, 9902, 775, 13, 407, 309, 3719, 365, 364, 4846, 10290, 13, 407, 613, 366, 307, 512, 18011, 10290, 295, 264, 4846, 13], "temperature": 0.0, "avg_logprob": -0.13594610691070558, "compression_ratio": 1.4409448818897639, "no_speech_prob": 0.0002412941394140944}, {"id": 63, "seek": 90500, "start": 905.0, "end": 930.0, "text": " It puts it through a hidden layer age with a matrix multiply followed by nonlinearity. So that matrix multiply can transform the space and map things around. And so then the output of that we can then put into a softmax layer and get out softmax probabilities from which we make a classification decisions.", "tokens": [467, 8137, 309, 807, 257, 7633, 4583, 3205, 365, 257, 8141, 12972, 6263, 538, 2107, 1889, 17409, 13, 407, 300, 8141, 12972, 393, 4088, 264, 1901, 293, 4471, 721, 926, 13, 400, 370, 550, 264, 5598, 295, 300, 321, 393, 550, 829, 666, 257, 2787, 41167, 4583, 293, 483, 484, 2787, 41167, 33783, 490, 597, 321, 652, 257, 21538, 5327, 13], "temperature": 0.0, "avg_logprob": -0.09588107329148512, "compression_ratio": 1.59375, "no_speech_prob": 3.94179041904863e-05}, {"id": 64, "seek": 93000, "start": 930.0, "end": 944.0, "text": " And to the extent that our probabilities don't assign one to the correct class, we then get some log loss or cross entropy error, which we back propagate towards the parameters and embeddings of our model.", "tokens": [400, 281, 264, 8396, 300, 527, 33783, 500, 380, 6269, 472, 281, 264, 3006, 1508, 11, 321, 550, 483, 512, 3565, 4470, 420, 3278, 30867, 6713, 11, 597, 321, 646, 48256, 3030, 264, 9834, 293, 12240, 29432, 295, 527, 2316, 13], "temperature": 0.0, "avg_logprob": -0.07217733065287273, "compression_ratio": 1.4236111111111112, "no_speech_prob": 4.189716491964646e-05}, {"id": 65, "seek": 94400, "start": 944.0, "end": 963.0, "text": " And as the learning that goes on via back propagation, we increasingly well learn parameters of this hidden layer of the model, which learn to re represent the input, they move the inputs around in an intermediate hidden vector space.", "tokens": [400, 382, 264, 2539, 300, 1709, 322, 5766, 646, 38377, 11, 321, 12980, 731, 1466, 9834, 295, 341, 7633, 4583, 295, 264, 2316, 11, 597, 1466, 281, 319, 2906, 264, 4846, 11, 436, 1286, 264, 15743, 926, 294, 364, 19376, 7633, 8062, 1901, 13], "temperature": 0.0, "avg_logprob": -0.13578529159228006, "compression_ratio": 1.5096774193548388, "no_speech_prob": 1.4733988791704178e-05}, {"id": 66, "seek": 96300, "start": 963.0, "end": 977.0, "text": " And so this is the easy classified with what at the end of the day is the linear softmax. So this is basically the whole of a simple feed forward neural network multi class classifier.", "tokens": [400, 370, 341, 307, 264, 1858, 1508, 2587, 365, 437, 412, 264, 917, 295, 264, 786, 307, 264, 8213, 2787, 41167, 13, 407, 341, 307, 1936, 264, 1379, 295, 257, 2199, 3154, 2128, 18161, 3209, 4825, 1508, 1508, 9902, 13], "temperature": 0.0, "avg_logprob": -0.2717752890153365, "compression_ratio": 1.4603174603174602, "no_speech_prob": 3.762154301512055e-05}, {"id": 67, "seek": 97700, "start": 977.0, "end": 1002.0, "text": " And if we had something like a visual signal, we just sort of feed straight in here real numbers and we've been done. But normally with human language material, we actually effectively have one more layer that we're feeding in before that because really below this dense input layer, we actually have one hot vectors for what words or parts of speech were involved.", "tokens": [400, 498, 321, 632, 746, 411, 257, 5056, 6358, 11, 321, 445, 1333, 295, 3154, 2997, 294, 510, 957, 3547, 293, 321, 600, 668, 1096, 13, 583, 5646, 365, 1952, 2856, 2527, 11, 321, 767, 8659, 362, 472, 544, 4583, 300, 321, 434, 12919, 294, 949, 300, 570, 534, 2507, 341, 18011, 4846, 4583, 11, 321, 767, 362, 472, 2368, 18875, 337, 437, 2283, 420, 3166, 295, 6218, 645, 3288, 13], "temperature": 0.0, "avg_logprob": -0.0851240603129069, "compression_ratio": 1.6079295154185023, "no_speech_prob": 3.16771911457181e-05}, {"id": 68, "seek": 100200, "start": 1002.0, "end": 1013.0, "text": " And we're doing a lookup process, which you can think of as one more matrix multiply to convert the one hot features into our dense input layer.", "tokens": [400, 321, 434, 884, 257, 574, 1010, 1399, 11, 597, 291, 393, 519, 295, 382, 472, 544, 8141, 12972, 281, 7620, 264, 472, 2368, 4122, 666, 527, 18011, 4846, 4583, 13], "temperature": 0.0, "avg_logprob": -0.09693123543099182, "compression_ratio": 1.53, "no_speech_prob": 0.00010063891386380419}, {"id": 69, "seek": 100200, "start": 1013.0, "end": 1023.0, "text": " Okay, in my picture here, the one other thing that's different is I've introduced a different nonlinearity in the hidden layer, which is a rectified linear unit.", "tokens": [1033, 11, 294, 452, 3036, 510, 11, 264, 472, 661, 551, 300, 311, 819, 307, 286, 600, 7268, 257, 819, 2107, 1889, 17409, 294, 264, 7633, 4583, 11, 597, 307, 257, 11048, 2587, 8213, 4985, 13], "temperature": 0.0, "avg_logprob": -0.09693123543099182, "compression_ratio": 1.53, "no_speech_prob": 0.00010063891386380419}, {"id": 70, "seek": 102300, "start": 1023.0, "end": 1036.0, "text": " So we'll be using our neural dependency pauses. It looks like the picture in the bottom right and I'll come back to that in a few minutes. That's one of the extra neural net things to talk about.", "tokens": [407, 321, 603, 312, 1228, 527, 18161, 33621, 2502, 8355, 13, 467, 1542, 411, 264, 3036, 294, 264, 2767, 558, 293, 286, 603, 808, 646, 281, 300, 294, 257, 1326, 2077, 13, 663, 311, 472, 295, 264, 2857, 18161, 2533, 721, 281, 751, 466, 13], "temperature": 0.0, "avg_logprob": -0.16480872095847615, "compression_ratio": 1.3928571428571428, "no_speech_prob": 6.81299134157598e-05}, {"id": 71, "seek": 103600, "start": 1036.0, "end": 1063.0, "text": " Okay, so our neural net dependency parser model architecture is essentially exactly that, but applied to the configuration of our transition based dependency parser. So based on our transition based dependency parser configuration, we construct an input layer embedding by looking up on the various elements as I discussed previously.", "tokens": [1033, 11, 370, 527, 18161, 2533, 33621, 21156, 260, 2316, 9482, 307, 4476, 2293, 300, 11, 457, 6456, 281, 264, 11694, 295, 527, 6034, 2361, 33621, 21156, 260, 13, 407, 2361, 322, 527, 6034, 2361, 33621, 21156, 260, 11694, 11, 321, 7690, 364, 4846, 4583, 12240, 3584, 538, 1237, 493, 322, 264, 3683, 4959, 382, 286, 7152, 8046, 13], "temperature": 0.0, "avg_logprob": -0.12056418070717463, "compression_ratio": 1.7305699481865284, "no_speech_prob": 3.119179746136069e-05}, {"id": 72, "seek": 106300, "start": 1063.0, "end": 1081.0, "text": " And then we feed it through this hidden layer to the softmax layer to get probabilities out of which we can choose what the next action is, and it's no more complicated than that.", "tokens": [400, 550, 321, 3154, 309, 807, 341, 7633, 4583, 281, 264, 2787, 41167, 4583, 281, 483, 33783, 484, 295, 597, 321, 393, 2826, 437, 264, 958, 3069, 307, 11, 293, 309, 311, 572, 544, 6179, 813, 300, 13], "temperature": 0.0, "avg_logprob": -0.07704240935189384, "compression_ratio": 1.376923076923077, "no_speech_prob": 0.0001464802771806717}, {"id": 73, "seek": 108100, "start": 1081.0, "end": 1108.0, "text": " What we found is that just simply, you know, in some sense, using the simplest kind of feed forward neural classifier could provide a very accurate dependency parser that determines the structure of sentences supporting meaning interpretation, the kind of way that I suggested last time.", "tokens": [708, 321, 1352, 307, 300, 445, 2935, 11, 291, 458, 11, 294, 512, 2020, 11, 1228, 264, 22811, 733, 295, 3154, 2128, 18161, 1508, 9902, 727, 2893, 257, 588, 8559, 33621, 21156, 260, 300, 24799, 264, 3877, 295, 16579, 7231, 3620, 14174, 11, 264, 733, 295, 636, 300, 286, 10945, 1036, 565, 13], "temperature": 0.0, "avg_logprob": -0.09110452417741742, "compression_ratio": 1.5185185185185186, "no_speech_prob": 2.0774072254425846e-05}, {"id": 74, "seek": 110800, "start": 1108.0, "end": 1119.0, "text": " Indeed, you know, despite the fact that it was a quite simple architecture in 2014. This was the first successful neural dependency parser.", "tokens": [15061, 11, 291, 458, 11, 7228, 264, 1186, 300, 309, 390, 257, 1596, 2199, 9482, 294, 8227, 13, 639, 390, 264, 700, 4406, 18161, 33621, 21156, 260, 13], "temperature": 0.0, "avg_logprob": -0.09882530165307316, "compression_ratio": 1.6051502145922747, "no_speech_prob": 7.589328015455976e-05}, {"id": 75, "seek": 110800, "start": 1119.0, "end": 1137.0, "text": " And the dense representations, especially, but also partly the nonlinearity of the classifier gave us this good result that it could both outperform symbolic parsers in terms of accuracy and it could outperform them in terms of speed.", "tokens": [400, 264, 18011, 33358, 11, 2318, 11, 457, 611, 17031, 264, 2107, 1889, 17409, 295, 264, 1508, 9902, 2729, 505, 341, 665, 1874, 300, 309, 727, 1293, 484, 26765, 25755, 21156, 433, 294, 2115, 295, 14170, 293, 309, 727, 484, 26765, 552, 294, 2115, 295, 3073, 13], "temperature": 0.0, "avg_logprob": -0.09882530165307316, "compression_ratio": 1.6051502145922747, "no_speech_prob": 7.589328015455976e-05}, {"id": 76, "seek": 113700, "start": 1137.0, "end": 1147.0, "text": " So that was 2014 just quickly here a couple more slides on what's happened since then.", "tokens": [407, 300, 390, 8227, 445, 2661, 510, 257, 1916, 544, 9788, 322, 437, 311, 2011, 1670, 550, 13], "temperature": 0.0, "avg_logprob": -0.173959266055714, "compression_ratio": 1.0238095238095237, "no_speech_prob": 0.0001996279606828466}, {"id": 77, "seek": 114700, "start": 1147.0, "end": 1166.0, "text": " So lots of people got excited by the success of this neural dependency parser and a number of people, particularly at Google, then set about building a bigger fancier transition based neural dependency parser. So they explored bigger, deeper networks. There's no reason to only have one hidden layer.", "tokens": [407, 3195, 295, 561, 658, 2919, 538, 264, 2245, 295, 341, 18161, 33621, 21156, 260, 293, 257, 1230, 295, 561, 11, 4098, 412, 3329, 11, 550, 992, 466, 2390, 257, 3801, 3429, 27674, 6034, 2361, 18161, 33621, 21156, 260, 13, 407, 436, 24016, 3801, 11, 7731, 9590, 13, 821, 311, 572, 1778, 281, 787, 362, 472, 7633, 4583, 13], "temperature": 0.0, "avg_logprob": -0.14911488124302455, "compression_ratio": 1.5625, "no_speech_prob": 7.464730879291892e-05}, {"id": 78, "seek": 116600, "start": 1166.0, "end": 1180.0, "text": " Two hidden layers, you can do beam search that I briefly mentioned last time. Another thing that I'm not going to talk about now is adding conditional random field style inference over decision sequences.", "tokens": [4453, 7633, 7914, 11, 291, 393, 360, 14269, 3164, 300, 286, 10515, 2835, 1036, 565, 13, 3996, 551, 300, 286, 478, 406, 516, 281, 751, 466, 586, 307, 5127, 27708, 4974, 2519, 3758, 38253, 670, 3537, 22978, 13], "temperature": 0.0, "avg_logprob": -0.1531393187386649, "compression_ratio": 1.3877551020408163, "no_speech_prob": 0.000117015304567758}, {"id": 79, "seek": 118000, "start": 1180.0, "end": 1197.0, "text": " And then led in 2016 for a model that they called parsing MacPars face, which is hard to say with a straight face, which was then about two and a half, three percent more accurate than the model that we had produced.", "tokens": [400, 550, 4684, 294, 6549, 337, 257, 2316, 300, 436, 1219, 21156, 278, 5707, 47, 685, 1851, 11, 597, 307, 1152, 281, 584, 365, 257, 2997, 1851, 11, 597, 390, 550, 466, 732, 293, 257, 1922, 11, 1045, 3043, 544, 8559, 813, 264, 2316, 300, 321, 632, 7126, 13], "temperature": 0.0, "avg_logprob": -0.22446625142157833, "compression_ratio": 1.6226415094339623, "no_speech_prob": 4.111452653887682e-05}, {"id": 80, "seek": 118000, "start": 1197.0, "end": 1209.0, "text": " But still in basically the same family of transition based parser with the neural net classifier to choose the next transition.", "tokens": [583, 920, 294, 1936, 264, 912, 1605, 295, 6034, 2361, 21156, 260, 365, 264, 18161, 2533, 1508, 9902, 281, 2826, 264, 958, 6034, 13], "temperature": 0.0, "avg_logprob": -0.22446625142157833, "compression_ratio": 1.6226415094339623, "no_speech_prob": 4.111452653887682e-05}, {"id": 81, "seek": 120900, "start": 1209.0, "end": 1218.0, "text": " So alternative to transition based parsers as graph based dependency parsers and for a graph based dependency parser.", "tokens": [407, 8535, 281, 6034, 2361, 21156, 433, 382, 4295, 2361, 33621, 21156, 433, 293, 337, 257, 4295, 2361, 33621, 21156, 260, 13], "temperature": 0.0, "avg_logprob": -0.18435980781676278, "compression_ratio": 1.7668711656441718, "no_speech_prob": 9.600254270480946e-05}, {"id": 82, "seek": 120900, "start": 1218.0, "end": 1230.0, "text": " What you're doing is effectively considering every pair of words and considering a word as a dependent of root and you're coming up with a score as to how likely is that.", "tokens": [708, 291, 434, 884, 307, 8659, 8079, 633, 6119, 295, 2283, 293, 8079, 257, 1349, 382, 257, 12334, 295, 5593, 293, 291, 434, 1348, 493, 365, 257, 6175, 382, 281, 577, 3700, 307, 300, 13], "temperature": 0.0, "avg_logprob": -0.18435980781676278, "compression_ratio": 1.7668711656441718, "no_speech_prob": 9.600254270480946e-05}, {"id": 83, "seek": 123000, "start": 1230.0, "end": 1245.0, "text": " That big is a dependent of root or how likely is big to be dependent of cat and similarly for every other word for the word sat how likely is it to be a dependent of root or a dependent of the etc.", "tokens": [663, 955, 307, 257, 12334, 295, 5593, 420, 577, 3700, 307, 955, 281, 312, 12334, 295, 3857, 293, 14138, 337, 633, 661, 1349, 337, 264, 1349, 3227, 577, 3700, 307, 309, 281, 312, 257, 12334, 295, 5593, 420, 257, 12334, 295, 264, 5183, 13], "temperature": 0.0, "avg_logprob": -0.23497837781906128, "compression_ratio": 1.7589285714285714, "no_speech_prob": 0.00014636335254181176}, {"id": 84, "seek": 124500, "start": 1245.0, "end": 1269.0, "text": " And well to do that well, you need to know more than just what the two words involved are. And so what you want to do is understand the context. So you want to have an understanding of the context of big what's to the left or what's to the right of it to understand how you might hook it up into the dependency representations of the sentence.", "tokens": [400, 731, 281, 360, 300, 731, 11, 291, 643, 281, 458, 544, 813, 445, 437, 264, 732, 2283, 3288, 366, 13, 400, 370, 437, 291, 528, 281, 360, 307, 1223, 264, 4319, 13, 407, 291, 528, 281, 362, 364, 3701, 295, 264, 4319, 295, 955, 437, 311, 281, 264, 1411, 420, 437, 311, 281, 264, 558, 295, 309, 281, 1223, 577, 291, 1062, 6328, 309, 493, 666, 264, 33621, 33358, 295, 264, 8174, 13], "temperature": 0.0, "avg_logprob": -0.1034233264434032, "compression_ratio": 1.8148148148148149, "no_speech_prob": 4.7446177632082254e-05}, {"id": 85, "seek": 126900, "start": 1269.0, "end": 1278.0, "text": " And so while there being previous work and graph based dependency parsing like the mst parser I showed on the earlier results slide.", "tokens": [400, 370, 1339, 456, 885, 3894, 589, 293, 4295, 2361, 33621, 21156, 278, 411, 264, 275, 372, 21156, 260, 286, 4712, 322, 264, 3071, 3542, 4137, 13], "temperature": 0.0, "avg_logprob": -0.11947096021551835, "compression_ratio": 1.6036866359447004, "no_speech_prob": 0.00015319071826525033}, {"id": 86, "seek": 126900, "start": 1278.0, "end": 1291.0, "text": " It seemed appealing that we could come up with a much better representation of context using neural nets that look at context and how we do that is actually what I'll be talking about in the end part of the lecture.", "tokens": [467, 6576, 23842, 300, 321, 727, 808, 493, 365, 257, 709, 1101, 10290, 295, 4319, 1228, 18161, 36170, 300, 574, 412, 4319, 293, 577, 321, 360, 300, 307, 767, 437, 286, 603, 312, 1417, 466, 294, 264, 917, 644, 295, 264, 7991, 13], "temperature": 0.0, "avg_logprob": -0.11947096021551835, "compression_ratio": 1.6036866359447004, "no_speech_prob": 0.00015319071826525033}, {"id": 87, "seek": 129100, "start": 1291.0, "end": 1302.0, "text": " And so at Stanford, we became interested in trying to work out how to come up with a better graph based dependency parser using context.", "tokens": [400, 370, 412, 20374, 11, 321, 3062, 3102, 294, 1382, 281, 589, 484, 577, 281, 808, 493, 365, 257, 1101, 4295, 2361, 33621, 21156, 260, 1228, 4319, 13], "temperature": 0.0, "avg_logprob": -0.1192519744237264, "compression_ratio": 1.4682080924855492, "no_speech_prob": 5.339127892511897e-05}, {"id": 88, "seek": 129100, "start": 1302.0, "end": 1309.0, "text": " So I forgot this. This was showing that if we can score each pair wise dependency, we can simply choose the best one.", "tokens": [407, 286, 5298, 341, 13, 639, 390, 4099, 300, 498, 321, 393, 6175, 1184, 6119, 10829, 33621, 11, 321, 393, 2935, 2826, 264, 1151, 472, 13], "temperature": 0.0, "avg_logprob": -0.1192519744237264, "compression_ratio": 1.4682080924855492, "no_speech_prob": 5.339127892511897e-05}, {"id": 89, "seek": 130900, "start": 1309.0, "end": 1324.0, "text": " So we can say probably big is a dependent of cat. And to a first of approximation, we're going to want to choose for each word that it is a dependent of the word that seems most likely to be a dependent.", "tokens": [407, 321, 393, 584, 1391, 955, 307, 257, 12334, 295, 3857, 13, 400, 281, 257, 700, 295, 28023, 11, 321, 434, 516, 281, 528, 281, 2826, 337, 1184, 1349, 300, 309, 307, 257, 12334, 295, 264, 1349, 300, 2544, 881, 3700, 281, 312, 257, 12334, 13], "temperature": 0.0, "avg_logprob": -0.11258909225463867, "compression_ratio": 1.5037037037037038, "no_speech_prob": 6.914237019373104e-05}, {"id": 90, "seek": 132400, "start": 1324.0, "end": 1342.0, "text": " But we want to do that with some constraints because we want to get out something that is a tree with a single root of I discussed last time and you can do that by making use of a minimum spanning tree algorithm that uses these scores of how likely different dependencies are.", "tokens": [583, 321, 528, 281, 360, 300, 365, 512, 18491, 570, 321, 528, 281, 483, 484, 746, 300, 307, 257, 4230, 365, 257, 2167, 5593, 295, 286, 7152, 1036, 565, 293, 291, 393, 360, 300, 538, 1455, 764, 295, 257, 7285, 47626, 4230, 9284, 300, 4960, 613, 13444, 295, 577, 3700, 819, 36606, 366, 13], "temperature": 0.0, "avg_logprob": -0.10913138554014008, "compression_ratio": 1.5862068965517242, "no_speech_prob": 0.00014513979840558022}, {"id": 91, "seek": 134200, "start": 1342.0, "end": 1361.0, "text": " Okay, so then in 2017 another student Tim Dozer and me then worked on saying well, can we now also build a much better neural graph based dependency parser and we developed a novel methods for scoring.", "tokens": [1033, 11, 370, 550, 294, 6591, 1071, 3107, 7172, 1144, 4527, 293, 385, 550, 2732, 322, 1566, 731, 11, 393, 321, 586, 611, 1322, 257, 709, 1101, 18161, 4295, 2361, 33621, 21156, 260, 293, 321, 4743, 257, 7613, 7150, 337, 22358, 13], "temperature": 0.0, "avg_logprob": -0.22160154840220575, "compression_ratio": 1.3223684210526316, "no_speech_prob": 7.783767796354368e-05}, {"id": 92, "seek": 136100, "start": 1361.0, "end": 1384.0, "text": " And scoring dependency parsers and a graph based model, which I'm not going to get into the details of right now, but that also had a very nice result because using getting back to graph based parsing we could then build a graph based parser that performed about a percent better than the best of the Google transition based neural dependency parsers.", "tokens": [400, 22358, 33621, 21156, 433, 293, 257, 4295, 2361, 2316, 11, 597, 286, 478, 406, 516, 281, 483, 666, 264, 4365, 295, 558, 586, 11, 457, 300, 611, 632, 257, 588, 1481, 1874, 570, 1228, 1242, 646, 281, 4295, 2361, 21156, 278, 321, 727, 550, 1322, 257, 4295, 2361, 21156, 260, 300, 10332, 466, 257, 3043, 1101, 813, 264, 1151, 295, 264, 3329, 6034, 2361, 18161, 33621, 21156, 433, 13], "temperature": 0.0, "avg_logprob": -0.14945518648302233, "compression_ratio": 1.6794258373205742, "no_speech_prob": 7.456745515810326e-05}, {"id": 93, "seek": 138400, "start": 1384.0, "end": 1391.0, "text": " And then we'll point out that this is a mixed win because although it's accuracy is better.", "tokens": [400, 550, 321, 603, 935, 484, 300, 341, 307, 257, 7467, 1942, 570, 4878, 309, 311, 14170, 307, 1101, 13], "temperature": 0.0, "avg_logprob": -0.221968136136494, "compression_ratio": 1.4438775510204083, "no_speech_prob": 7.717045082245022e-05}, {"id": 94, "seek": 138400, "start": 1391.0, "end": 1404.0, "text": " These graph based parsers are just in squared and performance rather than linear time. So kind of like the earlier results I showed they don't operate nearly as quickly when you're wanting to", "tokens": [1981, 4295, 2361, 21156, 433, 366, 445, 294, 8889, 293, 3389, 2831, 813, 8213, 565, 13, 407, 733, 295, 411, 264, 3071, 3542, 286, 4712, 436, 500, 380, 9651, 6217, 382, 2661, 562, 291, 434, 7935, 281], "temperature": 0.0, "avg_logprob": -0.221968136136494, "compression_ratio": 1.4438775510204083, "no_speech_prob": 7.717045082245022e-05}, {"id": 95, "seek": 140400, "start": 1404.0, "end": 1419.0, "text": " have a large amounts of text with complex long sentences. Okay, so that's everything you need to know about dependency parsers and to do assignment three so grab it this evening and start to work.", "tokens": [362, 257, 2416, 11663, 295, 2487, 365, 3997, 938, 16579, 13, 1033, 11, 370, 300, 311, 1203, 291, 643, 281, 458, 466, 33621, 21156, 433, 293, 281, 360, 15187, 1045, 370, 4444, 309, 341, 5634, 293, 722, 281, 589, 13], "temperature": 0.0, "avg_logprob": -0.22051752697337756, "compression_ratio": 1.3900709219858156, "no_speech_prob": 9.162443166133016e-05}, {"id": 96, "seek": 141900, "start": 1419.0, "end": 1437.0, "text": " I did want to sort of before going on to the next topic just mention a few more things about neural networks since some of you know this well already some of you have seen less of it, but you know, there just are a bunch of things you have to be aware of for building neural networks.", "tokens": [286, 630, 528, 281, 1333, 295, 949, 516, 322, 281, 264, 958, 4829, 445, 2152, 257, 1326, 544, 721, 466, 18161, 9590, 1670, 512, 295, 291, 458, 341, 731, 1217, 512, 295, 291, 362, 1612, 1570, 295, 309, 11, 457, 291, 458, 11, 456, 445, 366, 257, 3840, 295, 721, 291, 362, 281, 312, 3650, 295, 337, 2390, 18161, 9590, 13], "temperature": 0.0, "avg_logprob": -0.1126469612121582, "compression_ratio": 1.6608187134502923, "no_speech_prob": 7.44378412491642e-05}, {"id": 97, "seek": 143700, "start": 1437.0, "end": 1464.0, "text": " Now again for assignment three, essentially we give you everything and if you follow the recipe your parser should work well, but you know what you should have minimally do is actually you know look carefully at some of the things that this parser does, which is questions like how do we initialize our matrices of our neural network.", "tokens": [823, 797, 337, 15187, 1045, 11, 4476, 321, 976, 291, 1203, 293, 498, 291, 1524, 264, 6782, 428, 21156, 260, 820, 589, 731, 11, 457, 291, 458, 437, 291, 820, 362, 4464, 379, 360, 307, 767, 291, 458, 574, 7500, 412, 512, 295, 264, 721, 300, 341, 21156, 260, 775, 11, 597, 307, 1651, 411, 577, 360, 321, 5883, 1125, 527, 32284, 295, 527, 18161, 3209, 13], "temperature": 0.0, "avg_logprob": -0.1597916643384477, "compression_ratio": 1.6213592233009708, "no_speech_prob": 4.2529834900051355e-05}, {"id": 98, "seek": 146400, "start": 1464.0, "end": 1469.0, "text": " What kind of optimizers do we use and things like that.", "tokens": [708, 733, 295, 5028, 22525, 360, 321, 764, 293, 721, 411, 300, 13], "temperature": 0.0, "avg_logprob": -0.10940229892730713, "compression_ratio": 1.4431137724550898, "no_speech_prob": 0.00013535864127334207}, {"id": 99, "seek": 146400, "start": 1469.0, "end": 1476.0, "text": " Because these are all important decisions and so I wanted to say just a few words about that.", "tokens": [1436, 613, 366, 439, 1021, 5327, 293, 370, 286, 1415, 281, 584, 445, 257, 1326, 2283, 466, 300, 13], "temperature": 0.0, "avg_logprob": -0.10940229892730713, "compression_ratio": 1.4431137724550898, "no_speech_prob": 0.00013535864127334207}, {"id": 100, "seek": 146400, "start": 1476.0, "end": 1483.0, "text": " Okay, so the first thing that we haven't discussed at all is the concept of regularization.", "tokens": [1033, 11, 370, 264, 700, 551, 300, 321, 2378, 380, 7152, 412, 439, 307, 264, 3410, 295, 3890, 2144, 13], "temperature": 0.0, "avg_logprob": -0.10940229892730713, "compression_ratio": 1.4431137724550898, "no_speech_prob": 0.00013535864127334207}, {"id": 101, "seek": 148300, "start": 1483.0, "end": 1504.0, "text": " So we're building these neural nets we're now building models with a huge number of parameters so essentially just about all neural net models that work well actually their full loss function is a regularized loss function.", "tokens": [407, 321, 434, 2390, 613, 18161, 36170, 321, 434, 586, 2390, 5245, 365, 257, 2603, 1230, 295, 9834, 370, 4476, 445, 466, 439, 18161, 2533, 5245, 300, 589, 731, 767, 641, 1577, 4470, 2445, 307, 257, 3890, 1602, 4470, 2445, 13], "temperature": 0.0, "avg_logprob": -0.20806399451361762, "compression_ratio": 1.5594405594405594, "no_speech_prob": 0.00010878973262151703}, {"id": 102, "seek": 150400, "start": 1504.0, "end": 1526.0, "text": " So this is a loss function here of J well this part here is the part that we've seen before where we're using a softmax classifier and then taking a negative log likelihood loss which within averaging over the different examples, but actually we then stick on the end of it.", "tokens": [407, 341, 307, 257, 4470, 2445, 510, 295, 508, 731, 341, 644, 510, 307, 264, 644, 300, 321, 600, 1612, 949, 689, 321, 434, 1228, 257, 2787, 41167, 1508, 9902, 293, 550, 1940, 257, 3671, 3565, 22119, 4470, 597, 1951, 47308, 670, 264, 819, 5110, 11, 457, 767, 321, 550, 2897, 322, 264, 917, 295, 309, 13], "temperature": 0.0, "avg_logprob": -0.29894916346815764, "compression_ratio": 1.5138121546961325, "no_speech_prob": 0.00015585677465423942}, {"id": 103, "seek": 152600, "start": 1526.0, "end": 1536.0, "text": " So this is a regularization term and so this regularization term sums the square of every parameter in the model.", "tokens": [407, 341, 307, 257, 3890, 2144, 1433, 293, 370, 341, 3890, 2144, 1433, 34499, 264, 3732, 295, 633, 13075, 294, 264, 2316, 13], "temperature": 0.0, "avg_logprob": -0.20293296592822974, "compression_ratio": 1.6210526315789473, "no_speech_prob": 0.0002097140095429495}, {"id": 104, "seek": 152600, "start": 1536.0, "end": 1553.0, "text": " And so what that effectively says is you only want to make parameters non zero if they're really useful right so to the extent of the parameters don't help much you're just being penalized here.", "tokens": [400, 370, 437, 300, 8659, 1619, 307, 291, 787, 528, 281, 652, 9834, 2107, 4018, 498, 436, 434, 534, 4420, 558, 370, 281, 264, 8396, 295, 264, 9834, 500, 380, 854, 709, 291, 434, 445, 885, 13661, 1602, 510, 13], "temperature": 0.0, "avg_logprob": -0.20293296592822974, "compression_ratio": 1.6210526315789473, "no_speech_prob": 0.0002097140095429495}, {"id": 105, "seek": 155300, "start": 1553.0, "end": 1569.0, "text": " And they're not going to be extremely non zero but to the extent that the parameters do help you will gain in your estimation of likelihood and therefore it's OK for them to be non zero in particular notice that this penalty is assessed only once per parameter.", "tokens": [400, 436, 434, 406, 516, 281, 312, 4664, 2107, 4018, 457, 281, 264, 8396, 300, 264, 9834, 360, 854, 291, 486, 6052, 294, 428, 35701, 295, 22119, 293, 4412, 309, 311, 2264, 337, 552, 281, 312, 2107, 4018, 294, 1729, 3449, 300, 341, 16263, 307, 36051, 787, 1564, 680, 13075, 13], "temperature": 0.6, "avg_logprob": -0.40506072542560634, "compression_ratio": 1.6020408163265305, "no_speech_prob": 0.00011408892896724865}, {"id": 106, "seek": 155300, "start": 1569.0, "end": 1573.0, "text": " It's not being assessed separately for each example.", "tokens": [467, 311, 406, 885, 36051, 14759, 337, 1184, 1365, 13], "temperature": 0.6, "avg_logprob": -0.40506072542560634, "compression_ratio": 1.6020408163265305, "no_speech_prob": 0.00011408892896724865}, {"id": 107, "seek": 157300, "start": 1573.0, "end": 1581.32, "text": " Okay, and having this kind of regularization is essential to build new net models that regularize well.", "tokens": [1033, 11, 293, 1419, 341, 733, 295, 3890, 2144, 307, 7115, 281, 1322, 777, 2533, 5245, 300, 3890, 1125, 731, 13], "temperature": 0.0, "avg_logprob": -0.27248573303222656, "compression_ratio": 1.6192660550458715, "no_speech_prob": 0.010806492529809475}, {"id": 108, "seek": 157300, "start": 1581.32, "end": 1585.16, "text": " So the classic problem is referred to as overfitting.", "tokens": [407, 264, 7230, 1154, 307, 10839, 281, 382, 670, 69, 2414, 13], "temperature": 0.0, "avg_logprob": -0.27248573303222656, "compression_ratio": 1.6192660550458715, "no_speech_prob": 0.010806492529809475}, {"id": 109, "seek": 157300, "start": 1585.16, "end": 1591.72, "text": " And what overfitting means is that if you have a particular training data set and you start training your model,", "tokens": [400, 437, 670, 69, 2414, 1355, 307, 300, 498, 291, 362, 257, 1729, 3097, 1412, 992, 293, 291, 722, 3097, 428, 2316, 11], "temperature": 0.0, "avg_logprob": -0.27248573303222656, "compression_ratio": 1.6192660550458715, "no_speech_prob": 0.010806492529809475}, {"id": 110, "seek": 157300, "start": 1592.52, "end": 1597.56, "text": " your error will go down because you'll shift the parameters so they better predict", "tokens": [428, 6713, 486, 352, 760, 570, 291, 603, 5513, 264, 9834, 370, 436, 1101, 6069], "temperature": 0.0, "avg_logprob": -0.27248573303222656, "compression_ratio": 1.6192660550458715, "no_speech_prob": 0.010806492529809475}, {"id": 111, "seek": 159756, "start": 1597.56, "end": 1606.2, "text": " the correct answer for data points in the model and you can keep on doing that and it will", "tokens": [264, 3006, 1867, 337, 1412, 2793, 294, 264, 2316, 293, 291, 393, 1066, 322, 884, 300, 293, 309, 486], "temperature": 0.0, "avg_logprob": -0.11137740061833308, "compression_ratio": 1.6277777777777778, "no_speech_prob": 0.0005876083159819245}, {"id": 112, "seek": 159756, "start": 1606.2, "end": 1614.36, "text": " keep on reducing your error rate. But if you then look at your partially trained classifier and say", "tokens": [1066, 322, 12245, 428, 6713, 3314, 13, 583, 498, 291, 550, 574, 412, 428, 18886, 8895, 1508, 9902, 293, 584], "temperature": 0.0, "avg_logprob": -0.11137740061833308, "compression_ratio": 1.6277777777777778, "no_speech_prob": 0.0005876083159819245}, {"id": 113, "seek": 159756, "start": 1614.36, "end": 1622.9199999999998, "text": " how well does this classifier classify independent data, different test data that you weren't training", "tokens": [577, 731, 775, 341, 1508, 9902, 33872, 6695, 1412, 11, 819, 1500, 1412, 300, 291, 4999, 380, 3097], "temperature": 0.0, "avg_logprob": -0.11137740061833308, "compression_ratio": 1.6277777777777778, "no_speech_prob": 0.0005876083159819245}, {"id": 114, "seek": 162292, "start": 1622.92, "end": 1630.04, "text": " the model on, what you'll find is up until a certain point you'll get better at classifying", "tokens": [264, 2316, 322, 11, 437, 291, 603, 915, 307, 493, 1826, 257, 1629, 935, 291, 603, 483, 1101, 412, 1508, 5489], "temperature": 0.0, "avg_logprob": -0.09958466922535616, "compression_ratio": 1.7971698113207548, "no_speech_prob": 0.00012130695540690795}, {"id": 115, "seek": 162292, "start": 1630.04, "end": 1637.3200000000002, "text": " independent test examples as well. And after that, commonly what will happen is you'll actually", "tokens": [6695, 1500, 5110, 382, 731, 13, 400, 934, 300, 11, 12719, 437, 486, 1051, 307, 291, 603, 767], "temperature": 0.0, "avg_logprob": -0.09958466922535616, "compression_ratio": 1.7971698113207548, "no_speech_prob": 0.00012130695540690795}, {"id": 116, "seek": 162292, "start": 1637.3200000000002, "end": 1643.64, "text": " start to get worse at classifying independent test examples even though you're continuing to get", "tokens": [722, 281, 483, 5324, 412, 1508, 5489, 6695, 1500, 5110, 754, 1673, 291, 434, 9289, 281, 483], "temperature": 0.0, "avg_logprob": -0.09958466922535616, "compression_ratio": 1.7971698113207548, "no_speech_prob": 0.00012130695540690795}, {"id": 117, "seek": 162292, "start": 1643.64, "end": 1649.0, "text": " better at predicting the training examples. And so this was then referred to as your overfitting", "tokens": [1101, 412, 32884, 264, 3097, 5110, 13, 400, 370, 341, 390, 550, 10839, 281, 382, 428, 670, 69, 2414], "temperature": 0.0, "avg_logprob": -0.09958466922535616, "compression_ratio": 1.7971698113207548, "no_speech_prob": 0.00012130695540690795}, {"id": 118, "seek": 164900, "start": 1649.0, "end": 1655.08, "text": " the training examples that you're fiddling the parameters of the model so they're really good at", "tokens": [264, 3097, 5110, 300, 291, 434, 283, 14273, 1688, 264, 9834, 295, 264, 2316, 370, 436, 434, 534, 665, 412], "temperature": 0.0, "avg_logprob": -0.13129942757742746, "compression_ratio": 1.6839080459770115, "no_speech_prob": 0.00013938092160969973}, {"id": 119, "seek": 164900, "start": 1655.08, "end": 1662.84, "text": " predicting the training examples which aren't useful things that can then predict on independent", "tokens": [32884, 264, 3097, 5110, 597, 3212, 380, 4420, 721, 300, 393, 550, 6069, 322, 6695], "temperature": 0.0, "avg_logprob": -0.13129942757742746, "compression_ratio": 1.6839080459770115, "no_speech_prob": 0.00013938092160969973}, {"id": 120, "seek": 164900, "start": 1663.56, "end": 1673.32, "text": " examples that you come to at runtime. Okay, that classic view of regularization is sort of actually", "tokens": [5110, 300, 291, 808, 281, 412, 34474, 13, 1033, 11, 300, 7230, 1910, 295, 3890, 2144, 307, 1333, 295, 767], "temperature": 0.0, "avg_logprob": -0.13129942757742746, "compression_ratio": 1.6839080459770115, "no_speech_prob": 0.00013938092160969973}, {"id": 121, "seek": 167332, "start": 1673.32, "end": 1683.24, "text": " outmoded and wrong for modern neural networks. So the right way to think of it for the kind of", "tokens": [484, 8014, 292, 293, 2085, 337, 4363, 18161, 9590, 13, 407, 264, 558, 636, 281, 519, 295, 309, 337, 264, 733, 295], "temperature": 0.0, "avg_logprob": -0.08778583642208215, "compression_ratio": 1.6206896551724137, "no_speech_prob": 9.880586003419012e-05}, {"id": 122, "seek": 167332, "start": 1683.24, "end": 1692.28, "text": " modern big neural networks that we build is that overfitting on the training data isn't a problem", "tokens": [4363, 955, 18161, 9590, 300, 321, 1322, 307, 300, 670, 69, 2414, 322, 264, 3097, 1412, 1943, 380, 257, 1154], "temperature": 0.0, "avg_logprob": -0.08778583642208215, "compression_ratio": 1.6206896551724137, "no_speech_prob": 9.880586003419012e-05}, {"id": 123, "seek": 167332, "start": 1692.28, "end": 1701.3999999999999, "text": " but nevertheless you need regularization to make sure that your models generalize well to", "tokens": [457, 26924, 291, 643, 3890, 2144, 281, 652, 988, 300, 428, 5245, 2674, 1125, 731, 281], "temperature": 0.0, "avg_logprob": -0.08778583642208215, "compression_ratio": 1.6206896551724137, "no_speech_prob": 9.880586003419012e-05}, {"id": 124, "seek": 170140, "start": 1701.4, "end": 1709.72, "text": " independent test data. So what you'd like is for your graph not to look like this example", "tokens": [6695, 1500, 1412, 13, 407, 437, 291, 1116, 411, 307, 337, 428, 4295, 406, 281, 574, 411, 341, 1365], "temperature": 0.0, "avg_logprob": -0.09210658774656408, "compression_ratio": 1.546448087431694, "no_speech_prob": 7.594017370138317e-05}, {"id": 125, "seek": 170140, "start": 1709.72, "end": 1718.1200000000001, "text": " with test error starting to head up. You'd like to have it at worst case flatline and best case", "tokens": [365, 1500, 6713, 2891, 281, 1378, 493, 13, 509, 1116, 411, 281, 362, 309, 412, 5855, 1389, 4962, 1889, 293, 1151, 1389], "temperature": 0.0, "avg_logprob": -0.09210658774656408, "compression_ratio": 1.546448087431694, "no_speech_prob": 7.594017370138317e-05}, {"id": 126, "seek": 170140, "start": 1718.1200000000001, "end": 1725.0, "text": " still be gradually dropping. It'll always be higher than the training error but it's not actually", "tokens": [920, 312, 13145, 13601, 13, 467, 603, 1009, 312, 2946, 813, 264, 3097, 6713, 457, 309, 311, 406, 767], "temperature": 0.0, "avg_logprob": -0.09210658774656408, "compression_ratio": 1.546448087431694, "no_speech_prob": 7.594017370138317e-05}, {"id": 127, "seek": 172500, "start": 1725.0, "end": 1734.76, "text": " showing a failure to generalize. So when we train big neural nets these days our big neural nets", "tokens": [4099, 257, 7763, 281, 2674, 1125, 13, 407, 562, 321, 3847, 955, 18161, 36170, 613, 1708, 527, 955, 18161, 36170], "temperature": 0.0, "avg_logprob": -0.10571836870770122, "compression_ratio": 1.9246231155778895, "no_speech_prob": 2.544691233197227e-05}, {"id": 128, "seek": 172500, "start": 1735.96, "end": 1742.84, "text": " always overfit on the training data they hugely overfit on the training data. In fact in many", "tokens": [1009, 670, 69, 270, 322, 264, 3097, 1412, 436, 27417, 670, 6845, 322, 264, 3097, 1412, 13, 682, 1186, 294, 867], "temperature": 0.0, "avg_logprob": -0.10571836870770122, "compression_ratio": 1.9246231155778895, "no_speech_prob": 2.544691233197227e-05}, {"id": 129, "seek": 172500, "start": 1742.84, "end": 1748.84, "text": " circumstances our neural nets have so many parameters that you can continue to train them on the", "tokens": [9121, 527, 18161, 36170, 362, 370, 867, 9834, 300, 291, 393, 2354, 281, 3847, 552, 322, 264], "temperature": 0.0, "avg_logprob": -0.10571836870770122, "compression_ratio": 1.9246231155778895, "no_speech_prob": 2.544691233197227e-05}, {"id": 130, "seek": 172500, "start": 1748.84, "end": 1754.6, "text": " training data until the error on the training data is zero. They get every single example right", "tokens": [3097, 1412, 1826, 264, 6713, 322, 264, 3097, 1412, 307, 4018, 13, 814, 483, 633, 2167, 1365, 558], "temperature": 0.0, "avg_logprob": -0.10571836870770122, "compression_ratio": 1.9246231155778895, "no_speech_prob": 2.544691233197227e-05}, {"id": 131, "seek": 175460, "start": 1754.6, "end": 1760.36, "text": " because they can just memorize enough stuff about it to predict the right answer. But in general", "tokens": [570, 436, 393, 445, 27478, 1547, 1507, 466, 309, 281, 6069, 264, 558, 1867, 13, 583, 294, 2674], "temperature": 0.0, "avg_logprob": -0.08950050225418606, "compression_ratio": 1.7136563876651982, "no_speech_prob": 2.3543838324258104e-05}, {"id": 132, "seek": 175460, "start": 1760.36, "end": 1767.08, "text": " providing the models are regularized well those models will still also generalize well and", "tokens": [6530, 264, 5245, 366, 3890, 1602, 731, 729, 5245, 486, 920, 611, 2674, 1125, 731, 293], "temperature": 0.0, "avg_logprob": -0.08950050225418606, "compression_ratio": 1.7136563876651982, "no_speech_prob": 2.3543838324258104e-05}, {"id": 133, "seek": 175460, "start": 1767.08, "end": 1774.84, "text": " predict well an independent data. And so for part of what we want to do for that is to work out how", "tokens": [6069, 731, 364, 6695, 1412, 13, 400, 370, 337, 644, 295, 437, 321, 528, 281, 360, 337, 300, 307, 281, 589, 484, 577], "temperature": 0.0, "avg_logprob": -0.08950050225418606, "compression_ratio": 1.7136563876651982, "no_speech_prob": 2.3543838324258104e-05}, {"id": 134, "seek": 175460, "start": 1774.84, "end": 1782.12, "text": " much to regularize. And so this lambda parameter here is the strength of regularization. So if you're", "tokens": [709, 281, 3890, 1125, 13, 400, 370, 341, 13607, 13075, 510, 307, 264, 3800, 295, 3890, 2144, 13, 407, 498, 291, 434], "temperature": 0.0, "avg_logprob": -0.08950050225418606, "compression_ratio": 1.7136563876651982, "no_speech_prob": 2.3543838324258104e-05}, {"id": 135, "seek": 178212, "start": 1782.12, "end": 1788.6, "text": " making that lambda number big you're getting more regularization and if you're making it small", "tokens": [1455, 300, 13607, 1230, 955, 291, 434, 1242, 544, 3890, 2144, 293, 498, 291, 434, 1455, 309, 1359], "temperature": 0.0, "avg_logprob": -0.07762184435007524, "compression_ratio": 1.8169014084507042, "no_speech_prob": 2.467736521793995e-05}, {"id": 136, "seek": 178212, "start": 1788.6, "end": 1793.3999999999999, "text": " you're getting less. And you don't want to have it be too big or else you won't fit the data well", "tokens": [291, 434, 1242, 1570, 13, 400, 291, 500, 380, 528, 281, 362, 309, 312, 886, 955, 420, 1646, 291, 1582, 380, 3318, 264, 1412, 731], "temperature": 0.0, "avg_logprob": -0.07762184435007524, "compression_ratio": 1.8169014084507042, "no_speech_prob": 2.467736521793995e-05}, {"id": 137, "seek": 178212, "start": 1793.3999999999999, "end": 1801.0, "text": " and you don't want it to be too small or else you have the problem that you don't generalize well.", "tokens": [293, 291, 500, 380, 528, 309, 281, 312, 886, 1359, 420, 1646, 291, 362, 264, 1154, 300, 291, 500, 380, 2674, 1125, 731, 13], "temperature": 0.0, "avg_logprob": -0.07762184435007524, "compression_ratio": 1.8169014084507042, "no_speech_prob": 2.467736521793995e-05}, {"id": 138, "seek": 178212, "start": 1801.56, "end": 1808.04, "text": " Okay so this is classic L2 regularization and it's a starting point but our big neural nets are", "tokens": [1033, 370, 341, 307, 7230, 441, 17, 3890, 2144, 293, 309, 311, 257, 2891, 935, 457, 527, 955, 18161, 36170, 366], "temperature": 0.0, "avg_logprob": -0.07762184435007524, "compression_ratio": 1.8169014084507042, "no_speech_prob": 2.467736521793995e-05}, {"id": 139, "seek": 180804, "start": 1808.04, "end": 1814.52, "text": " sufficiently complex and have sufficiently many parameters that essentially L2 regularization", "tokens": [31868, 3997, 293, 362, 31868, 867, 9834, 300, 4476, 441, 17, 3890, 2144], "temperature": 0.0, "avg_logprob": -0.08848436417118195, "compression_ratio": 1.5078534031413613, "no_speech_prob": 2.3180544303613715e-05}, {"id": 140, "seek": 180804, "start": 1814.52, "end": 1820.84, "text": " doesn't cut it. So the next thing that you should know about and is a very standard good feature", "tokens": [1177, 380, 1723, 309, 13, 407, 264, 958, 551, 300, 291, 820, 458, 466, 293, 307, 257, 588, 3832, 665, 4111], "temperature": 0.0, "avg_logprob": -0.08848436417118195, "compression_ratio": 1.5078534031413613, "no_speech_prob": 2.3180544303613715e-05}, {"id": 141, "seek": 180804, "start": 1821.8799999999999, "end": 1832.44, "text": " for building your own nets is a technique called dropout. So dropout is generally introduced as a", "tokens": [337, 2390, 428, 1065, 36170, 307, 257, 6532, 1219, 3270, 346, 13, 407, 3270, 346, 307, 5101, 7268, 382, 257], "temperature": 0.0, "avg_logprob": -0.08848436417118195, "compression_ratio": 1.5078534031413613, "no_speech_prob": 2.3180544303613715e-05}, {"id": 142, "seek": 183244, "start": 1832.44, "end": 1840.76, "text": " sort of a slightly funny process that you do when training to avoid feature co-adaptation.", "tokens": [1333, 295, 257, 4748, 4074, 1399, 300, 291, 360, 562, 3097, 281, 5042, 4111, 598, 12, 345, 2796, 399, 13], "temperature": 0.0, "avg_logprob": -0.0932824024255725, "compression_ratio": 1.6566265060240963, "no_speech_prob": 4.3909367377636954e-05}, {"id": 143, "seek": 183244, "start": 1840.76, "end": 1848.68, "text": " So in dropout what you do is at the time that you're training your model that for each", "tokens": [407, 294, 3270, 346, 437, 291, 360, 307, 412, 264, 565, 300, 291, 434, 3097, 428, 2316, 300, 337, 1184], "temperature": 0.0, "avg_logprob": -0.0932824024255725, "compression_ratio": 1.6566265060240963, "no_speech_prob": 4.3909367377636954e-05}, {"id": 144, "seek": 183244, "start": 1849.8, "end": 1860.04, "text": " instance or for each batch in your training then for each neuron in the model you drop 50% of its", "tokens": [5197, 420, 337, 1184, 15245, 294, 428, 3097, 550, 337, 1184, 34090, 294, 264, 2316, 291, 3270, 2625, 4, 295, 1080], "temperature": 0.0, "avg_logprob": -0.0932824024255725, "compression_ratio": 1.6566265060240963, "no_speech_prob": 4.3909367377636954e-05}, {"id": 145, "seek": 186004, "start": 1860.04, "end": 1867.3999999999999, "text": " inputs you just treat them as zero and so that you can do by sort of zeroing out elements of", "tokens": [15743, 291, 445, 2387, 552, 382, 4018, 293, 370, 300, 291, 393, 360, 538, 1333, 295, 4018, 278, 484, 4959, 295], "temperature": 0.0, "avg_logprob": -0.13494079642825657, "compression_ratio": 1.6724137931034482, "no_speech_prob": 4.8313951992895454e-05}, {"id": 146, "seek": 186004, "start": 1868.28, "end": 1878.28, "text": " the sort of layers. And then at test time you don't drop any of the model weights you keep them all", "tokens": [264, 1333, 295, 7914, 13, 400, 550, 412, 1500, 565, 291, 500, 380, 3270, 604, 295, 264, 2316, 17443, 291, 1066, 552, 439], "temperature": 0.0, "avg_logprob": -0.13494079642825657, "compression_ratio": 1.6724137931034482, "no_speech_prob": 4.8313951992895454e-05}, {"id": 147, "seek": 186004, "start": 1878.28, "end": 1883.72, "text": " but actually you harble the model weights because you're now keeping twice as many things as you'd", "tokens": [457, 767, 291, 2233, 638, 264, 2316, 17443, 570, 291, 434, 586, 5145, 6091, 382, 867, 721, 382, 291, 1116], "temperature": 0.0, "avg_logprob": -0.13494079642825657, "compression_ratio": 1.6724137931034482, "no_speech_prob": 4.8313951992895454e-05}, {"id": 148, "seek": 188372, "start": 1883.72, "end": 1893.72, "text": " used at training data. And so effectively that little recipe prevents what's called feature co-adaptation.", "tokens": [1143, 412, 3097, 1412, 13, 400, 370, 8659, 300, 707, 6782, 22367, 437, 311, 1219, 4111, 598, 12, 345, 2796, 399, 13], "temperature": 0.0, "avg_logprob": -0.08512345827542818, "compression_ratio": 1.608695652173913, "no_speech_prob": 3.320659016026184e-05}, {"id": 149, "seek": 188372, "start": 1893.72, "end": 1902.44, "text": " So you can't you can't have features that are only useful in the presence of particular other", "tokens": [407, 291, 393, 380, 291, 393, 380, 362, 4122, 300, 366, 787, 4420, 294, 264, 6814, 295, 1729, 661], "temperature": 0.0, "avg_logprob": -0.08512345827542818, "compression_ratio": 1.608695652173913, "no_speech_prob": 3.320659016026184e-05}, {"id": 150, "seek": 188372, "start": 1902.44, "end": 1907.64, "text": " features because the model can't guarantee which features are going to be present for different", "tokens": [4122, 570, 264, 2316, 393, 380, 10815, 597, 4122, 366, 516, 281, 312, 1974, 337, 819], "temperature": 0.0, "avg_logprob": -0.08512345827542818, "compression_ratio": 1.608695652173913, "no_speech_prob": 3.320659016026184e-05}, {"id": 151, "seek": 190764, "start": 1907.64, "end": 1914.1200000000001, "text": " examples because different features are being randomly dropped all of the time. And so effectively", "tokens": [5110, 570, 819, 4122, 366, 885, 16979, 8119, 439, 295, 264, 565, 13, 400, 370, 8659], "temperature": 0.0, "avg_logprob": -0.10382209051223028, "compression_ratio": 1.9126984126984128, "no_speech_prob": 1.8618806279846467e-05}, {"id": 152, "seek": 190764, "start": 1914.68, "end": 1919.8000000000002, "text": " dropout gives you a kind of a middle ground between naive bays and a logistic regression model", "tokens": [3270, 346, 2709, 291, 257, 733, 295, 257, 2808, 2727, 1296, 29052, 272, 3772, 293, 257, 3565, 3142, 24590, 2316], "temperature": 0.0, "avg_logprob": -0.10382209051223028, "compression_ratio": 1.9126984126984128, "no_speech_prob": 1.8618806279846467e-05}, {"id": 153, "seek": 190764, "start": 1919.8000000000002, "end": 1925.3200000000002, "text": " and a naive bays models all the weights are set independently and a logistic regression model", "tokens": [293, 257, 29052, 272, 3772, 5245, 439, 264, 17443, 366, 992, 21761, 293, 257, 3565, 3142, 24590, 2316], "temperature": 0.0, "avg_logprob": -0.10382209051223028, "compression_ratio": 1.9126984126984128, "no_speech_prob": 1.8618806279846467e-05}, {"id": 154, "seek": 190764, "start": 1925.3200000000002, "end": 1930.6000000000001, "text": " all the weights are set in the context of all the others and here you are aware of other weights", "tokens": [439, 264, 17443, 366, 992, 294, 264, 4319, 295, 439, 264, 2357, 293, 510, 291, 366, 3650, 295, 661, 17443], "temperature": 0.0, "avg_logprob": -0.10382209051223028, "compression_ratio": 1.9126984126984128, "no_speech_prob": 1.8618806279846467e-05}, {"id": 155, "seek": 190764, "start": 1930.6000000000001, "end": 1937.16, "text": " but they can randomly disappear from you. It's also related to ensemble models like model bagging", "tokens": [457, 436, 393, 16979, 11596, 490, 291, 13, 467, 311, 611, 4077, 281, 19492, 5245, 411, 2316, 3411, 3249], "temperature": 0.0, "avg_logprob": -0.10382209051223028, "compression_ratio": 1.9126984126984128, "no_speech_prob": 1.8618806279846467e-05}, {"id": 156, "seek": 193716, "start": 1937.16, "end": 1944.6000000000001, "text": " because you're using different subsets of the features every time. But after all of those", "tokens": [570, 291, 434, 1228, 819, 2090, 1385, 295, 264, 4122, 633, 565, 13, 583, 934, 439, 295, 729], "temperature": 0.0, "avg_logprob": -0.11216509485819254, "compression_ratio": 1.6593886462882097, "no_speech_prob": 6.238220066734357e-06}, {"id": 157, "seek": 193716, "start": 1944.6000000000001, "end": 1950.76, "text": " explanations there's actually another way of thinking about dropout which was actually developed", "tokens": [28708, 456, 311, 767, 1071, 636, 295, 1953, 466, 3270, 346, 597, 390, 767, 4743], "temperature": 0.0, "avg_logprob": -0.11216509485819254, "compression_ratio": 1.6593886462882097, "no_speech_prob": 6.238220066734357e-06}, {"id": 158, "seek": 193716, "start": 1950.76, "end": 1958.1200000000001, "text": " here at Stanford as a paper by personally angling students which is to argue that really what dropout", "tokens": [510, 412, 20374, 382, 257, 3035, 538, 5665, 2562, 1688, 1731, 597, 307, 281, 9695, 300, 534, 437, 3270, 346], "temperature": 0.0, "avg_logprob": -0.11216509485819254, "compression_ratio": 1.6593886462882097, "no_speech_prob": 6.238220066734357e-06}, {"id": 159, "seek": 193716, "start": 1958.1200000000001, "end": 1965.24, "text": " gives you is a strong regularizer that isn't a uniform regularizer like L2 that regularizes", "tokens": [2709, 291, 307, 257, 2068, 3890, 6545, 300, 1943, 380, 257, 9452, 3890, 6545, 411, 441, 17, 300, 3890, 5660], "temperature": 0.0, "avg_logprob": -0.11216509485819254, "compression_ratio": 1.6593886462882097, "no_speech_prob": 6.238220066734357e-06}, {"id": 160, "seek": 196524, "start": 1965.24, "end": 1971.4, "text": " everything with an L2 last but can learn a feature dependent regularization and so that dropout", "tokens": [1203, 365, 364, 441, 17, 1036, 457, 393, 1466, 257, 4111, 12334, 3890, 2144, 293, 370, 300, 3270, 346], "temperature": 0.0, "avg_logprob": -0.08193349308437771, "compression_ratio": 1.648068669527897, "no_speech_prob": 3.760098115890287e-05}, {"id": 161, "seek": 196524, "start": 1971.4, "end": 1978.28, "text": " is just emerged as in general the best way to do regularization for neural nets. I think you've", "tokens": [307, 445, 20178, 382, 294, 2674, 264, 1151, 636, 281, 360, 3890, 2144, 337, 18161, 36170, 13, 286, 519, 291, 600], "temperature": 0.0, "avg_logprob": -0.08193349308437771, "compression_ratio": 1.648068669527897, "no_speech_prob": 3.760098115890287e-05}, {"id": 162, "seek": 196524, "start": 1978.28, "end": 1986.68, "text": " already seen and heard this one but just have it on my slides once. If you want to have your neural", "tokens": [1217, 1612, 293, 2198, 341, 472, 457, 445, 362, 309, 322, 452, 9788, 1564, 13, 759, 291, 528, 281, 362, 428, 18161], "temperature": 0.0, "avg_logprob": -0.08193349308437771, "compression_ratio": 1.648068669527897, "no_speech_prob": 3.760098115890287e-05}, {"id": 163, "seek": 196524, "start": 1986.68, "end": 1994.92, "text": " networks go fast it's really essential that you make use of vectors matrices tensors and you", "tokens": [9590, 352, 2370, 309, 311, 534, 7115, 300, 291, 652, 764, 295, 18875, 32284, 10688, 830, 293, 291], "temperature": 0.0, "avg_logprob": -0.08193349308437771, "compression_ratio": 1.648068669527897, "no_speech_prob": 3.760098115890287e-05}, {"id": 164, "seek": 199492, "start": 1994.92, "end": 2002.6000000000001, "text": " don't do things with for loop. So here's a teeny example where I'm using time it which is a useful", "tokens": [500, 380, 360, 721, 365, 337, 6367, 13, 407, 510, 311, 257, 48232, 1365, 689, 286, 478, 1228, 565, 309, 597, 307, 257, 4420], "temperature": 0.0, "avg_logprob": -0.18370661017012924, "compression_ratio": 1.6166666666666667, "no_speech_prob": 0.00010027447569882497}, {"id": 165, "seek": 199492, "start": 2002.6000000000001, "end": 2007.5600000000002, "text": " thing that you can use too to see where how faster neural nets run in different ways of writing", "tokens": [551, 300, 291, 393, 764, 886, 281, 536, 689, 577, 4663, 18161, 36170, 1190, 294, 819, 2098, 295, 3579], "temperature": 0.0, "avg_logprob": -0.18370661017012924, "compression_ratio": 1.6166666666666667, "no_speech_prob": 0.00010027447569882497}, {"id": 166, "seek": 199492, "start": 2007.5600000000002, "end": 2021.0, "text": " it and so when I'm doing this doing these dot products here I can either do the dot product in a", "tokens": [309, 293, 370, 562, 286, 478, 884, 341, 884, 613, 5893, 3383, 510, 286, 393, 2139, 360, 264, 5893, 1674, 294, 257], "temperature": 0.0, "avg_logprob": -0.18370661017012924, "compression_ratio": 1.6166666666666667, "no_speech_prob": 0.00010027447569882497}, {"id": 167, "seek": 202100, "start": 2021.0, "end": 2029.4, "text": " for loop against each word vector or I can do the dot product with a single word vector matrix", "tokens": [337, 6367, 1970, 1184, 1349, 8062, 420, 286, 393, 360, 264, 5893, 1674, 365, 257, 2167, 1349, 8062, 8141], "temperature": 0.0, "avg_logprob": -0.06161954743521554, "compression_ratio": 1.670520231213873, "no_speech_prob": 8.471902401652187e-05}, {"id": 168, "seek": 202100, "start": 2029.4, "end": 2040.04, "text": " and if I do it in a for loop doing each loop takes me almost a second whereas if I do it with a", "tokens": [293, 498, 286, 360, 309, 294, 257, 337, 6367, 884, 1184, 6367, 2516, 385, 1920, 257, 1150, 9735, 498, 286, 360, 309, 365, 257], "temperature": 0.0, "avg_logprob": -0.06161954743521554, "compression_ratio": 1.670520231213873, "no_speech_prob": 8.471902401652187e-05}, {"id": 169, "seek": 202100, "start": 2041.24, "end": 2047.88, "text": " matrix multiply it takes me an order of magnitude less time so you should always be looking to use", "tokens": [8141, 12972, 309, 2516, 385, 364, 1668, 295, 15668, 1570, 565, 370, 291, 820, 1009, 312, 1237, 281, 764], "temperature": 0.0, "avg_logprob": -0.06161954743521554, "compression_ratio": 1.670520231213873, "no_speech_prob": 8.471902401652187e-05}, {"id": 170, "seek": 204788, "start": 2047.88, "end": 2054.28, "text": " vectors and matrices not for loops and this is a speed up of about 10 times when you're doing things", "tokens": [18875, 293, 32284, 406, 337, 16121, 293, 341, 307, 257, 3073, 493, 295, 466, 1266, 1413, 562, 291, 434, 884, 721], "temperature": 0.0, "avg_logprob": -0.09431037169236403, "compression_ratio": 1.565217391304348, "no_speech_prob": 4.538887151284143e-05}, {"id": 171, "seek": 204788, "start": 2054.28, "end": 2062.2000000000003, "text": " on a CPU heading forward we're going to be using GPUs and they only further exaggerate the", "tokens": [322, 257, 13199, 9864, 2128, 321, 434, 516, 281, 312, 1228, 18407, 82, 293, 436, 787, 3052, 19123, 473, 264], "temperature": 0.0, "avg_logprob": -0.09431037169236403, "compression_ratio": 1.565217391304348, "no_speech_prob": 4.538887151284143e-05}, {"id": 172, "seek": 204788, "start": 2062.2000000000003, "end": 2067.56, "text": " advantages of using vectors and matrices where you'll commonly get two orders of magnitude speed", "tokens": [14906, 295, 1228, 18875, 293, 32284, 689, 291, 603, 12719, 483, 732, 9470, 295, 15668, 3073], "temperature": 0.0, "avg_logprob": -0.09431037169236403, "compression_ratio": 1.565217391304348, "no_speech_prob": 4.538887151284143e-05}, {"id": 173, "seek": 206756, "start": 2067.56, "end": 2078.92, "text": " up by doing things that way. Yeah so for the backward pass you are running a backward passes before", "tokens": [493, 538, 884, 721, 300, 636, 13, 865, 370, 337, 264, 23897, 1320, 291, 366, 2614, 257, 23897, 11335, 949], "temperature": 0.0, "avg_logprob": -0.13615303947812035, "compression_ratio": 1.6744186046511629, "no_speech_prob": 4.7563058615196496e-05}, {"id": 174, "seek": 206756, "start": 2078.92, "end": 2087.32, "text": " on the drop down examples right so for the things that were dropped out no gradient is going through", "tokens": [322, 264, 3270, 760, 5110, 558, 370, 337, 264, 721, 300, 645, 8119, 484, 572, 16235, 307, 516, 807], "temperature": 0.0, "avg_logprob": -0.13615303947812035, "compression_ratio": 1.6744186046511629, "no_speech_prob": 4.7563058615196496e-05}, {"id": 175, "seek": 206756, "start": 2087.32, "end": 2094.36, "text": " them because they weren't present they're not affecting things so in a particular batch", "tokens": [552, 570, 436, 4999, 380, 1974, 436, 434, 406, 17476, 721, 370, 294, 257, 1729, 15245], "temperature": 0.0, "avg_logprob": -0.13615303947812035, "compression_ratio": 1.6744186046511629, "no_speech_prob": 4.7563058615196496e-05}, {"id": 176, "seek": 209436, "start": 2094.36, "end": 2101.32, "text": " you're only training weights for the things that aren't dropped out but then since you for each", "tokens": [291, 434, 787, 3097, 17443, 337, 264, 721, 300, 3212, 380, 8119, 484, 457, 550, 1670, 291, 337, 1184], "temperature": 0.0, "avg_logprob": -0.08021042838929192, "compression_ratio": 1.653179190751445, "no_speech_prob": 8.47757255542092e-05}, {"id": 177, "seek": 209436, "start": 2101.32, "end": 2107.7200000000003, "text": " successive batch you drop out different things that over a bunch of batches you're then training", "tokens": [48043, 15245, 291, 3270, 484, 819, 721, 300, 670, 257, 3840, 295, 15245, 279, 291, 434, 550, 3097], "temperature": 0.0, "avg_logprob": -0.08021042838929192, "compression_ratio": 1.653179190751445, "no_speech_prob": 8.47757255542092e-05}, {"id": 178, "seek": 209436, "start": 2107.7200000000003, "end": 2118.52, "text": " all of the weights of the model and so feature dependent regularizer is meaning that how much", "tokens": [439, 295, 264, 17443, 295, 264, 2316, 293, 370, 4111, 12334, 3890, 6545, 307, 3620, 300, 577, 709], "temperature": 0.0, "avg_logprob": -0.08021042838929192, "compression_ratio": 1.653179190751445, "no_speech_prob": 8.47757255542092e-05}, {"id": 179, "seek": 211852, "start": 2118.52, "end": 2129.24, "text": " a feature the different features can be regularized different amounts to maximize performance", "tokens": [257, 4111, 264, 819, 4122, 393, 312, 3890, 1602, 819, 11663, 281, 19874, 3389], "temperature": 0.0, "avg_logprob": -0.11157063306388208, "compression_ratio": 1.6726190476190477, "no_speech_prob": 1.9516537577146664e-05}, {"id": 180, "seek": 211852, "start": 2129.8, "end": 2138.52, "text": " so back in this model every feature was just sort of being penalized by taking lambda times", "tokens": [370, 646, 294, 341, 2316, 633, 4111, 390, 445, 1333, 295, 885, 13661, 1602, 538, 1940, 13607, 1413], "temperature": 0.0, "avg_logprob": -0.11157063306388208, "compression_ratio": 1.6726190476190477, "no_speech_prob": 1.9516537577146664e-05}, {"id": 181, "seek": 211852, "start": 2138.52, "end": 2146.92, "text": " at squared value so this is sort of uniform regularization where the end result of this dropout", "tokens": [412, 8889, 2158, 370, 341, 307, 1333, 295, 9452, 3890, 2144, 689, 264, 917, 1874, 295, 341, 3270, 346], "temperature": 0.0, "avg_logprob": -0.11157063306388208, "compression_ratio": 1.6726190476190477, "no_speech_prob": 1.9516537577146664e-05}, {"id": 182, "seek": 214692, "start": 2146.92, "end": 2154.2000000000003, "text": " style training is that you end up with some features being regularized much more strongly", "tokens": [3758, 3097, 307, 300, 291, 917, 493, 365, 512, 4122, 885, 3890, 1602, 709, 544, 10613], "temperature": 0.0, "avg_logprob": -0.08571608861287434, "compression_ratio": 1.9375, "no_speech_prob": 7.667300815228373e-05}, {"id": 183, "seek": 214692, "start": 2154.2000000000003, "end": 2163.7200000000003, "text": " and some other features being regularized less strongly and how much they regularize depends on", "tokens": [293, 512, 661, 4122, 885, 3890, 1602, 1570, 10613, 293, 577, 709, 436, 3890, 1125, 5946, 322], "temperature": 0.0, "avg_logprob": -0.08571608861287434, "compression_ratio": 1.9375, "no_speech_prob": 7.667300815228373e-05}, {"id": 184, "seek": 214692, "start": 2163.7200000000003, "end": 2169.96, "text": " how much they're being used so you're regularizing more features that are being used less but I'm", "tokens": [577, 709, 436, 434, 885, 1143, 370, 291, 434, 3890, 3319, 544, 4122, 300, 366, 885, 1143, 1570, 457, 286, 478], "temperature": 0.0, "avg_logprob": -0.08571608861287434, "compression_ratio": 1.9375, "no_speech_prob": 7.667300815228373e-05}, {"id": 185, "seek": 214692, "start": 2171.0, "end": 2175.32, "text": " I'm not going to get through into the details of how you can understand that perspective", "tokens": [286, 478, 406, 516, 281, 483, 807, 666, 264, 4365, 295, 577, 291, 393, 1223, 300, 4585], "temperature": 0.0, "avg_logprob": -0.08571608861287434, "compression_ratio": 1.9375, "no_speech_prob": 7.667300815228373e-05}, {"id": 186, "seek": 217532, "start": 2175.32, "end": 2182.52, "text": " that's that that's outside of context what I'm going to get through right now so the final bit is", "tokens": [300, 311, 300, 300, 311, 2380, 295, 4319, 437, 286, 478, 516, 281, 483, 807, 558, 586, 370, 264, 2572, 857, 307], "temperature": 0.0, "avg_logprob": -0.14095724256415115, "compression_ratio": 1.670391061452514, "no_speech_prob": 0.00017667401698417962}, {"id": 187, "seek": 217532, "start": 2182.52, "end": 2191.88, "text": " I just wanted to give a little bit of perspective on non-linearities in our neural nets so the first", "tokens": [286, 445, 1415, 281, 976, 257, 707, 857, 295, 4585, 322, 2107, 12, 28263, 1088, 294, 527, 18161, 36170, 370, 264, 700], "temperature": 0.0, "avg_logprob": -0.14095724256415115, "compression_ratio": 1.670391061452514, "no_speech_prob": 0.00017667401698417962}, {"id": 188, "seek": 217532, "start": 2191.88, "end": 2199.0800000000004, "text": " thing to remember is you have to have non-linearities so if you're building a multi-layer neural net", "tokens": [551, 281, 1604, 307, 291, 362, 281, 362, 2107, 12, 28263, 1088, 370, 498, 291, 434, 2390, 257, 4825, 12, 8376, 260, 18161, 2533], "temperature": 0.0, "avg_logprob": -0.14095724256415115, "compression_ratio": 1.670391061452514, "no_speech_prob": 0.00017667401698417962}, {"id": 189, "seek": 219908, "start": 2199.08, "end": 2206.2, "text": " and you've just got you know w1 x plus b1 then you put it through w2 x plus b2 and then put", "tokens": [293, 291, 600, 445, 658, 291, 458, 261, 16, 2031, 1804, 272, 16, 550, 291, 829, 309, 807, 261, 17, 2031, 1804, 272, 17, 293, 550, 829], "temperature": 0.0, "avg_logprob": -0.12477669664608534, "compression_ratio": 1.7887323943661972, "no_speech_prob": 6.0978909459663555e-05}, {"id": 190, "seek": 219908, "start": 2206.2, "end": 2213.48, "text": " through w3 x well I guess they're different hidden layers so I should have said x they should be", "tokens": [807, 261, 18, 2031, 731, 286, 2041, 436, 434, 819, 7633, 7914, 370, 286, 820, 362, 848, 2031, 436, 820, 312], "temperature": 0.0, "avg_logprob": -0.12477669664608534, "compression_ratio": 1.7887323943661972, "no_speech_prob": 6.0978909459663555e-05}, {"id": 191, "seek": 219908, "start": 2213.48, "end": 2221.96, "text": " hidden one hidden two hidden three w3 hidden three plus b3 that multiple linear transformations", "tokens": [7633, 472, 7633, 732, 7633, 1045, 261, 18, 7633, 1045, 1804, 272, 18, 300, 3866, 8213, 34852], "temperature": 0.0, "avg_logprob": -0.12477669664608534, "compression_ratio": 1.7887323943661972, "no_speech_prob": 6.0978909459663555e-05}, {"id": 192, "seek": 219908, "start": 2222.84, "end": 2228.68, "text": " composed so they can be just collapsed down into a single linear transformation so you don't get", "tokens": [18204, 370, 436, 393, 312, 445, 24578, 760, 666, 257, 2167, 8213, 9887, 370, 291, 500, 380, 483], "temperature": 0.0, "avg_logprob": -0.12477669664608534, "compression_ratio": 1.7887323943661972, "no_speech_prob": 6.0978909459663555e-05}, {"id": 193, "seek": 222868, "start": 2228.68, "end": 2239.24, "text": " any power as a data representation by having multiple linear layers there's a slightly longer story", "tokens": [604, 1347, 382, 257, 1412, 10290, 538, 1419, 3866, 8213, 7914, 456, 311, 257, 4748, 2854, 1657], "temperature": 0.0, "avg_logprob": -0.05066147683158753, "compression_ratio": 1.5806451612903225, "no_speech_prob": 3.3201180485775694e-05}, {"id": 194, "seek": 222868, "start": 2239.24, "end": 2243.3999999999996, "text": " there because you actually do get some interesting learning effects but I'm not going to talk about", "tokens": [456, 570, 291, 767, 360, 483, 512, 1880, 2539, 5065, 457, 286, 478, 406, 516, 281, 751, 466], "temperature": 0.0, "avg_logprob": -0.05066147683158753, "compression_ratio": 1.5806451612903225, "no_speech_prob": 3.3201180485775694e-05}, {"id": 195, "seek": 222868, "start": 2243.3999999999996, "end": 2253.72, "text": " that now but standardly we have to have some kind of non-linearity to do something interesting", "tokens": [300, 586, 457, 3832, 356, 321, 362, 281, 362, 512, 733, 295, 2107, 12, 1889, 17409, 281, 360, 746, 1880], "temperature": 0.0, "avg_logprob": -0.05066147683158753, "compression_ratio": 1.5806451612903225, "no_speech_prob": 3.3201180485775694e-05}, {"id": 196, "seek": 225372, "start": 2253.72, "end": 2261.7999999999997, "text": " in a deep neural network okay so there's a starting a starting point is the most classic non-linearity", "tokens": [294, 257, 2452, 18161, 3209, 1392, 370, 456, 311, 257, 2891, 257, 2891, 935, 307, 264, 881, 7230, 2107, 12, 1889, 17409], "temperature": 0.0, "avg_logprob": -0.1041569709777832, "compression_ratio": 1.6077348066298343, "no_speech_prob": 1.2799874639313202e-05}, {"id": 197, "seek": 225372, "start": 2261.7999999999997, "end": 2268.9199999999996, "text": " is the logistic often just called the sigmine non-linearity because of its s shape which we've", "tokens": [307, 264, 3565, 3142, 2049, 445, 1219, 264, 4556, 76, 533, 2107, 12, 1889, 17409, 570, 295, 1080, 262, 3909, 597, 321, 600], "temperature": 0.0, "avg_logprob": -0.1041569709777832, "compression_ratio": 1.6077348066298343, "no_speech_prob": 1.2799874639313202e-05}, {"id": 198, "seek": 225372, "start": 2268.9199999999996, "end": 2276.12, "text": " seen before in previous lectures so this will take any real number and map it on to the range", "tokens": [1612, 949, 294, 3894, 16564, 370, 341, 486, 747, 604, 957, 1230, 293, 4471, 309, 322, 281, 264, 3613], "temperature": 0.0, "avg_logprob": -0.1041569709777832, "compression_ratio": 1.6077348066298343, "no_speech_prob": 1.2799874639313202e-05}, {"id": 199, "seek": 227612, "start": 2276.12, "end": 2286.12, "text": " of 0 1 and that was sort of basically what people used in sort of 1980s neural nets now one", "tokens": [295, 1958, 502, 293, 300, 390, 1333, 295, 1936, 437, 561, 1143, 294, 1333, 295, 13626, 82, 18161, 36170, 586, 472], "temperature": 0.0, "avg_logprob": -0.07415851714119079, "compression_ratio": 1.5166666666666666, "no_speech_prob": 8.010614692466334e-06}, {"id": 200, "seek": 227612, "start": 2286.12, "end": 2294.44, "text": " disadvantage of this non-linearity is that it's moving everything into the positive space", "tokens": [24292, 295, 341, 2107, 12, 1889, 17409, 307, 300, 309, 311, 2684, 1203, 666, 264, 3353, 1901], "temperature": 0.0, "avg_logprob": -0.07415851714119079, "compression_ratio": 1.5166666666666666, "no_speech_prob": 8.010614692466334e-06}, {"id": 201, "seek": 227612, "start": 2294.44, "end": 2301.08, "text": " because the output was always between 0 and 1 so people then decided that for many purposes", "tokens": [570, 264, 5598, 390, 1009, 1296, 1958, 293, 502, 370, 561, 550, 3047, 300, 337, 867, 9932], "temperature": 0.0, "avg_logprob": -0.07415851714119079, "compression_ratio": 1.5166666666666666, "no_speech_prob": 8.010614692466334e-06}, {"id": 202, "seek": 230108, "start": 2301.08, "end": 2308.2799999999997, "text": " it was useful to have this variant sigmois shape of hyperbolic tan which is then being shown", "tokens": [309, 390, 4420, 281, 362, 341, 17501, 4556, 3280, 271, 3909, 295, 9848, 65, 7940, 7603, 597, 307, 550, 885, 4898], "temperature": 0.0, "avg_logprob": -0.07845771982428733, "compression_ratio": 1.7031963470319635, "no_speech_prob": 1.7771677448763512e-05}, {"id": 203, "seek": 230108, "start": 2308.2799999999997, "end": 2315.88, "text": " in the second picture now you know logistic and hyperbolic tan they sound like they're very", "tokens": [294, 264, 1150, 3036, 586, 291, 458, 3565, 3142, 293, 9848, 65, 7940, 7603, 436, 1626, 411, 436, 434, 588], "temperature": 0.0, "avg_logprob": -0.07845771982428733, "compression_ratio": 1.7031963470319635, "no_speech_prob": 1.7771677448763512e-05}, {"id": 204, "seek": 230108, "start": 2315.88, "end": 2321.72, "text": " different things but actually as you maybe remember from a math class hyperbolic tan can be", "tokens": [819, 721, 457, 767, 382, 291, 1310, 1604, 490, 257, 5221, 1508, 9848, 65, 7940, 7603, 393, 312], "temperature": 0.0, "avg_logprob": -0.07845771982428733, "compression_ratio": 1.7031963470319635, "no_speech_prob": 1.7771677448763512e-05}, {"id": 205, "seek": 230108, "start": 2321.72, "end": 2327.24, "text": " represented in terms of exponentials as well and if you do a bit of math which possibly we might", "tokens": [10379, 294, 2115, 295, 21510, 82, 382, 731, 293, 498, 291, 360, 257, 857, 295, 5221, 597, 6264, 321, 1062], "temperature": 0.0, "avg_logprob": -0.07845771982428733, "compression_ratio": 1.7031963470319635, "no_speech_prob": 1.7771677448763512e-05}, {"id": 206, "seek": 232724, "start": 2327.24, "end": 2333.24, "text": " make you do on an assignment it's actually the case that a hyperbolic tangent is just a rescaled", "tokens": [652, 291, 360, 322, 364, 15187, 309, 311, 767, 264, 1389, 300, 257, 9848, 65, 7940, 27747, 307, 445, 257, 9610, 5573], "temperature": 0.0, "avg_logprob": -0.08827382723490397, "compression_ratio": 1.6796536796536796, "no_speech_prob": 2.143892015737947e-05}, {"id": 207, "seek": 232724, "start": 2333.24, "end": 2339.4799999999996, "text": " and shifted version of the logistic so it's really exactly the same curve just squeezed a bit so", "tokens": [293, 18892, 3037, 295, 264, 3565, 3142, 370, 309, 311, 534, 2293, 264, 912, 7605, 445, 39470, 257, 857, 370], "temperature": 0.0, "avg_logprob": -0.08827382723490397, "compression_ratio": 1.6796536796536796, "no_speech_prob": 2.143892015737947e-05}, {"id": 208, "seek": 232724, "start": 2339.4799999999996, "end": 2349.16, "text": " it goes now symmetrically between minus 1 and 1 well these kind of transcendental functions like", "tokens": [309, 1709, 586, 14232, 27965, 984, 1296, 3175, 502, 293, 502, 731, 613, 733, 295, 28535, 14533, 6828, 411], "temperature": 0.0, "avg_logprob": -0.08827382723490397, "compression_ratio": 1.6796536796536796, "no_speech_prob": 2.143892015737947e-05}, {"id": 209, "seek": 232724, "start": 2349.16, "end": 2355.4799999999996, "text": " hyperbolic tangent they're kind of slow and expensive to compute right even on our fast computers", "tokens": [9848, 65, 7940, 27747, 436, 434, 733, 295, 2964, 293, 5124, 281, 14722, 558, 754, 322, 527, 2370, 10807], "temperature": 0.0, "avg_logprob": -0.08827382723490397, "compression_ratio": 1.6796536796536796, "no_speech_prob": 2.143892015737947e-05}, {"id": 210, "seek": 235548, "start": 2355.48, "end": 2362.2, "text": " calculating exponentials is a bit slow so something people became interested in was well could we do", "tokens": [28258, 21510, 82, 307, 257, 857, 2964, 370, 746, 561, 3062, 3102, 294, 390, 731, 727, 321, 360], "temperature": 0.0, "avg_logprob": -0.12134113827267208, "compression_ratio": 1.5879120879120878, "no_speech_prob": 4.466414975468069e-05}, {"id": 211, "seek": 235548, "start": 2362.2, "end": 2370.76, "text": " things with much simpler non-linearity so what if we used a so-called hard 10h so the hard 10h", "tokens": [721, 365, 709, 18587, 2107, 12, 1889, 17409, 370, 437, 498, 321, 1143, 257, 370, 12, 11880, 1152, 1266, 71, 370, 264, 1152, 1266, 71], "temperature": 0.0, "avg_logprob": -0.12134113827267208, "compression_ratio": 1.5879120879120878, "no_speech_prob": 4.466414975468069e-05}, {"id": 212, "seek": 235548, "start": 2371.88, "end": 2382.12, "text": " at some point up to some point it just flat lines at minus 1 then it is y equals x up until 1", "tokens": [412, 512, 935, 493, 281, 512, 935, 309, 445, 4962, 3876, 412, 3175, 502, 550, 309, 307, 288, 6915, 2031, 493, 1826, 502], "temperature": 0.0, "avg_logprob": -0.12134113827267208, "compression_ratio": 1.5879120879120878, "no_speech_prob": 4.466414975468069e-05}, {"id": 213, "seek": 238212, "start": 2382.12, "end": 2389.72, "text": " and then it just flat lines again and you know that seems a slightly weird thing to use because", "tokens": [293, 550, 309, 445, 4962, 3876, 797, 293, 291, 458, 300, 2544, 257, 4748, 3657, 551, 281, 764, 570], "temperature": 0.0, "avg_logprob": -0.13992865635798526, "compression_ratio": 1.608695652173913, "no_speech_prob": 2.2094847736298107e-05}, {"id": 214, "seek": 238212, "start": 2389.72, "end": 2397.24, "text": " if your input is over on the left or over on the right you're sort of not getting any discrimination", "tokens": [498, 428, 4846, 307, 670, 322, 264, 1411, 420, 670, 322, 264, 558, 291, 434, 1333, 295, 406, 1242, 604, 15973], "temperature": 0.0, "avg_logprob": -0.13992865635798526, "compression_ratio": 1.608695652173913, "no_speech_prob": 2.2094847736298107e-05}, {"id": 215, "seek": 238212, "start": 2397.24, "end": 2404.2799999999997, "text": " in everything's giving the same output but somewhat surprisingly I mean I was surprised when people", "tokens": [294, 1203, 311, 2902, 264, 912, 5598, 457, 8344, 17600, 286, 914, 286, 390, 6100, 562, 561], "temperature": 0.0, "avg_logprob": -0.13992865635798526, "compression_ratio": 1.608695652173913, "no_speech_prob": 2.2094847736298107e-05}, {"id": 216, "seek": 240428, "start": 2404.28, "end": 2413.6400000000003, "text": " started doing this these kind of models proved to be very successful and so that then led into", "tokens": [1409, 884, 341, 613, 733, 295, 5245, 14617, 281, 312, 588, 4406, 293, 370, 300, 550, 4684, 666], "temperature": 0.0, "avg_logprob": -0.09148645401000977, "compression_ratio": 1.6145251396648044, "no_speech_prob": 5.061062620370649e-05}, {"id": 217, "seek": 240428, "start": 2413.6400000000003, "end": 2419.88, "text": " what's proven to be kind of the most successful and generally widely used non-linearity in a lot", "tokens": [437, 311, 12785, 281, 312, 733, 295, 264, 881, 4406, 293, 5101, 13371, 1143, 2107, 12, 1889, 17409, 294, 257, 688], "temperature": 0.0, "avg_logprob": -0.09148645401000977, "compression_ratio": 1.6145251396648044, "no_speech_prob": 5.061062620370649e-05}, {"id": 218, "seek": 240428, "start": 2419.88, "end": 2428.0400000000004, "text": " of recent deep learning work which was what was being used in the dependency paths model I showed", "tokens": [295, 5162, 2452, 2539, 589, 597, 390, 437, 390, 885, 1143, 294, 264, 33621, 14518, 2316, 286, 4712], "temperature": 0.0, "avg_logprob": -0.09148645401000977, "compression_ratio": 1.6145251396648044, "no_speech_prob": 5.061062620370649e-05}, {"id": 219, "seek": 242804, "start": 2428.04, "end": 2434.12, "text": " is what's called the rectified linear unit or value so a real U is kind of the simplest kind of", "tokens": [307, 437, 311, 1219, 264, 11048, 2587, 8213, 4985, 420, 2158, 370, 257, 957, 624, 307, 733, 295, 264, 22811, 733, 295], "temperature": 0.0, "avg_logprob": -0.10279425303141276, "compression_ratio": 1.6628571428571428, "no_speech_prob": 1.8047991034109145e-05}, {"id": 220, "seek": 242804, "start": 2434.12, "end": 2441.24, "text": " non-linearity that you can imagine so if the value of x is negative it's value is 0 so effectively", "tokens": [2107, 12, 1889, 17409, 300, 291, 393, 3811, 370, 498, 264, 2158, 295, 2031, 307, 3671, 309, 311, 2158, 307, 1958, 370, 8659], "temperature": 0.0, "avg_logprob": -0.10279425303141276, "compression_ratio": 1.6628571428571428, "no_speech_prob": 1.8047991034109145e-05}, {"id": 221, "seek": 242804, "start": 2441.24, "end": 2449.16, "text": " it's just dead it's not doing anything in the computation and if it's value of x is greater than", "tokens": [309, 311, 445, 3116, 309, 311, 406, 884, 1340, 294, 264, 24903, 293, 498, 309, 311, 2158, 295, 2031, 307, 5044, 813], "temperature": 0.0, "avg_logprob": -0.10279425303141276, "compression_ratio": 1.6628571428571428, "no_speech_prob": 1.8047991034109145e-05}, {"id": 222, "seek": 244916, "start": 2449.16, "end": 2458.92, "text": " 0 then it's just simply y equals x the value as being passed through and at first sight this might", "tokens": [1958, 550, 309, 311, 445, 2935, 288, 6915, 2031, 264, 2158, 382, 885, 4678, 807, 293, 412, 700, 7860, 341, 1062], "temperature": 0.0, "avg_logprob": -0.07545605827780331, "compression_ratio": 1.6995515695067265, "no_speech_prob": 3.338104306749301e-06}, {"id": 223, "seek": 244916, "start": 2458.92, "end": 2465.08, "text": " seem really really weird and how could this be useful as a non-linearity but if you sort of think", "tokens": [1643, 534, 534, 3657, 293, 577, 727, 341, 312, 4420, 382, 257, 2107, 12, 1889, 17409, 457, 498, 291, 1333, 295, 519], "temperature": 0.0, "avg_logprob": -0.07545605827780331, "compression_ratio": 1.6995515695067265, "no_speech_prob": 3.338104306749301e-06}, {"id": 224, "seek": 244916, "start": 2465.08, "end": 2471.96, "text": " a bit about how you can approximate things with piecewise linear functions very accurately you", "tokens": [257, 857, 466, 577, 291, 393, 30874, 721, 365, 2522, 3711, 8213, 6828, 588, 20095, 291], "temperature": 0.0, "avg_logprob": -0.07545605827780331, "compression_ratio": 1.6995515695067265, "no_speech_prob": 3.338104306749301e-06}, {"id": 225, "seek": 244916, "start": 2471.96, "end": 2478.3599999999997, "text": " might kind of start to see how you could use this to do accurate function approximation", "tokens": [1062, 733, 295, 722, 281, 536, 577, 291, 727, 764, 341, 281, 360, 8559, 2445, 28023], "temperature": 0.0, "avg_logprob": -0.07545605827780331, "compression_ratio": 1.6995515695067265, "no_speech_prob": 3.338104306749301e-06}, {"id": 226, "seek": 247836, "start": 2478.36, "end": 2484.92, "text": " with piecewise linear functions and that's what value units have been found to do extremely", "tokens": [365, 2522, 3711, 8213, 6828, 293, 300, 311, 437, 2158, 6815, 362, 668, 1352, 281, 360, 4664], "temperature": 0.0, "avg_logprob": -0.11527488397997479, "compression_ratio": 1.6902654867256637, "no_speech_prob": 4.8922764108283445e-05}, {"id": 227, "seek": 247836, "start": 2484.92, "end": 2492.92, "text": " extremely successfully so logistic and tanH are still used in various places you use logistic when", "tokens": [4664, 10727, 370, 3565, 3142, 293, 7603, 39, 366, 920, 1143, 294, 3683, 3190, 291, 764, 3565, 3142, 562], "temperature": 0.0, "avg_logprob": -0.11527488397997479, "compression_ratio": 1.6902654867256637, "no_speech_prob": 4.8922764108283445e-05}, {"id": 228, "seek": 247836, "start": 2492.92, "end": 2498.44, "text": " you want a probability output we'll see tanH's again very soon when we get to a current neural", "tokens": [291, 528, 257, 8482, 5598, 321, 603, 536, 7603, 39, 311, 797, 588, 2321, 562, 321, 483, 281, 257, 2190, 18161], "temperature": 0.0, "avg_logprob": -0.11527488397997479, "compression_ratio": 1.6902654867256637, "no_speech_prob": 4.8922764108283445e-05}, {"id": 229, "seek": 247836, "start": 2498.44, "end": 2504.84, "text": " networks but they're no longer the default when making deep networks that in a lot of places the", "tokens": [9590, 457, 436, 434, 572, 2854, 264, 7576, 562, 1455, 2452, 9590, 300, 294, 257, 688, 295, 3190, 264], "temperature": 0.0, "avg_logprob": -0.11527488397997479, "compression_ratio": 1.6902654867256637, "no_speech_prob": 4.8922764108283445e-05}, {"id": 230, "seek": 250484, "start": 2504.84, "end": 2510.6800000000003, "text": " first thing you should think about trying is relu non-linearities and so in particular", "tokens": [700, 551, 291, 820, 519, 466, 1382, 307, 1039, 84, 2107, 12, 1889, 289, 1088, 293, 370, 294, 1729], "temperature": 0.0, "avg_logprob": -0.14427571016199447, "compression_ratio": 1.7867298578199051, "no_speech_prob": 5.9180852986173704e-05}, {"id": 231, "seek": 250484, "start": 2512.52, "end": 2521.2400000000002, "text": " that why part of why they're good is that relu non networks train very quickly because you get", "tokens": [300, 983, 644, 295, 983, 436, 434, 665, 307, 300, 1039, 84, 2107, 9590, 3847, 588, 2661, 570, 291, 483], "temperature": 0.0, "avg_logprob": -0.14427571016199447, "compression_ratio": 1.7867298578199051, "no_speech_prob": 5.9180852986173704e-05}, {"id": 232, "seek": 250484, "start": 2521.2400000000002, "end": 2527.2400000000002, "text": " this sort of very straightforward gradient backflow because providing you on the right hand side", "tokens": [341, 1333, 295, 588, 15325, 16235, 646, 10565, 570, 6530, 291, 322, 264, 558, 1011, 1252], "temperature": 0.0, "avg_logprob": -0.14427571016199447, "compression_ratio": 1.7867298578199051, "no_speech_prob": 5.9180852986173704e-05}, {"id": 233, "seek": 250484, "start": 2527.2400000000002, "end": 2533.48, "text": " of it you then just getting this sort of constant gradient backflow from the slope one and so they", "tokens": [295, 309, 291, 550, 445, 1242, 341, 1333, 295, 5754, 16235, 646, 10565, 490, 264, 13525, 472, 293, 370, 436], "temperature": 0.0, "avg_logprob": -0.14427571016199447, "compression_ratio": 1.7867298578199051, "no_speech_prob": 5.9180852986173704e-05}, {"id": 234, "seek": 253348, "start": 2533.48, "end": 2541.08, "text": " train very quickly the somewhat surprising fact is that sort of almost the simplest non-linearity", "tokens": [3847, 588, 2661, 264, 8344, 8830, 1186, 307, 300, 1333, 295, 1920, 264, 22811, 2107, 12, 1889, 17409], "temperature": 0.0, "avg_logprob": -0.10354326978141878, "compression_ratio": 1.6972477064220184, "no_speech_prob": 2.584655703685712e-05}, {"id": 235, "seek": 253348, "start": 2541.08, "end": 2548.52, "text": " imaginable is still enough to have a very good neural network but it just is people have played", "tokens": [23427, 712, 307, 920, 1547, 281, 362, 257, 588, 665, 18161, 3209, 457, 309, 445, 307, 561, 362, 3737], "temperature": 0.0, "avg_logprob": -0.10354326978141878, "compression_ratio": 1.6972477064220184, "no_speech_prob": 2.584655703685712e-05}, {"id": 236, "seek": 253348, "start": 2548.52, "end": 2554.76, "text": " around the variance of that so people have then played around with leaky relus where rather than", "tokens": [926, 264, 21977, 295, 300, 370, 561, 362, 550, 3737, 926, 365, 476, 15681, 1039, 301, 689, 2831, 813], "temperature": 0.0, "avg_logprob": -0.10354326978141878, "compression_ratio": 1.6972477064220184, "no_speech_prob": 2.584655703685712e-05}, {"id": 237, "seek": 253348, "start": 2555.8, "end": 2561.72, "text": " the left hand side just going completely to zero it goes slightly negative on a", "tokens": [264, 1411, 1011, 1252, 445, 516, 2584, 281, 4018, 309, 1709, 4748, 3671, 322, 257], "temperature": 0.0, "avg_logprob": -0.10354326978141878, "compression_ratio": 1.6972477064220184, "no_speech_prob": 2.584655703685712e-05}, {"id": 238, "seek": 256172, "start": 2561.72, "end": 2569.7999999999997, "text": " vertmuch shallower slope and then there's been a parametric relu where you have an extra parameter", "tokens": [6509, 76, 625, 4393, 968, 13525, 293, 550, 456, 311, 668, 257, 6220, 17475, 1039, 84, 689, 291, 362, 364, 2857, 13075], "temperature": 0.0, "avg_logprob": -0.12023476759592693, "compression_ratio": 1.6899563318777293, "no_speech_prob": 8.081491250777617e-05}, {"id": 239, "seek": 256172, "start": 2569.7999999999997, "end": 2576.6, "text": " where you learn the slope of the negative part another thing that's been used recently is this", "tokens": [689, 291, 1466, 264, 13525, 295, 264, 3671, 644, 1071, 551, 300, 311, 668, 1143, 3938, 307, 341], "temperature": 0.0, "avg_logprob": -0.12023476759592693, "compression_ratio": 1.6899563318777293, "no_speech_prob": 8.081491250777617e-05}, {"id": 240, "seek": 256172, "start": 2576.6, "end": 2584.2799999999997, "text": " swish non-linearity which looks almost like a relu but it sort of curves down just a little bit", "tokens": [1693, 742, 2107, 12, 1889, 17409, 597, 1542, 1920, 411, 257, 1039, 84, 457, 309, 1333, 295, 19490, 760, 445, 257, 707, 857], "temperature": 0.0, "avg_logprob": -0.12023476759592693, "compression_ratio": 1.6899563318777293, "no_speech_prob": 8.081491250777617e-05}, {"id": 241, "seek": 256172, "start": 2584.2799999999997, "end": 2590.4399999999996, "text": " there and starts to go up I mean I think it's fair to say that you know none of these have really", "tokens": [456, 293, 3719, 281, 352, 493, 286, 914, 286, 519, 309, 311, 3143, 281, 584, 300, 291, 458, 6022, 295, 613, 362, 534], "temperature": 0.0, "avg_logprob": -0.12023476759592693, "compression_ratio": 1.6899563318777293, "no_speech_prob": 8.081491250777617e-05}, {"id": 242, "seek": 259044, "start": 2590.44, "end": 2595.64, "text": " proven themselves vastly superior there are papers saying I can get better results by using one of", "tokens": [12785, 2969, 41426, 13028, 456, 366, 10577, 1566, 286, 393, 483, 1101, 3542, 538, 1228, 472, 295], "temperature": 0.0, "avg_logprob": -0.11374644799665971, "compression_ratio": 1.5602094240837696, "no_speech_prob": 4.510139115154743e-05}, {"id": 243, "seek": 259044, "start": 2595.64, "end": 2601.8, "text": " these and maybe you can but you know it's not night and day and a vast majority of work that you", "tokens": [613, 293, 1310, 291, 393, 457, 291, 458, 309, 311, 406, 1818, 293, 786, 293, 257, 8369, 6286, 295, 589, 300, 291], "temperature": 0.0, "avg_logprob": -0.11374644799665971, "compression_ratio": 1.5602094240837696, "no_speech_prob": 4.510139115154743e-05}, {"id": 244, "seek": 259044, "start": 2601.8, "end": 2613.48, "text": " see around is still just using relus in many places okay a couple more things parameter initialization", "tokens": [536, 926, 307, 920, 445, 1228, 1039, 301, 294, 867, 3190, 1392, 257, 1916, 544, 721, 13075, 5883, 2144], "temperature": 0.0, "avg_logprob": -0.11374644799665971, "compression_ratio": 1.5602094240837696, "no_speech_prob": 4.510139115154743e-05}, {"id": 245, "seek": 261348, "start": 2613.48, "end": 2625.32, "text": " so in almost all cases you must must must initialize the matrices of your neural nets with small random", "tokens": [370, 294, 1920, 439, 3331, 291, 1633, 1633, 1633, 5883, 1125, 264, 32284, 295, 428, 18161, 36170, 365, 1359, 4974], "temperature": 0.0, "avg_logprob": -0.1018855417928388, "compression_ratio": 1.7175141242937852, "no_speech_prob": 1.5663119484088384e-05}, {"id": 246, "seek": 261348, "start": 2625.32, "end": 2633.08, "text": " values neural nets just don't work if you start the matrices off as zero because effectively then", "tokens": [4190, 18161, 36170, 445, 500, 380, 589, 498, 291, 722, 264, 32284, 766, 382, 4018, 570, 8659, 550], "temperature": 0.0, "avg_logprob": -0.1018855417928388, "compression_ratio": 1.7175141242937852, "no_speech_prob": 1.5663119484088384e-05}, {"id": 247, "seek": 263308, "start": 2633.08, "end": 2643.72, "text": " everything is symmetric is symmetric nothing can specialize in different ways and you then get sort of", "tokens": [1203, 307, 32330, 307, 32330, 1825, 393, 37938, 294, 819, 2098, 293, 291, 550, 483, 1333, 295], "temperature": 0.0, "avg_logprob": -0.0964517671553815, "compression_ratio": 1.5824175824175823, "no_speech_prob": 1.2214881280669942e-05}, {"id": 248, "seek": 263308, "start": 2643.72, "end": 2648.92, "text": " you just don't have an ability for a neural net to learn you sort of get this defective solution", "tokens": [291, 445, 500, 380, 362, 364, 3485, 337, 257, 18161, 2533, 281, 1466, 291, 1333, 295, 483, 341, 16445, 488, 3827], "temperature": 0.0, "avg_logprob": -0.0964517671553815, "compression_ratio": 1.5824175824175823, "no_speech_prob": 1.2214881280669942e-05}, {"id": 249, "seek": 263308, "start": 2649.7999999999997, "end": 2657.64, "text": " so standardly you're using some methods such as drawing random numbers uniformly between", "tokens": [370, 3832, 356, 291, 434, 1228, 512, 7150, 1270, 382, 6316, 4974, 3547, 48806, 1296], "temperature": 0.0, "avg_logprob": -0.0964517671553815, "compression_ratio": 1.5824175824175823, "no_speech_prob": 1.2214881280669942e-05}, {"id": 250, "seek": 265764, "start": 2657.64, "end": 2665.24, "text": " minus r and r for a small value r and just filling in all the parameters with that exception", "tokens": [3175, 367, 293, 367, 337, 257, 1359, 2158, 367, 293, 445, 10623, 294, 439, 264, 9834, 365, 300, 11183], "temperature": 0.0, "avg_logprob": -0.0834733009338379, "compression_ratio": 1.6766467065868262, "no_speech_prob": 2.0140560081927106e-05}, {"id": 251, "seek": 265764, "start": 2665.24, "end": 2670.52, "text": " is with bias weights it's fine to set bias weights to zero and in some sense that's better", "tokens": [307, 365, 12577, 17443, 309, 311, 2489, 281, 992, 12577, 17443, 281, 4018, 293, 294, 512, 2020, 300, 311, 1101], "temperature": 0.0, "avg_logprob": -0.0834733009338379, "compression_ratio": 1.6766467065868262, "no_speech_prob": 2.0140560081927106e-05}, {"id": 252, "seek": 265764, "start": 2672.2799999999997, "end": 2681.64, "text": " in terms of choosing what the r value is essentially for traditional neural nets what we want to", "tokens": [294, 2115, 295, 10875, 437, 264, 367, 2158, 307, 4476, 337, 5164, 18161, 36170, 437, 321, 528, 281], "temperature": 0.0, "avg_logprob": -0.0834733009338379, "compression_ratio": 1.6766467065868262, "no_speech_prob": 2.0140560081927106e-05}, {"id": 253, "seek": 268164, "start": 2681.64, "end": 2689.48, "text": " set that r range for is so that the numbers in our neural network stay you're of a reasonable size", "tokens": [992, 300, 367, 3613, 337, 307, 370, 300, 264, 3547, 294, 527, 18161, 3209, 1754, 291, 434, 295, 257, 10585, 2744], "temperature": 0.0, "avg_logprob": -0.10463784081595284, "compression_ratio": 1.6569767441860466, "no_speech_prob": 4.004361107945442e-05}, {"id": 254, "seek": 268164, "start": 2689.48, "end": 2696.7599999999998, "text": " they don't get too big and they don't get too small and whether they kind of blow up or not", "tokens": [436, 500, 380, 483, 886, 955, 293, 436, 500, 380, 483, 886, 1359, 293, 1968, 436, 733, 295, 6327, 493, 420, 406], "temperature": 0.0, "avg_logprob": -0.10463784081595284, "compression_ratio": 1.6569767441860466, "no_speech_prob": 4.004361107945442e-05}, {"id": 255, "seek": 268164, "start": 2696.7599999999998, "end": 2702.8399999999997, "text": " depends on how many connections there are in the neural networks I'm looking at the fan in and", "tokens": [5946, 322, 577, 867, 9271, 456, 366, 294, 264, 18161, 9590, 286, 478, 1237, 412, 264, 3429, 294, 293], "temperature": 0.0, "avg_logprob": -0.10463784081595284, "compression_ratio": 1.6569767441860466, "no_speech_prob": 4.004361107945442e-05}, {"id": 256, "seek": 270284, "start": 2702.84, "end": 2712.52, "text": " fan out of connections in the neural network and so a very common initialization that you'll see", "tokens": [3429, 484, 295, 9271, 294, 264, 18161, 3209, 293, 370, 257, 588, 2689, 5883, 2144, 300, 291, 603, 536], "temperature": 0.0, "avg_logprob": -0.14593083328670925, "compression_ratio": 1.5714285714285714, "no_speech_prob": 1.2012965271424036e-05}, {"id": 257, "seek": 270284, "start": 2712.52, "end": 2719.6400000000003, "text": " in PyTorch is what's called Havier initialization named after a person who suggested that", "tokens": [294, 9953, 51, 284, 339, 307, 437, 311, 1219, 389, 706, 811, 5883, 2144, 4926, 934, 257, 954, 567, 10945, 300], "temperature": 0.0, "avg_logprob": -0.14593083328670925, "compression_ratio": 1.5714285714285714, "no_speech_prob": 1.2012965271424036e-05}, {"id": 258, "seek": 270284, "start": 2720.44, "end": 2729.96, "text": " and it's working out a value of based on this fan in fan out of the layers but you can just sort of", "tokens": [293, 309, 311, 1364, 484, 257, 2158, 295, 2361, 322, 341, 3429, 294, 3429, 484, 295, 264, 7914, 457, 291, 393, 445, 1333, 295], "temperature": 0.0, "avg_logprob": -0.14593083328670925, "compression_ratio": 1.5714285714285714, "no_speech_prob": 1.2012965271424036e-05}, {"id": 259, "seek": 272996, "start": 2729.96, "end": 2736.28, "text": " ask for it say initialize with this initialization and it will this is another area where there have", "tokens": [1029, 337, 309, 584, 5883, 1125, 365, 341, 5883, 2144, 293, 309, 486, 341, 307, 1071, 1859, 689, 456, 362], "temperature": 0.0, "avg_logprob": -0.0814616091111127, "compression_ratio": 1.7443946188340806, "no_speech_prob": 1.0772800123959314e-05}, {"id": 260, "seek": 272996, "start": 2736.28, "end": 2744.36, "text": " been some subsequent development so around week five we'll start talking about layer normalization", "tokens": [668, 512, 19962, 3250, 370, 926, 1243, 1732, 321, 603, 722, 1417, 466, 4583, 2710, 2144], "temperature": 0.0, "avg_logprob": -0.0814616091111127, "compression_ratio": 1.7443946188340806, "no_speech_prob": 1.0772800123959314e-05}, {"id": 261, "seek": 272996, "start": 2744.36, "end": 2749.08, "text": " and if you're using layer normalization then it sort of doesn't matter the same how you initialize", "tokens": [293, 498, 291, 434, 1228, 4583, 2710, 2144, 550, 309, 1333, 295, 1177, 380, 1871, 264, 912, 577, 291, 5883, 1125], "temperature": 0.0, "avg_logprob": -0.0814616091111127, "compression_ratio": 1.7443946188340806, "no_speech_prob": 1.0772800123959314e-05}, {"id": 262, "seek": 272996, "start": 2749.08, "end": 2758.84, "text": " the weights so finally we have to train our models and I've briefly introduced the idea of", "tokens": [264, 17443, 370, 2721, 321, 362, 281, 3847, 527, 5245, 293, 286, 600, 10515, 7268, 264, 1558, 295], "temperature": 0.0, "avg_logprob": -0.0814616091111127, "compression_ratio": 1.7443946188340806, "no_speech_prob": 1.0772800123959314e-05}, {"id": 263, "seek": 275884, "start": 2758.84, "end": 2766.1200000000003, "text": " stochastic gradient descent and you know the good news is that most of the time that if training", "tokens": [342, 8997, 2750, 16235, 23475, 293, 291, 458, 264, 665, 2583, 307, 300, 881, 295, 264, 565, 300, 498, 3097], "temperature": 0.0, "avg_logprob": -0.057008054521348744, "compression_ratio": 1.7365269461077844, "no_speech_prob": 8.212813554564491e-05}, {"id": 264, "seek": 275884, "start": 2766.1200000000003, "end": 2774.04, "text": " your networks with stochastic gradient descent works just fine use it and you will get good results", "tokens": [428, 9590, 365, 342, 8997, 2750, 16235, 23475, 1985, 445, 2489, 764, 309, 293, 291, 486, 483, 665, 3542], "temperature": 0.0, "avg_logprob": -0.057008054521348744, "compression_ratio": 1.7365269461077844, "no_speech_prob": 8.212813554564491e-05}, {"id": 265, "seek": 275884, "start": 2776.1200000000003, "end": 2783.6400000000003, "text": " however often that requires choosing a suitable learning rate which is my final slide of tips", "tokens": [4461, 2049, 300, 7029, 10875, 257, 12873, 2539, 3314, 597, 307, 452, 2572, 4137, 295, 6082], "temperature": 0.0, "avg_logprob": -0.057008054521348744, "compression_ratio": 1.7365269461077844, "no_speech_prob": 8.212813554564491e-05}, {"id": 266, "seek": 278364, "start": 2783.64, "end": 2791.3199999999997, "text": " on the next slide but there's been an enormous amount of work on optimization of neural networks", "tokens": [322, 264, 958, 4137, 457, 456, 311, 668, 364, 11322, 2372, 295, 589, 322, 19618, 295, 18161, 9590], "temperature": 0.0, "avg_logprob": -0.07738008953276135, "compression_ratio": 1.6292134831460674, "no_speech_prob": 4.875411104876548e-05}, {"id": 267, "seek": 278364, "start": 2791.3199999999997, "end": 2799.08, "text": " and people have come up with the whole series of more sophisticated optimizers and I'm not going", "tokens": [293, 561, 362, 808, 493, 365, 264, 1379, 2638, 295, 544, 16950, 5028, 22525, 293, 286, 478, 406, 516], "temperature": 0.0, "avg_logprob": -0.07738008953276135, "compression_ratio": 1.6292134831460674, "no_speech_prob": 4.875411104876548e-05}, {"id": 268, "seek": 278364, "start": 2799.08, "end": 2806.2, "text": " again to the details of optimization this class but the very loose idea is that these optimizers", "tokens": [797, 281, 264, 4365, 295, 19618, 341, 1508, 457, 264, 588, 9612, 1558, 307, 300, 613, 5028, 22525], "temperature": 0.0, "avg_logprob": -0.07738008953276135, "compression_ratio": 1.6292134831460674, "no_speech_prob": 4.875411104876548e-05}, {"id": 269, "seek": 280620, "start": 2806.2, "end": 2813.7999999999997, "text": " are adaptive in that they can kind of keep track of how much slope there was, how much gradient", "tokens": [366, 27912, 294, 300, 436, 393, 733, 295, 1066, 2837, 295, 577, 709, 13525, 456, 390, 11, 577, 709, 16235], "temperature": 0.0, "avg_logprob": -0.1150904965687947, "compression_ratio": 1.7255813953488373, "no_speech_prob": 5.733102807425894e-05}, {"id": 270, "seek": 280620, "start": 2813.7999999999997, "end": 2819.8799999999997, "text": " there is for different parameters and therefore based on that make decisions as to how much to", "tokens": [456, 307, 337, 819, 9834, 293, 4412, 2361, 322, 300, 652, 5327, 382, 281, 577, 709, 281], "temperature": 0.0, "avg_logprob": -0.1150904965687947, "compression_ratio": 1.7255813953488373, "no_speech_prob": 5.733102807425894e-05}, {"id": 271, "seek": 280620, "start": 2819.8799999999997, "end": 2826.2799999999997, "text": " adjust the weights when doing the gradient update rather than adjusting it by a constant amount", "tokens": [4369, 264, 17443, 562, 884, 264, 16235, 5623, 2831, 813, 23559, 309, 538, 257, 5754, 2372], "temperature": 0.0, "avg_logprob": -0.1150904965687947, "compression_ratio": 1.7255813953488373, "no_speech_prob": 5.733102807425894e-05}, {"id": 272, "seek": 280620, "start": 2826.2799999999997, "end": 2833.0, "text": " and so in that family of methods there are methods that include eta grad, RMS, prof,", "tokens": [293, 370, 294, 300, 1605, 295, 7150, 456, 366, 7150, 300, 4090, 32415, 2771, 11, 497, 10288, 11, 1740, 11], "temperature": 0.0, "avg_logprob": -0.1150904965687947, "compression_ratio": 1.7255813953488373, "no_speech_prob": 5.733102807425894e-05}, {"id": 273, "seek": 283300, "start": 2833.0, "end": 2839.08, "text": " atom and then a variance of atom including sparse atom, atom, w etc.", "tokens": [12018, 293, 550, 257, 21977, 295, 12018, 3009, 637, 11668, 12018, 11, 12018, 11, 261, 5183, 13], "temperature": 0.0, "avg_logprob": -0.1452986329466432, "compression_ratio": 1.6018518518518519, "no_speech_prob": 2.926544038928114e-05}, {"id": 274, "seek": 283300, "start": 2840.36, "end": 2847.16, "text": " The one called atom is a pretty good place to start and a lot of the time that's a good one to use", "tokens": [440, 472, 1219, 12018, 307, 257, 1238, 665, 1081, 281, 722, 293, 257, 688, 295, 264, 565, 300, 311, 257, 665, 472, 281, 764], "temperature": 0.0, "avg_logprob": -0.1452986329466432, "compression_ratio": 1.6018518518518519, "no_speech_prob": 2.926544038928114e-05}, {"id": 275, "seek": 283300, "start": 2847.16, "end": 2853.16, "text": " and again from the perspective of PyTorch when you're initializing an optimizer you can just say", "tokens": [293, 797, 490, 264, 4585, 295, 9953, 51, 284, 339, 562, 291, 434, 5883, 3319, 364, 5028, 6545, 291, 393, 445, 584], "temperature": 0.0, "avg_logprob": -0.1452986329466432, "compression_ratio": 1.6018518518518519, "no_speech_prob": 2.926544038928114e-05}, {"id": 276, "seek": 283300, "start": 2853.16, "end": 2858.28, "text": " please use atom and you don't actually need to know much more about it than that.", "tokens": [1767, 764, 12018, 293, 291, 500, 380, 767, 643, 281, 458, 709, 544, 466, 309, 813, 300, 13], "temperature": 0.0, "avg_logprob": -0.1452986329466432, "compression_ratio": 1.6018518518518519, "no_speech_prob": 2.926544038928114e-05}, {"id": 277, "seek": 285828, "start": 2858.28, "end": 2867.1600000000003, "text": " If you are using simple secastic gradient descent you have to change choose a learning rate so", "tokens": [759, 291, 366, 1228, 2199, 907, 2750, 16235, 23475, 291, 362, 281, 1319, 2826, 257, 2539, 3314, 370], "temperature": 0.0, "avg_logprob": -0.13384169690749226, "compression_ratio": 1.572972972972973, "no_speech_prob": 9.020265133585781e-05}, {"id": 278, "seek": 285828, "start": 2867.1600000000003, "end": 2874.36, "text": " that was the eta value of the two multiplied the gradient by for how much to adjust the weights", "tokens": [300, 390, 264, 32415, 2158, 295, 264, 732, 17207, 264, 16235, 538, 337, 577, 709, 281, 4369, 264, 17443], "temperature": 0.0, "avg_logprob": -0.13384169690749226, "compression_ratio": 1.572972972972973, "no_speech_prob": 9.020265133585781e-05}, {"id": 279, "seek": 285828, "start": 2874.36, "end": 2881.0800000000004, "text": " and so I talked about that slightly how you didn't want it to be too big or your model could diverge", "tokens": [293, 370, 286, 2825, 466, 300, 4748, 577, 291, 994, 380, 528, 309, 281, 312, 886, 955, 420, 428, 2316, 727, 18558, 432], "temperature": 0.0, "avg_logprob": -0.13384169690749226, "compression_ratio": 1.572972972972973, "no_speech_prob": 9.020265133585781e-05}, {"id": 280, "seek": 288108, "start": 2881.08, "end": 2889.16, "text": " or bounce around you didn't want it to be too small or else training could take place exceedingly", "tokens": [420, 15894, 926, 291, 994, 380, 528, 309, 281, 312, 886, 1359, 420, 1646, 3097, 727, 747, 1081, 14048, 12163], "temperature": 0.0, "avg_logprob": -0.13764956901813374, "compression_ratio": 1.634453781512605, "no_speech_prob": 0.0001484950043959543}, {"id": 281, "seek": 288108, "start": 2889.16, "end": 2896.12, "text": " slowly and you'll miss this sign deadline. How big it should be depends on all sorts of details", "tokens": [5692, 293, 291, 603, 1713, 341, 1465, 20615, 13, 1012, 955, 309, 820, 312, 5946, 322, 439, 7527, 295, 4365], "temperature": 0.0, "avg_logprob": -0.13764956901813374, "compression_ratio": 1.634453781512605, "no_speech_prob": 0.0001484950043959543}, {"id": 282, "seek": 288108, "start": 2896.12, "end": 2903.4, "text": " of the model and so you sort of want to try out some different order of magnitude numbers to see", "tokens": [295, 264, 2316, 293, 370, 291, 1333, 295, 528, 281, 853, 484, 512, 819, 1668, 295, 15668, 3547, 281, 536], "temperature": 0.0, "avg_logprob": -0.13764956901813374, "compression_ratio": 1.634453781512605, "no_speech_prob": 0.0001484950043959543}, {"id": 283, "seek": 288108, "start": 2903.4, "end": 2909.88, "text": " what numbers seem to work well for a training stable but reasonably quickly something around 10 to", "tokens": [437, 3547, 1643, 281, 589, 731, 337, 257, 3097, 8351, 457, 23551, 2661, 746, 926, 1266, 281], "temperature": 0.0, "avg_logprob": -0.13764956901813374, "compression_ratio": 1.634453781512605, "no_speech_prob": 0.0001484950043959543}, {"id": 284, "seek": 290988, "start": 2909.88, "end": 2916.28, "text": " the minus 3 or 10 to the minus 4 is an crazy place to start. In principle you can do fine just", "tokens": [264, 3175, 805, 420, 1266, 281, 264, 3175, 1017, 307, 364, 3219, 1081, 281, 722, 13, 682, 8665, 291, 393, 360, 2489, 445], "temperature": 0.0, "avg_logprob": -0.09962103917048527, "compression_ratio": 1.646808510638298, "no_speech_prob": 0.00011764500959543511}, {"id": 285, "seek": 290988, "start": 2916.28, "end": 2923.8, "text": " using a constant learning rate in SGD in practice people generally find they can get better results", "tokens": [1228, 257, 5754, 2539, 3314, 294, 34520, 35, 294, 3124, 561, 5101, 915, 436, 393, 483, 1101, 3542], "temperature": 0.0, "avg_logprob": -0.09962103917048527, "compression_ratio": 1.646808510638298, "no_speech_prob": 0.00011764500959543511}, {"id": 286, "seek": 290988, "start": 2923.8, "end": 2931.1600000000003, "text": " by decreasing learning rates as you trained so a very common recipe is that you have the learning", "tokens": [538, 23223, 2539, 6846, 382, 291, 8895, 370, 257, 588, 2689, 6782, 307, 300, 291, 362, 264, 2539], "temperature": 0.0, "avg_logprob": -0.09962103917048527, "compression_ratio": 1.646808510638298, "no_speech_prob": 0.00011764500959543511}, {"id": 287, "seek": 290988, "start": 2931.1600000000003, "end": 2937.8, "text": " rate after every K epox where an epoch means that you've made a pass through the entire set of", "tokens": [3314, 934, 633, 591, 30992, 87, 689, 364, 30992, 339, 1355, 300, 291, 600, 1027, 257, 1320, 807, 264, 2302, 992, 295], "temperature": 0.0, "avg_logprob": -0.09962103917048527, "compression_ratio": 1.646808510638298, "no_speech_prob": 0.00011764500959543511}, {"id": 288, "seek": 293780, "start": 2937.8, "end": 2943.2400000000002, "text": " training data so perhaps something like every three epochs you have the learning rate.", "tokens": [3097, 1412, 370, 4317, 746, 411, 633, 1045, 30992, 28346, 291, 362, 264, 2539, 3314, 13], "temperature": 0.0, "avg_logprob": -0.09485022966251817, "compression_ratio": 1.7429906542056075, "no_speech_prob": 6.91653840476647e-05}, {"id": 289, "seek": 293780, "start": 2945.0, "end": 2949.7200000000003, "text": " And a final little note there in purple is when you make a pass through the data you don't want", "tokens": [400, 257, 2572, 707, 3637, 456, 294, 9656, 307, 562, 291, 652, 257, 1320, 807, 264, 1412, 291, 500, 380, 528], "temperature": 0.0, "avg_logprob": -0.09485022966251817, "compression_ratio": 1.7429906542056075, "no_speech_prob": 6.91653840476647e-05}, {"id": 290, "seek": 293780, "start": 2949.7200000000003, "end": 2956.76, "text": " to go through the data items in the same order each time because that leads you to kind of speed", "tokens": [281, 352, 807, 264, 1412, 4754, 294, 264, 912, 1668, 1184, 565, 570, 300, 6689, 291, 281, 733, 295, 3073], "temperature": 0.0, "avg_logprob": -0.09485022966251817, "compression_ratio": 1.7429906542056075, "no_speech_prob": 6.91653840476647e-05}, {"id": 291, "seek": 293780, "start": 2956.76, "end": 2963.1600000000003, "text": " have a sort of patterning of the training examples that the model will sort of fall into that", "tokens": [362, 257, 1333, 295, 3829, 773, 295, 264, 3097, 5110, 300, 264, 2316, 486, 1333, 295, 2100, 666, 300], "temperature": 0.0, "avg_logprob": -0.09485022966251817, "compression_ratio": 1.7429906542056075, "no_speech_prob": 6.91653840476647e-05}, {"id": 292, "seek": 296316, "start": 2963.16, "end": 2968.68, "text": " periodicity of those patterns so it's best to shuffle the data before each pass through it.", "tokens": [27790, 507, 295, 729, 8294, 370, 309, 311, 1151, 281, 39426, 264, 1412, 949, 1184, 1320, 807, 309, 13], "temperature": 0.0, "avg_logprob": -0.11009943194505645, "compression_ratio": 1.646788990825688, "no_speech_prob": 1.5434894521604292e-05}, {"id": 293, "seek": 296316, "start": 2970.04, "end": 2977.24, "text": " Okay now more sophisticated ways to set learning rates and I won't really get into those now.", "tokens": [1033, 586, 544, 16950, 2098, 281, 992, 2539, 6846, 293, 286, 1582, 380, 534, 483, 666, 729, 586, 13], "temperature": 0.0, "avg_logprob": -0.11009943194505645, "compression_ratio": 1.646788990825688, "no_speech_prob": 1.5434894521604292e-05}, {"id": 294, "seek": 296316, "start": 2978.2799999999997, "end": 2983.48, "text": " Fancy optimizers like Adam also have a learning rate so you still have to choose", "tokens": [479, 6717, 5028, 22525, 411, 7938, 611, 362, 257, 2539, 3314, 370, 291, 920, 362, 281, 2826], "temperature": 0.0, "avg_logprob": -0.11009943194505645, "compression_ratio": 1.646788990825688, "no_speech_prob": 1.5434894521604292e-05}, {"id": 295, "seek": 296316, "start": 2983.48, "end": 2988.6, "text": " a learning rate value but it's effectively it's an initial learning rate which typically the", "tokens": [257, 2539, 3314, 2158, 457, 309, 311, 8659, 309, 311, 364, 5883, 2539, 3314, 597, 5850, 264], "temperature": 0.0, "avg_logprob": -0.11009943194505645, "compression_ratio": 1.646788990825688, "no_speech_prob": 1.5434894521604292e-05}, {"id": 296, "seek": 298860, "start": 2988.6, "end": 2994.52, "text": " optimizer shrinks as it runs and so you commonly want to have the number it starts off with", "tokens": [5028, 6545, 9884, 16431, 382, 309, 6676, 293, 370, 291, 12719, 528, 281, 362, 264, 1230, 309, 3719, 766, 365], "temperature": 0.0, "avg_logprob": -0.1269816602213999, "compression_ratio": 1.6535087719298245, "no_speech_prob": 3.810948328464292e-05}, {"id": 297, "seek": 298860, "start": 2994.52, "end": 3002.7599999999998, "text": " beyond the larger size because it'll be shrinking as it goes. Okay so that's all by way of", "tokens": [4399, 264, 4833, 2744, 570, 309, 603, 312, 41684, 382, 309, 1709, 13, 1033, 370, 300, 311, 439, 538, 636, 295], "temperature": 0.0, "avg_logprob": -0.1269816602213999, "compression_ratio": 1.6535087719298245, "no_speech_prob": 3.810948328464292e-05}, {"id": 298, "seek": 298860, "start": 3002.7599999999998, "end": 3009.24, "text": " introduction and I'm now ready to start on language models and our own ends so what is language", "tokens": [9339, 293, 286, 478, 586, 1919, 281, 722, 322, 2856, 5245, 293, 527, 1065, 5314, 370, 437, 307, 2856], "temperature": 0.0, "avg_logprob": -0.1269816602213999, "compression_ratio": 1.6535087719298245, "no_speech_prob": 3.810948328464292e-05}, {"id": 299, "seek": 298860, "start": 3009.24, "end": 3016.36, "text": " modeling? I mean as two words of English language modeling can mean just about anything but in the", "tokens": [15983, 30, 286, 914, 382, 732, 2283, 295, 3669, 2856, 15983, 393, 914, 445, 466, 1340, 457, 294, 264], "temperature": 0.0, "avg_logprob": -0.1269816602213999, "compression_ratio": 1.6535087719298245, "no_speech_prob": 3.810948328464292e-05}, {"id": 300, "seek": 301636, "start": 3016.36, "end": 3022.84, "text": " natural language processing literature language modeling has a very precise technical definition", "tokens": [3303, 2856, 9007, 10394, 2856, 15983, 575, 257, 588, 13600, 6191, 7123], "temperature": 0.0, "avg_logprob": -0.08515851838248116, "compression_ratio": 1.622093023255814, "no_speech_prob": 6.094407945056446e-05}, {"id": 301, "seek": 301636, "start": 3022.84, "end": 3030.28, "text": " which you should know so language modeling is the task of predicting the word that comes next.", "tokens": [597, 291, 820, 458, 370, 2856, 15983, 307, 264, 5633, 295, 32884, 264, 1349, 300, 1487, 958, 13], "temperature": 0.0, "avg_logprob": -0.08515851838248116, "compression_ratio": 1.622093023255814, "no_speech_prob": 6.094407945056446e-05}, {"id": 302, "seek": 301636, "start": 3031.8, "end": 3038.84, "text": " So if you have some context like the students open there you want to be able to predict", "tokens": [407, 498, 291, 362, 512, 4319, 411, 264, 1731, 1269, 456, 291, 528, 281, 312, 1075, 281, 6069], "temperature": 0.0, "avg_logprob": -0.08515851838248116, "compression_ratio": 1.622093023255814, "no_speech_prob": 6.094407945056446e-05}, {"id": 303, "seek": 303884, "start": 3038.84, "end": 3047.48, "text": " what words will come next is it their books their laptops their exams their minds and so in particular", "tokens": [437, 2283, 486, 808, 958, 307, 309, 641, 3642, 641, 27642, 641, 20514, 641, 9634, 293, 370, 294, 1729], "temperature": 0.0, "avg_logprob": -0.08967167331326392, "compression_ratio": 1.6686046511627908, "no_speech_prob": 3.53047507815063e-05}, {"id": 304, "seek": 303884, "start": 3048.6000000000004, "end": 3056.6800000000003, "text": " what you want to be doing is being able to give a probability that different words will occur", "tokens": [437, 291, 528, 281, 312, 884, 307, 885, 1075, 281, 976, 257, 8482, 300, 819, 2283, 486, 5160], "temperature": 0.0, "avg_logprob": -0.08967167331326392, "compression_ratio": 1.6686046511627908, "no_speech_prob": 3.53047507815063e-05}, {"id": 305, "seek": 303884, "start": 3056.6800000000003, "end": 3065.56, "text": " in this context. So a language model is a probability distribution over next words given a", "tokens": [294, 341, 4319, 13, 407, 257, 2856, 2316, 307, 257, 8482, 7316, 670, 958, 2283, 2212, 257], "temperature": 0.0, "avg_logprob": -0.08967167331326392, "compression_ratio": 1.6686046511627908, "no_speech_prob": 3.53047507815063e-05}, {"id": 306, "seek": 306556, "start": 3065.56, "end": 3077.56, "text": " preceding context and a system that does that is called a language model. So as a result of that", "tokens": [16969, 278, 4319, 293, 257, 1185, 300, 775, 300, 307, 1219, 257, 2856, 2316, 13, 407, 382, 257, 1874, 295, 300], "temperature": 0.0, "avg_logprob": -0.05912610174904407, "compression_ratio": 1.7607361963190185, "no_speech_prob": 2.281752495036926e-05}, {"id": 307, "seek": 306556, "start": 3077.56, "end": 3083.56, "text": " you can also think of a language model as a system that assigns a probability score to a piece of", "tokens": [291, 393, 611, 519, 295, 257, 2856, 2316, 382, 257, 1185, 300, 6269, 82, 257, 8482, 6175, 281, 257, 2522, 295], "temperature": 0.0, "avg_logprob": -0.05912610174904407, "compression_ratio": 1.7607361963190185, "no_speech_prob": 2.281752495036926e-05}, {"id": 308, "seek": 306556, "start": 3083.56, "end": 3089.56, "text": " text. So if we have a piece of text then we can just work out its probability according to a", "tokens": [2487, 13, 407, 498, 321, 362, 257, 2522, 295, 2487, 550, 321, 393, 445, 589, 484, 1080, 8482, 4650, 281, 257], "temperature": 0.0, "avg_logprob": -0.05912610174904407, "compression_ratio": 1.7607361963190185, "no_speech_prob": 2.281752495036926e-05}, {"id": 309, "seek": 308956, "start": 3089.56, "end": 3096.68, "text": " language model. So the probability of a sequence of tokens we can decompose via the chain rule", "tokens": [2856, 2316, 13, 407, 264, 8482, 295, 257, 8310, 295, 22667, 321, 393, 22867, 541, 5766, 264, 5021, 4978], "temperature": 0.0, "avg_logprob": -0.09857880152188815, "compression_ratio": 1.8629441624365481, "no_speech_prob": 4.537247514235787e-05}, {"id": 310, "seek": 308956, "start": 3096.68, "end": 3102.6, "text": " probability of the first times probability of the second given the first etc etc and then", "tokens": [8482, 295, 264, 700, 1413, 8482, 295, 264, 1150, 2212, 264, 700, 5183, 5183, 293, 550], "temperature": 0.0, "avg_logprob": -0.09857880152188815, "compression_ratio": 1.8629441624365481, "no_speech_prob": 4.537247514235787e-05}, {"id": 311, "seek": 308956, "start": 3102.6, "end": 3109.32, "text": " we can work that out using our language model provides as a product of each probability of", "tokens": [321, 393, 589, 300, 484, 1228, 527, 2856, 2316, 6417, 382, 257, 1674, 295, 1184, 8482, 295], "temperature": 0.0, "avg_logprob": -0.09857880152188815, "compression_ratio": 1.8629441624365481, "no_speech_prob": 4.537247514235787e-05}, {"id": 312, "seek": 308956, "start": 3109.32, "end": 3119.08, "text": " predicting the next word. Okay language models are really the cornerstone of human language", "tokens": [32884, 264, 958, 1349, 13, 1033, 2856, 5245, 366, 534, 264, 4538, 11243, 295, 1952, 2856], "temperature": 0.0, "avg_logprob": -0.09857880152188815, "compression_ratio": 1.8629441624365481, "no_speech_prob": 4.537247514235787e-05}, {"id": 313, "seek": 311908, "start": 3119.08, "end": 3127.7999999999997, "text": " technology everything that you do with computers and involves human language you are using language", "tokens": [2899, 1203, 300, 291, 360, 365, 10807, 293, 11626, 1952, 2856, 291, 366, 1228, 2856], "temperature": 0.0, "avg_logprob": -0.10537890730233028, "compression_ratio": 1.790909090909091, "no_speech_prob": 0.00016832008259370923}, {"id": 314, "seek": 311908, "start": 3127.7999999999997, "end": 3135.16, "text": " models. So when you're using your phone and it's suggesting whether well or badly what the next", "tokens": [5245, 13, 407, 562, 291, 434, 1228, 428, 2593, 293, 309, 311, 18094, 1968, 731, 420, 13425, 437, 264, 958], "temperature": 0.0, "avg_logprob": -0.10537890730233028, "compression_ratio": 1.790909090909091, "no_speech_prob": 0.00016832008259370923}, {"id": 315, "seek": 311908, "start": 3135.16, "end": 3141.08, "text": " word that you probably want to type is that's a language model working to try and predict the likely", "tokens": [1349, 300, 291, 1391, 528, 281, 2010, 307, 300, 311, 257, 2856, 2316, 1364, 281, 853, 293, 6069, 264, 3700], "temperature": 0.0, "avg_logprob": -0.10537890730233028, "compression_ratio": 1.790909090909091, "no_speech_prob": 0.00016832008259370923}, {"id": 316, "seek": 311908, "start": 3141.08, "end": 3148.44, "text": " next words. When the same thing happens in a Google doc and it's suggesting a next word or a next", "tokens": [958, 2283, 13, 1133, 264, 912, 551, 2314, 294, 257, 3329, 3211, 293, 309, 311, 18094, 257, 958, 1349, 420, 257, 958], "temperature": 0.0, "avg_logprob": -0.10537890730233028, "compression_ratio": 1.790909090909091, "no_speech_prob": 0.00016832008259370923}, {"id": 317, "seek": 314844, "start": 3148.44, "end": 3156.12, "text": " few words that's a language model. You know the main reason why the one in Google Docs works much", "tokens": [1326, 2283, 300, 311, 257, 2856, 2316, 13, 509, 458, 264, 2135, 1778, 983, 264, 472, 294, 3329, 16024, 82, 1985, 709], "temperature": 0.0, "avg_logprob": -0.13353773263784555, "compression_ratio": 1.7272727272727273, "no_speech_prob": 0.00013913141447119415}, {"id": 318, "seek": 314844, "start": 3156.12, "end": 3162.44, "text": " better than the one on your phone is that for the keyboard phone models they have to be very compact", "tokens": [1101, 813, 264, 472, 322, 428, 2593, 307, 300, 337, 264, 10186, 2593, 5245, 436, 362, 281, 312, 588, 14679], "temperature": 0.0, "avg_logprob": -0.13353773263784555, "compression_ratio": 1.7272727272727273, "no_speech_prob": 0.00013913141447119415}, {"id": 319, "seek": 314844, "start": 3162.44, "end": 3169.32, "text": " so they can run quickly and not much memory. So there's sort of only mediocre language models whether", "tokens": [370, 436, 393, 1190, 2661, 293, 406, 709, 4675, 13, 407, 456, 311, 1333, 295, 787, 45415, 2856, 5245, 1968], "temperature": 0.0, "avg_logprob": -0.13353773263784555, "compression_ratio": 1.7272727272727273, "no_speech_prob": 0.00013913141447119415}, {"id": 320, "seek": 314844, "start": 3169.32, "end": 3176.52, "text": " something like Google Docs can do a much better language modeling job. Queer completion same thing", "tokens": [746, 411, 3329, 16024, 82, 393, 360, 257, 709, 1101, 2856, 15983, 1691, 13, 4493, 260, 19372, 912, 551], "temperature": 0.0, "avg_logprob": -0.13353773263784555, "compression_ratio": 1.7272727272727273, "no_speech_prob": 0.00013913141447119415}, {"id": 321, "seek": 317652, "start": 3176.52, "end": 3185.48, "text": " there's a language model. And so then the question is well how do we build language models and so", "tokens": [456, 311, 257, 2856, 2316, 13, 400, 370, 550, 264, 1168, 307, 731, 577, 360, 321, 1322, 2856, 5245, 293, 370], "temperature": 0.0, "avg_logprob": -0.13106781436551002, "compression_ratio": 1.595505617977528, "no_speech_prob": 8.08620170573704e-05}, {"id": 322, "seek": 317652, "start": 3185.48, "end": 3192.7599999999998, "text": " I briefly wanted to first again give the traditional answer since you should have at least some", "tokens": [286, 10515, 1415, 281, 700, 797, 976, 264, 5164, 1867, 1670, 291, 820, 362, 412, 1935, 512], "temperature": 0.0, "avg_logprob": -0.13106781436551002, "compression_ratio": 1.595505617977528, "no_speech_prob": 8.08620170573704e-05}, {"id": 323, "seek": 317652, "start": 3192.7599999999998, "end": 3199.96, "text": " understanding of how NLP was done without a neural network and the traditional answer that", "tokens": [3701, 295, 577, 426, 45196, 390, 1096, 1553, 257, 18161, 3209, 293, 264, 5164, 1867, 300], "temperature": 0.0, "avg_logprob": -0.13106781436551002, "compression_ratio": 1.595505617977528, "no_speech_prob": 8.08620170573704e-05}, {"id": 324, "seek": 319996, "start": 3199.96, "end": 3206.52, "text": " powered speech recognition and other applications for at least two decades, three decades really", "tokens": [17786, 6218, 11150, 293, 661, 5821, 337, 412, 1935, 732, 7878, 11, 1045, 7878, 534], "temperature": 0.0, "avg_logprob": -0.1648961752653122, "compression_ratio": 1.5, "no_speech_prob": 3.643293530330993e-05}, {"id": 325, "seek": 319996, "start": 3207.32, "end": 3213.96, "text": " was what we're called NGram language models and these were very simple but still quite effective", "tokens": [390, 437, 321, 434, 1219, 426, 38, 2356, 2856, 5245, 293, 613, 645, 588, 2199, 457, 920, 1596, 4942], "temperature": 0.0, "avg_logprob": -0.1648961752653122, "compression_ratio": 1.5, "no_speech_prob": 3.643293530330993e-05}, {"id": 326, "seek": 319996, "start": 3213.96, "end": 3222.76, "text": " idea. So we want to give probabilities of next words. So what we're going to work with is what", "tokens": [1558, 13, 407, 321, 528, 281, 976, 33783, 295, 958, 2283, 13, 407, 437, 321, 434, 516, 281, 589, 365, 307, 437], "temperature": 0.0, "avg_logprob": -0.1648961752653122, "compression_ratio": 1.5, "no_speech_prob": 3.643293530330993e-05}, {"id": 327, "seek": 322276, "start": 3222.76, "end": 3230.1200000000003, "text": " are referred to as Ngrams and so Ngrams is just a chunk of N consecutive words which are usually", "tokens": [366, 10839, 281, 382, 426, 1342, 82, 293, 370, 426, 1342, 82, 307, 445, 257, 16635, 295, 426, 30497, 2283, 597, 366, 2673], "temperature": 0.0, "avg_logprob": -0.15151572714046557, "compression_ratio": 1.7004405286343611, "no_speech_prob": 6.0053531342418864e-05}, {"id": 328, "seek": 322276, "start": 3230.1200000000003, "end": 3236.84, "text": " referred to as unagrams, bi-grams, trigrams and then four grams and five grams. A horrible set of", "tokens": [10839, 281, 382, 517, 3914, 82, 11, 3228, 12, 1342, 82, 11, 35386, 2356, 82, 293, 550, 1451, 11899, 293, 1732, 11899, 13, 316, 9263, 992, 295], "temperature": 0.0, "avg_logprob": -0.15151572714046557, "compression_ratio": 1.7004405286343611, "no_speech_prob": 6.0053531342418864e-05}, {"id": 329, "seek": 322276, "start": 3236.84, "end": 3245.2400000000002, "text": " names which would offend any humanist but that's what people normally say. And so effectively what", "tokens": [5288, 597, 576, 41836, 604, 1952, 468, 457, 300, 311, 437, 561, 5646, 584, 13, 400, 370, 8659, 437], "temperature": 0.0, "avg_logprob": -0.15151572714046557, "compression_ratio": 1.7004405286343611, "no_speech_prob": 6.0053531342418864e-05}, {"id": 330, "seek": 322276, "start": 3245.2400000000002, "end": 3252.28, "text": " we do is just collect statistics about how often different Ngrams occur in a large amount of", "tokens": [321, 360, 307, 445, 2500, 12523, 466, 577, 2049, 819, 426, 1342, 82, 5160, 294, 257, 2416, 2372, 295], "temperature": 0.0, "avg_logprob": -0.15151572714046557, "compression_ratio": 1.7004405286343611, "no_speech_prob": 6.0053531342418864e-05}, {"id": 331, "seek": 325228, "start": 3252.28, "end": 3259.7200000000003, "text": " text and then use those to build a probability model. So the first thing we do is what's referred", "tokens": [2487, 293, 550, 764, 729, 281, 1322, 257, 8482, 2316, 13, 407, 264, 700, 551, 321, 360, 307, 437, 311, 10839], "temperature": 0.0, "avg_logprob": -0.12975030786850872, "compression_ratio": 1.6491228070175439, "no_speech_prob": 3.266826752224006e-05}, {"id": 332, "seek": 325228, "start": 3259.7200000000003, "end": 3265.96, "text": " to as making a mark off assumption so these are also referred to as mark off models and we decide", "tokens": [281, 382, 1455, 257, 1491, 766, 15302, 370, 613, 366, 611, 10839, 281, 382, 1491, 766, 5245, 293, 321, 4536], "temperature": 0.0, "avg_logprob": -0.12975030786850872, "compression_ratio": 1.6491228070175439, "no_speech_prob": 3.266826752224006e-05}, {"id": 333, "seek": 325228, "start": 3265.96, "end": 3272.84, "text": " that the word and position t plus one only depends on the preceding N minus one words.", "tokens": [300, 264, 1349, 293, 2535, 256, 1804, 472, 787, 5946, 322, 264, 16969, 278, 426, 3175, 472, 2283, 13], "temperature": 0.0, "avg_logprob": -0.12975030786850872, "compression_ratio": 1.6491228070175439, "no_speech_prob": 3.266826752224006e-05}, {"id": 334, "seek": 327284, "start": 3272.84, "end": 3283.8, "text": " So if we want to predict t plus one given the entire preceding text we actually throw away the", "tokens": [407, 498, 321, 528, 281, 6069, 256, 1804, 472, 2212, 264, 2302, 16969, 278, 2487, 321, 767, 3507, 1314, 264], "temperature": 0.0, "avg_logprob": -0.06663588743943434, "compression_ratio": 1.6045197740112995, "no_speech_prob": 0.00011584993626456708}, {"id": 335, "seek": 327284, "start": 3283.8, "end": 3290.6800000000003, "text": " early words and just use the preceding N minus one words as context. Well once we've made that", "tokens": [2440, 2283, 293, 445, 764, 264, 16969, 278, 426, 3175, 472, 2283, 382, 4319, 13, 1042, 1564, 321, 600, 1027, 300], "temperature": 0.0, "avg_logprob": -0.06663588743943434, "compression_ratio": 1.6045197740112995, "no_speech_prob": 0.00011584993626456708}, {"id": 336, "seek": 327284, "start": 3290.6800000000003, "end": 3296.6800000000003, "text": " simplification we can then just use the definition of conditional probability and say all that", "tokens": [6883, 3774, 321, 393, 550, 445, 764, 264, 7123, 295, 27708, 8482, 293, 584, 439, 300], "temperature": 0.0, "avg_logprob": -0.06663588743943434, "compression_ratio": 1.6045197740112995, "no_speech_prob": 0.00011584993626456708}, {"id": 337, "seek": 329668, "start": 3296.68, "end": 3306.9199999999996, "text": " conditional probability is the probability of N words divided by the preceding N minus one words", "tokens": [27708, 8482, 307, 264, 8482, 295, 426, 2283, 6666, 538, 264, 16969, 278, 426, 3175, 472, 2283], "temperature": 0.0, "avg_logprob": -0.10202851406363554, "compression_ratio": 1.8911917098445596, "no_speech_prob": 5.506881279870868e-06}, {"id": 338, "seek": 329668, "start": 3306.9199999999996, "end": 3312.2799999999997, "text": " and so we have the probability of an Ngram over the probability of an N minus one gram.", "tokens": [293, 370, 321, 362, 264, 8482, 295, 364, 426, 1342, 670, 264, 8482, 295, 364, 426, 3175, 472, 21353, 13], "temperature": 0.0, "avg_logprob": -0.10202851406363554, "compression_ratio": 1.8911917098445596, "no_speech_prob": 5.506881279870868e-06}, {"id": 339, "seek": 329668, "start": 3313.96, "end": 3319.48, "text": " And so then how do we get these Ngram and N minus one gram probabilities? We simply take a", "tokens": [400, 370, 550, 577, 360, 321, 483, 613, 426, 1342, 293, 426, 3175, 472, 21353, 33783, 30, 492, 2935, 747, 257], "temperature": 0.0, "avg_logprob": -0.10202851406363554, "compression_ratio": 1.8911917098445596, "no_speech_prob": 5.506881279870868e-06}, {"id": 340, "seek": 331948, "start": 3319.48, "end": 3327.56, "text": " large amount of text and some language and we count how often the different Ngrams occur.", "tokens": [2416, 2372, 295, 2487, 293, 512, 2856, 293, 321, 1207, 577, 2049, 264, 819, 426, 1342, 82, 5160, 13], "temperature": 0.0, "avg_logprob": -0.11344103191209876, "compression_ratio": 1.6812227074235808, "no_speech_prob": 6.337964350677794e-06}, {"id": 341, "seek": 331948, "start": 3327.56, "end": 3334.84, "text": " And so our crude statistical approximation starts off as the count of the Ngram over the count of", "tokens": [400, 370, 527, 30796, 22820, 28023, 3719, 766, 382, 264, 1207, 295, 264, 426, 1342, 670, 264, 1207, 295], "temperature": 0.0, "avg_logprob": -0.11344103191209876, "compression_ratio": 1.6812227074235808, "no_speech_prob": 6.337964350677794e-06}, {"id": 342, "seek": 331948, "start": 3334.84, "end": 3341.16, "text": " the N minus one gram. So here's an example of that. Suppose we are learning a four-gram language", "tokens": [264, 426, 3175, 472, 21353, 13, 407, 510, 311, 364, 1365, 295, 300, 13, 21360, 321, 366, 2539, 257, 1451, 12, 1342, 2856], "temperature": 0.0, "avg_logprob": -0.11344103191209876, "compression_ratio": 1.6812227074235808, "no_speech_prob": 6.337964350677794e-06}, {"id": 343, "seek": 331948, "start": 3341.16, "end": 3348.28, "text": " model. Okay so we throw away all words apart from the last three words and they're our conditioning.", "tokens": [2316, 13, 1033, 370, 321, 3507, 1314, 439, 2283, 4936, 490, 264, 1036, 1045, 2283, 293, 436, 434, 527, 21901, 13], "temperature": 0.0, "avg_logprob": -0.11344103191209876, "compression_ratio": 1.6812227074235808, "no_speech_prob": 6.337964350677794e-06}, {"id": 344, "seek": 334828, "start": 3348.28, "end": 3359.0, "text": " We look in some large, we use the counts from some large training corpus and we see how often did", "tokens": [492, 574, 294, 512, 2416, 11, 321, 764, 264, 14893, 490, 512, 2416, 3097, 1181, 31624, 293, 321, 536, 577, 2049, 630], "temperature": 0.0, "avg_logprob": -0.12261814059633197, "compression_ratio": 1.9210526315789473, "no_speech_prob": 0.00022635071945842355}, {"id": 345, "seek": 334828, "start": 3359.0, "end": 3365.48, "text": " students open their books occur, how often did students open their minds occur and then for each", "tokens": [1731, 1269, 641, 3642, 5160, 11, 577, 2049, 630, 1731, 1269, 641, 9634, 5160, 293, 550, 337, 1184], "temperature": 0.0, "avg_logprob": -0.12261814059633197, "compression_ratio": 1.9210526315789473, "no_speech_prob": 0.00022635071945842355}, {"id": 346, "seek": 334828, "start": 3365.48, "end": 3371.7200000000003, "text": " of those counts we divide through by the count of how often students open their occurred and that", "tokens": [295, 729, 14893, 321, 9845, 807, 538, 264, 1207, 295, 577, 2049, 1731, 1269, 641, 11068, 293, 300], "temperature": 0.0, "avg_logprob": -0.12261814059633197, "compression_ratio": 1.9210526315789473, "no_speech_prob": 0.00022635071945842355}, {"id": 347, "seek": 337172, "start": 3371.72, "end": 3380.3599999999997, "text": " gives us our probability estimates. So for example if in the corpus students open their occurred", "tokens": [2709, 505, 527, 8482, 20561, 13, 407, 337, 1365, 498, 294, 264, 1181, 31624, 1731, 1269, 641, 11068], "temperature": 0.0, "avg_logprob": -0.14988994598388672, "compression_ratio": 1.7745098039215685, "no_speech_prob": 3.5313336411491036e-05}, {"id": 348, "seek": 337172, "start": 3380.3599999999997, "end": 3386.4399999999996, "text": " a thousand times, students open their books occurred four hundred times, we get a probability", "tokens": [257, 4714, 1413, 11, 1731, 1269, 641, 3642, 11068, 1451, 3262, 1413, 11, 321, 483, 257, 8482], "temperature": 0.0, "avg_logprob": -0.14988994598388672, "compression_ratio": 1.7745098039215685, "no_speech_prob": 3.5313336411491036e-05}, {"id": 349, "seek": 337172, "start": 3386.4399999999996, "end": 3392.6, "text": " estimate of 0.4 for books, if exams occurred a hundred times it gets 0.1 for exams.", "tokens": [12539, 295, 1958, 13, 19, 337, 3642, 11, 498, 20514, 11068, 257, 3262, 1413, 309, 2170, 1958, 13, 16, 337, 20514, 13], "temperature": 0.0, "avg_logprob": -0.14988994598388672, "compression_ratio": 1.7745098039215685, "no_speech_prob": 3.5313336411491036e-05}, {"id": 350, "seek": 337172, "start": 3393.3199999999997, "end": 3399.3999999999996, "text": " And we sort of see here already the disadvantage of having made the mark off assumption", "tokens": [400, 321, 1333, 295, 536, 510, 1217, 264, 24292, 295, 1419, 1027, 264, 1491, 766, 15302], "temperature": 0.0, "avg_logprob": -0.14988994598388672, "compression_ratio": 1.7745098039215685, "no_speech_prob": 3.5313336411491036e-05}, {"id": 351, "seek": 339940, "start": 3399.4, "end": 3406.04, "text": " and have gotten rid of all of this earlier context which would be useful for helping us to predict.", "tokens": [293, 362, 5768, 3973, 295, 439, 295, 341, 3071, 4319, 597, 576, 312, 4420, 337, 4315, 505, 281, 6069, 13], "temperature": 0.0, "avg_logprob": -0.10105740683419363, "compression_ratio": 1.6166666666666667, "no_speech_prob": 6.0926082369405776e-05}, {"id": 352, "seek": 339940, "start": 3408.44, "end": 3416.92, "text": " The one other point that I'll just mention that I confuse myself on is this count of the Ngram", "tokens": [440, 472, 661, 935, 300, 286, 603, 445, 2152, 300, 286, 28584, 2059, 322, 307, 341, 1207, 295, 264, 426, 1342], "temperature": 0.0, "avg_logprob": -0.10105740683419363, "compression_ratio": 1.6166666666666667, "no_speech_prob": 6.0926082369405776e-05}, {"id": 353, "seek": 339940, "start": 3416.92, "end": 3424.12, "text": " language model. So for a four-gram language model it's called a four-gram language model because", "tokens": [2856, 2316, 13, 407, 337, 257, 1451, 12, 1342, 2856, 2316, 309, 311, 1219, 257, 1451, 12, 1342, 2856, 2316, 570], "temperature": 0.0, "avg_logprob": -0.10105740683419363, "compression_ratio": 1.6166666666666667, "no_speech_prob": 6.0926082369405776e-05}, {"id": 354, "seek": 342412, "start": 3424.12, "end": 3431.3199999999997, "text": " in its estimation you're using four grams in the numerator and trigrams in the denominator.", "tokens": [294, 1080, 35701, 291, 434, 1228, 1451, 11899, 294, 264, 30380, 293, 1376, 1342, 82, 294, 264, 20687, 13], "temperature": 0.0, "avg_logprob": -0.1288961516486274, "compression_ratio": 1.8756218905472637, "no_speech_prob": 2.504037183825858e-05}, {"id": 355, "seek": 342412, "start": 3431.3199999999997, "end": 3438.7599999999998, "text": " So you use the size of the numerator. So that terminology is different to the terminology", "tokens": [407, 291, 764, 264, 2744, 295, 264, 30380, 13, 407, 300, 27575, 307, 819, 281, 264, 27575], "temperature": 0.0, "avg_logprob": -0.1288961516486274, "compression_ratio": 1.8756218905472637, "no_speech_prob": 2.504037183825858e-05}, {"id": 356, "seek": 342412, "start": 3438.7599999999998, "end": 3445.08, "text": " that's used in mark-off models. So when people talk about the order of a mark-off model that", "tokens": [300, 311, 1143, 294, 1491, 12, 4506, 5245, 13, 407, 562, 561, 751, 466, 264, 1668, 295, 257, 1491, 12, 4506, 2316, 300], "temperature": 0.0, "avg_logprob": -0.1288961516486274, "compression_ratio": 1.8756218905472637, "no_speech_prob": 2.504037183825858e-05}, {"id": 357, "seek": 344508, "start": 3445.08, "end": 3454.2, "text": " refers to the amount of context you're using so this would correspond to a third order mark-off model.", "tokens": [14942, 281, 264, 2372, 295, 4319, 291, 434, 1228, 370, 341, 576, 6805, 281, 257, 2636, 1668, 1491, 12, 4506, 2316, 13], "temperature": 0.0, "avg_logprob": -0.15110090800694057, "compression_ratio": 1.646067415730337, "no_speech_prob": 1.641096059756819e-05}, {"id": 358, "seek": 344508, "start": 3455.16, "end": 3463.88, "text": " Yeah so someone said is this similar to a naive-based model sort of naive-based models you also", "tokens": [865, 370, 1580, 848, 307, 341, 2531, 281, 257, 29052, 12, 6032, 2316, 1333, 295, 29052, 12, 6032, 5245, 291, 611], "temperature": 0.0, "avg_logprob": -0.15110090800694057, "compression_ratio": 1.646067415730337, "no_speech_prob": 1.641096059756819e-05}, {"id": 359, "seek": 344508, "start": 3463.88, "end": 3472.44, "text": " estimate the probabilities just by counting. So they're they're related and they're sort of in", "tokens": [12539, 264, 33783, 445, 538, 13251, 13, 407, 436, 434, 436, 434, 4077, 293, 436, 434, 1333, 295, 294], "temperature": 0.0, "avg_logprob": -0.15110090800694057, "compression_ratio": 1.646067415730337, "no_speech_prob": 1.641096059756819e-05}, {"id": 360, "seek": 347244, "start": 3472.44, "end": 3481.88, "text": " some sense two different answers. The first difference or specialization is that naive-based models", "tokens": [512, 2020, 732, 819, 6338, 13, 440, 700, 2649, 420, 2121, 2144, 307, 300, 29052, 12, 6032, 5245], "temperature": 0.0, "avg_logprob": -0.15555851276104266, "compression_ratio": 1.5978260869565217, "no_speech_prob": 2.0625155229936354e-05}, {"id": 361, "seek": 347244, "start": 3483.08, "end": 3491.16, "text": " work out probabilities of words independent of their neighbors. So in one part that a naive-based", "tokens": [589, 484, 33783, 295, 2283, 6695, 295, 641, 12512, 13, 407, 294, 472, 644, 300, 257, 29052, 12, 6032], "temperature": 0.0, "avg_logprob": -0.15555851276104266, "compression_ratio": 1.5978260869565217, "no_speech_prob": 2.0625155229936354e-05}, {"id": 362, "seek": 347244, "start": 3491.16, "end": 3497.16, "text": " language model is a unagram language model. So you're just using the counts of individual words.", "tokens": [2856, 2316, 307, 257, 517, 3914, 2856, 2316, 13, 407, 291, 434, 445, 1228, 264, 14893, 295, 2609, 2283, 13], "temperature": 0.0, "avg_logprob": -0.15555851276104266, "compression_ratio": 1.5978260869565217, "no_speech_prob": 2.0625155229936354e-05}, {"id": 363, "seek": 349716, "start": 3497.16, "end": 3504.3599999999997, "text": " But the other part of a naive-based model is you're learning a different set of unagram counts", "tokens": [583, 264, 661, 644, 295, 257, 29052, 12, 6032, 2316, 307, 291, 434, 2539, 257, 819, 992, 295, 517, 3914, 14893], "temperature": 0.0, "avg_logprob": -0.0728870051247733, "compression_ratio": 1.625, "no_speech_prob": 2.2113063096185215e-05}, {"id": 364, "seek": 349716, "start": 3504.3599999999997, "end": 3514.52, "text": " for every class for your classifier. And so you've then got sort of so effectively a naive-based", "tokens": [337, 633, 1508, 337, 428, 1508, 9902, 13, 400, 370, 291, 600, 550, 658, 1333, 295, 370, 8659, 257, 29052, 12, 6032], "temperature": 0.0, "avg_logprob": -0.0728870051247733, "compression_ratio": 1.625, "no_speech_prob": 2.2113063096185215e-05}, {"id": 365, "seek": 349716, "start": 3514.52, "end": 3526.2799999999997, "text": " model is you've got class-specific unagram language models. Okay I gave this as a", "tokens": [2316, 307, 291, 600, 658, 1508, 12, 29258, 517, 3914, 2856, 5245, 13, 1033, 286, 2729, 341, 382, 257], "temperature": 0.0, "avg_logprob": -0.0728870051247733, "compression_ratio": 1.625, "no_speech_prob": 2.2113063096185215e-05}, {"id": 366, "seek": 352628, "start": 3526.28, "end": 3532.52, "text": " simple statistical model for estimating your probabilities with an engram model. You can't", "tokens": [2199, 22820, 2316, 337, 8017, 990, 428, 33783, 365, 364, 465, 1342, 2316, 13, 509, 393, 380], "temperature": 0.0, "avg_logprob": -0.11274900890531994, "compression_ratio": 1.668141592920354, "no_speech_prob": 0.00017911985924001783}, {"id": 367, "seek": 352628, "start": 3532.52, "end": 3538.6800000000003, "text": " actually get away with just doing that because you have sparsity problems. So you know often", "tokens": [767, 483, 1314, 365, 445, 884, 300, 570, 291, 362, 637, 685, 507, 2740, 13, 407, 291, 458, 2049], "temperature": 0.0, "avg_logprob": -0.11274900890531994, "compression_ratio": 1.668141592920354, "no_speech_prob": 0.00017911985924001783}, {"id": 368, "seek": 352628, "start": 3538.6800000000003, "end": 3547.0, "text": " will be the case that for many words students open their books or students opened their backpacks", "tokens": [486, 312, 264, 1389, 300, 337, 867, 2283, 1731, 1269, 641, 3642, 420, 1731, 5625, 641, 646, 79, 7424], "temperature": 0.0, "avg_logprob": -0.11274900890531994, "compression_ratio": 1.668141592920354, "no_speech_prob": 0.00017911985924001783}, {"id": 369, "seek": 352628, "start": 3547.0, "end": 3551.48, "text": " just never occurred in the training data. That if you think about it if you have something like", "tokens": [445, 1128, 11068, 294, 264, 3097, 1412, 13, 663, 498, 291, 519, 466, 309, 498, 291, 362, 746, 411], "temperature": 0.0, "avg_logprob": -0.11274900890531994, "compression_ratio": 1.668141592920354, "no_speech_prob": 0.00017911985924001783}, {"id": 370, "seek": 355148, "start": 3551.48, "end": 3558.12, "text": " 10 to the fifth different words even and you want to have then a sequence of four words", "tokens": [1266, 281, 264, 9266, 819, 2283, 754, 293, 291, 528, 281, 362, 550, 257, 8310, 295, 1451, 2283], "temperature": 0.0, "avg_logprob": -0.1509907288984819, "compression_ratio": 1.7984189723320159, "no_speech_prob": 0.0001419008185621351}, {"id": 371, "seek": 355148, "start": 3558.12, "end": 3563.16, "text": " are probably and they're 10 to the fifth of each. There's sort of 10 to the 20th different", "tokens": [366, 1391, 293, 436, 434, 1266, 281, 264, 9266, 295, 1184, 13, 821, 311, 1333, 295, 1266, 281, 264, 945, 392, 819], "temperature": 0.0, "avg_logprob": -0.1509907288984819, "compression_ratio": 1.7984189723320159, "no_speech_prob": 0.0001419008185621351}, {"id": 372, "seek": 355148, "start": 3563.16, "end": 3569.0, "text": " combinations. So unless you're seeing and it's truly astronomical amount of data most", "tokens": [21267, 13, 407, 5969, 291, 434, 2577, 293, 309, 311, 4908, 49035, 2372, 295, 1412, 881], "temperature": 0.0, "avg_logprob": -0.1509907288984819, "compression_ratio": 1.7984189723320159, "no_speech_prob": 0.0001419008185621351}, {"id": 373, "seek": 355148, "start": 3569.0, "end": 3575.08, "text": " forward sequences you've never seen. So then your numerate will be zero and your probability", "tokens": [2128, 22978, 291, 600, 1128, 1612, 13, 407, 550, 428, 7866, 473, 486, 312, 4018, 293, 428, 8482], "temperature": 0.0, "avg_logprob": -0.1509907288984819, "compression_ratio": 1.7984189723320159, "no_speech_prob": 0.0001419008185621351}, {"id": 374, "seek": 355148, "start": 3575.08, "end": 3580.84, "text": " estimate will be zero. And so that's bad. And so the commoners way of solving that is just to add", "tokens": [12539, 486, 312, 4018, 13, 400, 370, 300, 311, 1578, 13, 400, 370, 264, 2689, 433, 636, 295, 12606, 300, 307, 445, 281, 909], "temperature": 0.0, "avg_logprob": -0.1509907288984819, "compression_ratio": 1.7984189723320159, "no_speech_prob": 0.0001419008185621351}, {"id": 375, "seek": 358084, "start": 3580.84, "end": 3586.2000000000003, "text": " a little delta to every count and then everything is non-zero and that's called smoothing.", "tokens": [257, 707, 8289, 281, 633, 1207, 293, 550, 1203, 307, 2107, 12, 32226, 293, 300, 311, 1219, 899, 6259, 571, 13], "temperature": 0.0, "avg_logprob": -0.1078393294079469, "compression_ratio": 1.7410358565737052, "no_speech_prob": 9.308256994700059e-05}, {"id": 376, "seek": 358084, "start": 3587.32, "end": 3591.7200000000003, "text": " But well sometimes it's worse than that because sometimes you won't even have seen", "tokens": [583, 731, 2171, 309, 311, 5324, 813, 300, 570, 2171, 291, 1582, 380, 754, 362, 1612], "temperature": 0.0, "avg_logprob": -0.1078393294079469, "compression_ratio": 1.7410358565737052, "no_speech_prob": 9.308256994700059e-05}, {"id": 377, "seek": 358084, "start": 3591.7200000000003, "end": 3596.76, "text": " students open theirs and that's more problematic because that means our denominator", "tokens": [1731, 1269, 22760, 293, 300, 311, 544, 19011, 570, 300, 1355, 527, 20687], "temperature": 0.0, "avg_logprob": -0.1078393294079469, "compression_ratio": 1.7410358565737052, "no_speech_prob": 9.308256994700059e-05}, {"id": 378, "seek": 358084, "start": 3596.76, "end": 3604.84, "text": " if is zero and so the division will be ill-defined and we can't usefully calculate any probabilities", "tokens": [498, 307, 4018, 293, 370, 264, 10044, 486, 312, 3171, 12, 37716, 293, 321, 393, 380, 764, 2277, 8873, 604, 33783], "temperature": 0.0, "avg_logprob": -0.1078393294079469, "compression_ratio": 1.7410358565737052, "no_speech_prob": 9.308256994700059e-05}, {"id": 379, "seek": 358084, "start": 3604.84, "end": 3609.88, "text": " in a context that we've never seen. And so the standard solution to that is to", "tokens": [294, 257, 4319, 300, 321, 600, 1128, 1612, 13, 400, 370, 264, 3832, 3827, 281, 300, 307, 281], "temperature": 0.0, "avg_logprob": -0.1078393294079469, "compression_ratio": 1.7410358565737052, "no_speech_prob": 9.308256994700059e-05}, {"id": 380, "seek": 360988, "start": 3609.88, "end": 3617.48, "text": " shorten the context and that's called back-off. So we condition only on open-there or if we", "tokens": [39632, 264, 4319, 293, 300, 311, 1219, 646, 12, 4506, 13, 407, 321, 4188, 787, 322, 1269, 12, 15456, 420, 498, 321], "temperature": 0.0, "avg_logprob": -0.17688797741401485, "compression_ratio": 1.62, "no_speech_prob": 0.000170946674188599}, {"id": 381, "seek": 360988, "start": 3617.48, "end": 3623.96, "text": " still don't haven't seen open-there we'll condition only on there or we could just forget", "tokens": [920, 500, 380, 2378, 380, 1612, 1269, 12, 15456, 321, 603, 4188, 787, 322, 456, 420, 321, 727, 445, 2870], "temperature": 0.0, "avg_logprob": -0.17688797741401485, "compression_ratio": 1.62, "no_speech_prob": 0.000170946674188599}, {"id": 382, "seek": 360988, "start": 3623.96, "end": 3628.04, "text": " all conditioning and actually use a unagram model for our probabilities.", "tokens": [439, 21901, 293, 767, 764, 257, 517, 3914, 2316, 337, 527, 33783, 13], "temperature": 0.0, "avg_logprob": -0.17688797741401485, "compression_ratio": 1.62, "no_speech_prob": 0.000170946674188599}, {"id": 383, "seek": 360988, "start": 3630.52, "end": 3638.6, "text": " Yeah. And so as you increase the order N of the N-gram language model", "tokens": [865, 13, 400, 370, 382, 291, 3488, 264, 1668, 426, 295, 264, 426, 12, 1342, 2856, 2316], "temperature": 0.0, "avg_logprob": -0.17688797741401485, "compression_ratio": 1.62, "no_speech_prob": 0.000170946674188599}, {"id": 384, "seek": 363860, "start": 3638.6, "end": 3644.7599999999998, "text": " these sparsity problems become worse and worse. So in the early days people normally worked with", "tokens": [613, 637, 685, 507, 2740, 1813, 5324, 293, 5324, 13, 407, 294, 264, 2440, 1708, 561, 5646, 2732, 365], "temperature": 0.0, "avg_logprob": -0.13453201914942542, "compression_ratio": 1.6355932203389831, "no_speech_prob": 3.757533704629168e-05}, {"id": 385, "seek": 363860, "start": 3644.7599999999998, "end": 3651.48, "text": " tri-gram models as it became easier to collect billions of words of text. People commonly move", "tokens": [1376, 12, 1342, 5245, 382, 309, 3062, 3571, 281, 2500, 17375, 295, 2283, 295, 2487, 13, 3432, 12719, 1286], "temperature": 0.0, "avg_logprob": -0.13453201914942542, "compression_ratio": 1.6355932203389831, "no_speech_prob": 3.757533704629168e-05}, {"id": 386, "seek": 363860, "start": 3651.48, "end": 3660.92, "text": " to five-gram models but every time you go up an order of conditioning you effectively need to be", "tokens": [281, 1732, 12, 1342, 5245, 457, 633, 565, 291, 352, 493, 364, 1668, 295, 21901, 291, 8659, 643, 281, 312], "temperature": 0.0, "avg_logprob": -0.13453201914942542, "compression_ratio": 1.6355932203389831, "no_speech_prob": 3.757533704629168e-05}, {"id": 387, "seek": 366092, "start": 3660.92, "end": 3668.6800000000003, "text": " collecting orders of magnitude more data because of the size of the vocabules of human languages.", "tokens": [12510, 9470, 295, 15668, 544, 1412, 570, 295, 264, 2744, 295, 264, 2329, 455, 3473, 295, 1952, 8650, 13], "temperature": 0.0, "avg_logprob": -0.15359564388499541, "compression_ratio": 1.5798319327731092, "no_speech_prob": 6.103701889514923e-05}, {"id": 388, "seek": 366092, "start": 3669.48, "end": 3676.84, "text": " There's also a problem that these models are huge. So basically have to be caught storing", "tokens": [821, 311, 611, 257, 1154, 300, 613, 5245, 366, 2603, 13, 407, 1936, 362, 281, 312, 5415, 26085], "temperature": 0.0, "avg_logprob": -0.15359564388499541, "compression_ratio": 1.5798319327731092, "no_speech_prob": 6.103701889514923e-05}, {"id": 389, "seek": 366092, "start": 3676.84, "end": 3682.28, "text": " counts of all of these words sequences so you can work out these probabilities. And I mean", "tokens": [14893, 295, 439, 295, 613, 2283, 22978, 370, 291, 393, 589, 484, 613, 33783, 13, 400, 286, 914], "temperature": 0.0, "avg_logprob": -0.15359564388499541, "compression_ratio": 1.5798319327731092, "no_speech_prob": 6.103701889514923e-05}, {"id": 390, "seek": 368228, "start": 3682.28, "end": 3691.0, "text": " that's actually had a big effect in terms of what technology is available. So in the 2000s decade", "tokens": [300, 311, 767, 632, 257, 955, 1802, 294, 2115, 295, 437, 2899, 307, 2435, 13, 407, 294, 264, 8132, 82, 10378], "temperature": 0.0, "avg_logprob": -0.1450174988293257, "compression_ratio": 1.456989247311828, "no_speech_prob": 7.24384153727442e-05}, {"id": 391, "seek": 368228, "start": 3691.0, "end": 3698.1200000000003, "text": " up till that whenever it was 2014 that there was already Google translate using", "tokens": [493, 4288, 300, 5699, 309, 390, 8227, 300, 456, 390, 1217, 3329, 13799, 1228], "temperature": 0.0, "avg_logprob": -0.1450174988293257, "compression_ratio": 1.456989247311828, "no_speech_prob": 7.24384153727442e-05}, {"id": 392, "seek": 368228, "start": 3699.48, "end": 3705.6400000000003, "text": " probabilistic models included language models of the N-gram language model sort. But the only", "tokens": [31959, 3142, 5245, 5556, 2856, 5245, 295, 264, 426, 12, 1342, 2856, 2316, 1333, 13, 583, 264, 787], "temperature": 0.0, "avg_logprob": -0.1450174988293257, "compression_ratio": 1.456989247311828, "no_speech_prob": 7.24384153727442e-05}, {"id": 393, "seek": 370564, "start": 3705.64, "end": 3712.92, "text": " way they could possibly be run is in the cloud because you needed to have these huge tables of", "tokens": [636, 436, 727, 6264, 312, 1190, 307, 294, 264, 4588, 570, 291, 2978, 281, 362, 613, 2603, 8020, 295], "temperature": 0.0, "avg_logprob": -0.07116890722705473, "compression_ratio": 1.576086956521739, "no_speech_prob": 5.8268058637622744e-05}, {"id": 394, "seek": 370564, "start": 3712.92, "end": 3718.52, "text": " probabilities. But now we have neural nets and you can have Google translate just actually run", "tokens": [33783, 13, 583, 586, 321, 362, 18161, 36170, 293, 291, 393, 362, 3329, 13799, 445, 767, 1190], "temperature": 0.0, "avg_logprob": -0.07116890722705473, "compression_ratio": 1.576086956521739, "no_speech_prob": 5.8268058637622744e-05}, {"id": 395, "seek": 370564, "start": 3718.52, "end": 3726.2799999999997, "text": " on your phone and that's possible because neural net models can be massively more compact than these", "tokens": [322, 428, 2593, 293, 300, 311, 1944, 570, 18161, 2533, 5245, 393, 312, 29379, 544, 14679, 813, 613], "temperature": 0.0, "avg_logprob": -0.07116890722705473, "compression_ratio": 1.576086956521739, "no_speech_prob": 5.8268058637622744e-05}, {"id": 396, "seek": 372628, "start": 3726.28, "end": 3737.32, "text": " old N-gram language models. But nevertheless before we get onto the neural models let's just", "tokens": [1331, 426, 12, 1342, 2856, 5245, 13, 583, 26924, 949, 321, 483, 3911, 264, 18161, 5245, 718, 311, 445], "temperature": 0.0, "avg_logprob": -0.10458947571230606, "compression_ratio": 1.5683060109289617, "no_speech_prob": 1.4507378182315733e-05}, {"id": 397, "seek": 372628, "start": 3740.36, "end": 3747.6400000000003, "text": " sort of look at the example of how these work. So it's trivial to train an N-gram language model", "tokens": [1333, 295, 574, 412, 264, 1365, 295, 577, 613, 589, 13, 407, 309, 311, 26703, 281, 3847, 364, 426, 12, 1342, 2856, 2316], "temperature": 0.0, "avg_logprob": -0.10458947571230606, "compression_ratio": 1.5683060109289617, "no_speech_prob": 1.4507378182315733e-05}, {"id": 398, "seek": 372628, "start": 3747.6400000000003, "end": 3753.0800000000004, "text": " because you really just count how often words sequences occur in a corpus and you're ready to go.", "tokens": [570, 291, 534, 445, 1207, 577, 2049, 2283, 22978, 5160, 294, 257, 1181, 31624, 293, 291, 434, 1919, 281, 352, 13], "temperature": 0.0, "avg_logprob": -0.10458947571230606, "compression_ratio": 1.5683060109289617, "no_speech_prob": 1.4507378182315733e-05}, {"id": 399, "seek": 375308, "start": 3753.08, "end": 3757.72, "text": " So these models can be trained in seconds. That's really good. That's not like sitting around", "tokens": [407, 613, 5245, 393, 312, 8895, 294, 3949, 13, 663, 311, 534, 665, 13, 663, 311, 406, 411, 3798, 926], "temperature": 0.0, "avg_logprob": -0.11702157955358525, "compression_ratio": 1.6317991631799162, "no_speech_prob": 0.00010712835501180962}, {"id": 400, "seek": 375308, "start": 3757.72, "end": 3765.96, "text": " for training neural networks. So if I train on my laptop a small language model on you know about", "tokens": [337, 3097, 18161, 9590, 13, 407, 498, 286, 3847, 322, 452, 10732, 257, 1359, 2856, 2316, 322, 291, 458, 466], "temperature": 0.0, "avg_logprob": -0.11702157955358525, "compression_ratio": 1.6317991631799162, "no_speech_prob": 0.00010712835501180962}, {"id": 401, "seek": 375308, "start": 3767.0, "end": 3774.2, "text": " 1.7 million words as a tri-gram model I can then ask it to generate text. If I give it a couple of", "tokens": [502, 13, 22, 2459, 2283, 382, 257, 1376, 12, 1342, 2316, 286, 393, 550, 1029, 309, 281, 8460, 2487, 13, 759, 286, 976, 309, 257, 1916, 295], "temperature": 0.0, "avg_logprob": -0.11702157955358525, "compression_ratio": 1.6317991631799162, "no_speech_prob": 0.00010712835501180962}, {"id": 402, "seek": 375308, "start": 3774.2, "end": 3782.04, "text": " words today I can then get it to sort of suggest a word that might come next. And the way I do that", "tokens": [2283, 965, 286, 393, 550, 483, 309, 281, 1333, 295, 3402, 257, 1349, 300, 1062, 808, 958, 13, 400, 264, 636, 286, 360, 300], "temperature": 0.0, "avg_logprob": -0.11702157955358525, "compression_ratio": 1.6317991631799162, "no_speech_prob": 0.00010712835501180962}, {"id": 403, "seek": 378204, "start": 3782.04, "end": 3787.72, "text": " is the language model knows the probability distribution of things that can come next.", "tokens": [307, 264, 2856, 2316, 3255, 264, 8482, 7316, 295, 721, 300, 393, 808, 958, 13], "temperature": 0.0, "avg_logprob": -0.18947075542650724, "compression_ratio": 1.83, "no_speech_prob": 9.720163507154211e-05}, {"id": 404, "seek": 378204, "start": 3788.6, "end": 3794.36, "text": " Now there's a kind of a crude probability distribution. I mean because effectively over", "tokens": [823, 456, 311, 257, 733, 295, 257, 30796, 8482, 7316, 13, 286, 914, 570, 8659, 670], "temperature": 0.0, "avg_logprob": -0.18947075542650724, "compression_ratio": 1.83, "no_speech_prob": 9.720163507154211e-05}, {"id": 405, "seek": 378204, "start": 3794.36, "end": 3800.2, "text": " this relatively small corpus there were things that occurred once Italian and Emirate. There are", "tokens": [341, 7226, 1359, 1181, 31624, 456, 645, 721, 300, 11068, 1564, 10003, 293, 38426, 473, 13, 821, 366], "temperature": 0.0, "avg_logprob": -0.18947075542650724, "compression_ratio": 1.83, "no_speech_prob": 9.720163507154211e-05}, {"id": 406, "seek": 378204, "start": 3800.2, "end": 3805.96, "text": " things that occurred twice price. There were things that occurred four times company and bank.", "tokens": [721, 300, 11068, 6091, 3218, 13, 821, 645, 721, 300, 11068, 1451, 1413, 2237, 293, 3765, 13], "temperature": 0.0, "avg_logprob": -0.18947075542650724, "compression_ratio": 1.83, "no_speech_prob": 9.720163507154211e-05}, {"id": 407, "seek": 380596, "start": 3805.96, "end": 3814.92, "text": " It's sort of fairly crude and rough but I never let's get probability estimates. I can then say okay", "tokens": [467, 311, 1333, 295, 6457, 30796, 293, 5903, 457, 286, 1128, 718, 311, 483, 8482, 20561, 13, 286, 393, 550, 584, 1392], "temperature": 0.0, "avg_logprob": -0.13904328413412603, "compression_ratio": 1.5526315789473684, "no_speech_prob": 9.576914453646168e-05}, {"id": 408, "seek": 380596, "start": 3814.92, "end": 3822.12, "text": " based on this let's take this probability distribution and then we'll just sample an X word. So the", "tokens": [2361, 322, 341, 718, 311, 747, 341, 8482, 7316, 293, 550, 321, 603, 445, 6889, 364, 1783, 1349, 13, 407, 264], "temperature": 0.0, "avg_logprob": -0.13904328413412603, "compression_ratio": 1.5526315789473684, "no_speech_prob": 9.576914453646168e-05}, {"id": 409, "seek": 380596, "start": 3822.12, "end": 3828.68, "text": " two most likely words the sample a company or bank but we're rolling the dice and we might get", "tokens": [732, 881, 3700, 2283, 264, 6889, 257, 2237, 420, 3765, 457, 321, 434, 9439, 264, 10313, 293, 321, 1062, 483], "temperature": 0.0, "avg_logprob": -0.13904328413412603, "compression_ratio": 1.5526315789473684, "no_speech_prob": 9.576914453646168e-05}, {"id": 410, "seek": 382868, "start": 3828.68, "end": 3835.8799999999997, "text": " any of the words that had come next. So maybe I sample price. Now I'll condition on price", "tokens": [604, 295, 264, 2283, 300, 632, 808, 958, 13, 407, 1310, 286, 6889, 3218, 13, 823, 286, 603, 4188, 322, 3218], "temperature": 0.0, "avg_logprob": -0.11511948903401693, "compression_ratio": 1.898989898989899, "no_speech_prob": 3.69528861483559e-05}, {"id": 411, "seek": 382868, "start": 3835.8799999999997, "end": 3843.0, "text": " on the price and look up the probability distribution of what comes next the most likely thing is", "tokens": [322, 264, 3218, 293, 574, 493, 264, 8482, 7316, 295, 437, 1487, 958, 264, 881, 3700, 551, 307], "temperature": 0.0, "avg_logprob": -0.11511948903401693, "compression_ratio": 1.898989898989899, "no_speech_prob": 3.69528861483559e-05}, {"id": 412, "seek": 382868, "start": 3843.0, "end": 3851.24, "text": " of. And so again I'll sample and maybe this time I'll pick up of and then I will now condition", "tokens": [295, 13, 400, 370, 797, 286, 603, 6889, 293, 1310, 341, 565, 286, 603, 1888, 493, 295, 293, 550, 286, 486, 586, 4188], "temperature": 0.0, "avg_logprob": -0.11511948903401693, "compression_ratio": 1.898989898989899, "no_speech_prob": 3.69528861483559e-05}, {"id": 413, "seek": 382868, "start": 3851.24, "end": 3858.44, "text": " on price of and I will look up the probability distribution of words following that and I get", "tokens": [322, 3218, 295, 293, 286, 486, 574, 493, 264, 8482, 7316, 295, 2283, 3480, 300, 293, 286, 483], "temperature": 0.0, "avg_logprob": -0.11511948903401693, "compression_ratio": 1.898989898989899, "no_speech_prob": 3.69528861483559e-05}, {"id": 414, "seek": 385844, "start": 3858.44, "end": 3865.8, "text": " this probability distribution and I'll sample randomly some word from it and maybe this time of", "tokens": [341, 8482, 7316, 293, 286, 603, 6889, 16979, 512, 1349, 490, 309, 293, 1310, 341, 565, 295], "temperature": 0.0, "avg_logprob": -0.12080595606849306, "compression_ratio": 1.620253164556962, "no_speech_prob": 0.00020194100216031075}, {"id": 415, "seek": 385844, "start": 3865.8, "end": 3873.0, "text": " sample of rare but possible one like gold and I can keep on going and I'll get out something like", "tokens": [6889, 295, 5892, 457, 1944, 472, 411, 3821, 293, 286, 393, 1066, 322, 516, 293, 286, 603, 483, 484, 746, 411], "temperature": 0.0, "avg_logprob": -0.12080595606849306, "compression_ratio": 1.620253164556962, "no_speech_prob": 0.00020194100216031075}, {"id": 416, "seek": 385844, "start": 3873.0, "end": 3879.88, "text": " this. Today the price of gold per ton while production of shoe lasts and shoe industry the bank", "tokens": [341, 13, 2692, 264, 3218, 295, 3821, 680, 2952, 1339, 4265, 295, 12796, 20669, 293, 12796, 3518, 264, 3765], "temperature": 0.0, "avg_logprob": -0.12080595606849306, "compression_ratio": 1.620253164556962, "no_speech_prob": 0.00020194100216031075}, {"id": 417, "seek": 385844, "start": 3879.88, "end": 3886.44, "text": " intervened just after it considered rejected an IMF demand to rebuild depleted European stocks", "tokens": [17104, 292, 445, 934, 309, 4888, 15749, 364, 21463, 37, 4733, 281, 16877, 37546, 10993, 6473, 12966], "temperature": 0.0, "avg_logprob": -0.12080595606849306, "compression_ratio": 1.620253164556962, "no_speech_prob": 0.00020194100216031075}, {"id": 418, "seek": 388644, "start": 3886.44, "end": 3895.0, "text": " set 30 in primary 76 cents a share. So what a just a simple tri-gram model can produce over not", "tokens": [992, 2217, 294, 6194, 24733, 14941, 257, 2073, 13, 407, 437, 257, 445, 257, 2199, 1376, 12, 1342, 2316, 393, 5258, 670, 406], "temperature": 0.0, "avg_logprob": -0.19520532944623162, "compression_ratio": 1.5743801652892562, "no_speech_prob": 0.00010167636355618015}, {"id": 419, "seek": 388644, "start": 3895.0, "end": 3901.4, "text": " very much text is actually already kind of interesting like it's actually surprisingly grammatical", "tokens": [588, 709, 2487, 307, 767, 1217, 733, 295, 1880, 411, 309, 311, 767, 17600, 17570, 267, 804], "temperature": 0.0, "avg_logprob": -0.19520532944623162, "compression_ratio": 1.5743801652892562, "no_speech_prob": 0.00010167636355618015}, {"id": 420, "seek": 388644, "start": 3901.4, "end": 3907.2400000000002, "text": " right there are whole pieces of it while production of shoe lasts and shoe industry the bank", "tokens": [558, 456, 366, 1379, 3755, 295, 309, 1339, 4265, 295, 12796, 20669, 293, 12796, 3518, 264, 3765], "temperature": 0.0, "avg_logprob": -0.19520532944623162, "compression_ratio": 1.5743801652892562, "no_speech_prob": 0.00010167636355618015}, {"id": 421, "seek": 388644, "start": 3907.2400000000002, "end": 3912.68, "text": " intervened just after it considered a rejected an IMF demand it's really actually pretty good", "tokens": [17104, 292, 445, 934, 309, 4888, 257, 15749, 364, 21463, 37, 4733, 309, 311, 534, 767, 1238, 665], "temperature": 0.0, "avg_logprob": -0.19520532944623162, "compression_ratio": 1.5743801652892562, "no_speech_prob": 0.00010167636355618015}, {"id": 422, "seek": 391268, "start": 3912.68, "end": 3919.3999999999996, "text": " grammatical text so it's it's sort of amazing that these simple n-gram models actually can model", "tokens": [17570, 267, 804, 2487, 370, 309, 311, 309, 311, 1333, 295, 2243, 300, 613, 2199, 297, 12, 1342, 5245, 767, 393, 2316], "temperature": 0.0, "avg_logprob": -0.09677127099806263, "compression_ratio": 1.7142857142857142, "no_speech_prob": 0.00014640022709500045}, {"id": 423, "seek": 391268, "start": 3919.3999999999996, "end": 3925.72, "text": " a lot of human language. On the other hand it's not a very good piece of text it's completely", "tokens": [257, 688, 295, 1952, 2856, 13, 1282, 264, 661, 1011, 309, 311, 406, 257, 588, 665, 2522, 295, 2487, 309, 311, 2584], "temperature": 0.0, "avg_logprob": -0.09677127099806263, "compression_ratio": 1.7142857142857142, "no_speech_prob": 0.00014640022709500045}, {"id": 424, "seek": 391268, "start": 3925.72, "end": 3934.2799999999997, "text": " incoherent and makes no sense and so to actually be able to generate text that seems like it makes", "tokens": [834, 78, 511, 317, 293, 1669, 572, 2020, 293, 370, 281, 767, 312, 1075, 281, 8460, 2487, 300, 2544, 411, 309, 1669], "temperature": 0.0, "avg_logprob": -0.09677127099806263, "compression_ratio": 1.7142857142857142, "no_speech_prob": 0.00014640022709500045}, {"id": 425, "seek": 391268, "start": 3934.2799999999997, "end": 3941.48, "text": " sense we're going to need a considerably better language model and that's precisely what newer", "tokens": [2020, 321, 434, 516, 281, 643, 257, 31308, 1101, 2856, 2316, 293, 300, 311, 13402, 437, 17628], "temperature": 0.0, "avg_logprob": -0.09677127099806263, "compression_ratio": 1.7142857142857142, "no_speech_prob": 0.00014640022709500045}, {"id": 426, "seek": 394148, "start": 3941.48, "end": 3949.0, "text": " language models have allowed us to build as we'll see later. Okay so how can we build a newer", "tokens": [2856, 5245, 362, 4350, 505, 281, 1322, 382, 321, 603, 536, 1780, 13, 1033, 370, 577, 393, 321, 1322, 257, 17628], "temperature": 0.0, "avg_logprob": -0.09885469396063622, "compression_ratio": 1.6796536796536796, "no_speech_prob": 6.809767364757136e-05}, {"id": 427, "seek": 394148, "start": 3949.0, "end": 3956.12, "text": " language model and so first of all we're going to do a simple one and then we'll see where we get", "tokens": [2856, 2316, 293, 370, 700, 295, 439, 321, 434, 516, 281, 360, 257, 2199, 472, 293, 550, 321, 603, 536, 689, 321, 483], "temperature": 0.0, "avg_logprob": -0.09885469396063622, "compression_ratio": 1.6796536796536796, "no_speech_prob": 6.809767364757136e-05}, {"id": 428, "seek": 394148, "start": 3956.12, "end": 3964.28, "text": " but to move into a current neural nets might still take us to next time. So we've going to have input", "tokens": [457, 281, 1286, 666, 257, 2190, 18161, 36170, 1062, 920, 747, 505, 281, 958, 565, 13, 407, 321, 600, 516, 281, 362, 4846], "temperature": 0.0, "avg_logprob": -0.09885469396063622, "compression_ratio": 1.6796536796536796, "no_speech_prob": 6.809767364757136e-05}, {"id": 429, "seek": 394148, "start": 3964.28, "end": 3970.84, "text": " sequence of words and we want a probability distribution over the next word. Well the simplest", "tokens": [8310, 295, 2283, 293, 321, 528, 257, 8482, 7316, 670, 264, 958, 1349, 13, 1042, 264, 22811], "temperature": 0.0, "avg_logprob": -0.09885469396063622, "compression_ratio": 1.6796536796536796, "no_speech_prob": 6.809767364757136e-05}, {"id": 430, "seek": 397084, "start": 3970.84, "end": 3978.44, "text": " thing that we could try is to say well kind of the only tool we have so far is a window-based", "tokens": [551, 300, 321, 727, 853, 307, 281, 584, 731, 733, 295, 264, 787, 2290, 321, 362, 370, 1400, 307, 257, 4910, 12, 6032], "temperature": 0.0, "avg_logprob": -0.10364289336152128, "compression_ratio": 1.6521739130434783, "no_speech_prob": 0.00013516431499738246}, {"id": 431, "seek": 397084, "start": 3978.44, "end": 3987.08, "text": " classifier so what we can say you know what we've done previously either for our name density", "tokens": [1508, 9902, 370, 437, 321, 393, 584, 291, 458, 437, 321, 600, 1096, 8046, 2139, 337, 527, 1315, 10305], "temperature": 0.0, "avg_logprob": -0.10364289336152128, "compression_ratio": 1.6521739130434783, "no_speech_prob": 0.00013516431499738246}, {"id": 432, "seek": 397084, "start": 3987.08, "end": 3992.28, "text": " recognize in lecture three or what I just showed you for the dependency parser is we have some", "tokens": [5521, 294, 7991, 1045, 420, 437, 286, 445, 4712, 291, 337, 264, 33621, 21156, 260, 307, 321, 362, 512], "temperature": 0.0, "avg_logprob": -0.10364289336152128, "compression_ratio": 1.6521739130434783, "no_speech_prob": 0.00013516431499738246}, {"id": 433, "seek": 397084, "start": 3992.28, "end": 3999.08, "text": " context window we put it through a neural net and we predict something as a classifier. So before", "tokens": [4319, 4910, 321, 829, 309, 807, 257, 18161, 2533, 293, 321, 6069, 746, 382, 257, 1508, 9902, 13, 407, 949], "temperature": 0.0, "avg_logprob": -0.10364289336152128, "compression_ratio": 1.6521739130434783, "no_speech_prob": 0.00013516431499738246}, {"id": 434, "seek": 399908, "start": 3999.08, "end": 4008.2799999999997, "text": " we were predicting a location but maybe instead we could reuse exactly the same technology and say", "tokens": [321, 645, 32884, 257, 4914, 457, 1310, 2602, 321, 727, 26225, 2293, 264, 912, 2899, 293, 584], "temperature": 0.0, "avg_logprob": -0.09650432362275965, "compression_ratio": 1.5240641711229947, "no_speech_prob": 2.8840730010415427e-05}, {"id": 435, "seek": 399908, "start": 4008.2799999999997, "end": 4014.44, "text": " we're going to have a window-based classifier so we're discarding the further away words just like", "tokens": [321, 434, 516, 281, 362, 257, 4910, 12, 6032, 1508, 9902, 370, 321, 434, 31597, 278, 264, 3052, 1314, 2283, 445, 411], "temperature": 0.0, "avg_logprob": -0.09650432362275965, "compression_ratio": 1.5240641711229947, "no_speech_prob": 2.8840730010415427e-05}, {"id": 436, "seek": 399908, "start": 4014.44, "end": 4023.24, "text": " in a n-gram language model but we'll feed this fixed window into a neural net so we can", "tokens": [294, 257, 297, 12, 1342, 2856, 2316, 457, 321, 603, 3154, 341, 6806, 4910, 666, 257, 18161, 2533, 370, 321, 393], "temperature": 0.0, "avg_logprob": -0.09650432362275965, "compression_ratio": 1.5240641711229947, "no_speech_prob": 2.8840730010415427e-05}, {"id": 437, "seek": 402324, "start": 4023.24, "end": 4031.64, "text": " catenate the word embeddings we put it through a hidden layer and then we have a softmax classifier", "tokens": [3857, 268, 473, 264, 1349, 12240, 29432, 321, 829, 309, 807, 257, 7633, 4583, 293, 550, 321, 362, 257, 2787, 41167, 1508, 9902], "temperature": 0.0, "avg_logprob": -0.09854032776572487, "compression_ratio": 1.6285714285714286, "no_speech_prob": 1.4734735486854333e-05}, {"id": 438, "seek": 402324, "start": 4031.64, "end": 4039.8799999999997, "text": " over our vocabulary and so now rather than predicting something like location or left arc", "tokens": [670, 527, 19864, 293, 370, 586, 2831, 813, 32884, 746, 411, 4914, 420, 1411, 10346], "temperature": 0.0, "avg_logprob": -0.09854032776572487, "compression_ratio": 1.6285714285714286, "no_speech_prob": 1.4734735486854333e-05}, {"id": 439, "seek": 402324, "start": 4039.8799999999997, "end": 4046.3599999999997, "text": " and the dependency parser we're going to have a softmax over the entire vocabulary sort of like", "tokens": [293, 264, 33621, 21156, 260, 321, 434, 516, 281, 362, 257, 2787, 41167, 670, 264, 2302, 19864, 1333, 295, 411], "temperature": 0.0, "avg_logprob": -0.09854032776572487, "compression_ratio": 1.6285714285714286, "no_speech_prob": 1.4734735486854333e-05}, {"id": 440, "seek": 404636, "start": 4046.36, "end": 4053.32, "text": " we did with the skip-gram negative sampling model in the first two lectures and so we're going to", "tokens": [321, 630, 365, 264, 10023, 12, 1342, 3671, 21179, 2316, 294, 264, 700, 732, 16564, 293, 370, 321, 434, 516, 281], "temperature": 0.0, "avg_logprob": -0.11548846960067749, "compression_ratio": 1.4974093264248705, "no_speech_prob": 1.8016753529082052e-05}, {"id": 441, "seek": 404636, "start": 4053.32, "end": 4061.08, "text": " see this choice as predicting what word that comes next whether it produces laptops minds books", "tokens": [536, 341, 3922, 382, 32884, 437, 1349, 300, 1487, 958, 1968, 309, 14725, 27642, 9634, 3642], "temperature": 0.0, "avg_logprob": -0.11548846960067749, "compression_ratio": 1.4974093264248705, "no_speech_prob": 1.8016753529082052e-05}, {"id": 442, "seek": 404636, "start": 4061.08, "end": 4071.96, "text": " etc. Okay so this is a fairly simple fixed window neural net classifier but this is essentially", "tokens": [5183, 13, 1033, 370, 341, 307, 257, 6457, 2199, 6806, 4910, 18161, 2533, 1508, 9902, 457, 341, 307, 4476], "temperature": 0.0, "avg_logprob": -0.11548846960067749, "compression_ratio": 1.4974093264248705, "no_speech_prob": 1.8016753529082052e-05}, {"id": 443, "seek": 407196, "start": 4071.96, "end": 4081.96, "text": " a famous early model in the use of neural nets for NLP applications so first a 2000 conference", "tokens": [257, 4618, 2440, 2316, 294, 264, 764, 295, 18161, 36170, 337, 426, 45196, 5821, 370, 700, 257, 8132, 7586], "temperature": 0.0, "avg_logprob": -0.19550081159247726, "compression_ratio": 1.4893617021276595, "no_speech_prob": 0.0001437500468455255}, {"id": 444, "seek": 407196, "start": 4081.96, "end": 4089.56, "text": " paper and then a somewhat later journal paper Yashua Benjiro and colleagues introduced precisely", "tokens": [3035, 293, 550, 257, 8344, 1780, 6708, 3035, 398, 1299, 4398, 3964, 4013, 340, 293, 7734, 7268, 13402], "temperature": 0.0, "avg_logprob": -0.19550081159247726, "compression_ratio": 1.4893617021276595, "no_speech_prob": 0.0001437500468455255}, {"id": 445, "seek": 407196, "start": 4089.56, "end": 4095.88, "text": " this model as the neural probabilistic language model and they were already able to show", "tokens": [341, 2316, 382, 264, 18161, 31959, 3142, 2856, 2316, 293, 436, 645, 1217, 1075, 281, 855], "temperature": 0.0, "avg_logprob": -0.19550081159247726, "compression_ratio": 1.4893617021276595, "no_speech_prob": 0.0001437500468455255}, {"id": 446, "seek": 409588, "start": 4095.88, "end": 4104.12, "text": " that this could give interesting good results for language modeling and so it wasn't a great", "tokens": [300, 341, 727, 976, 1880, 665, 3542, 337, 2856, 15983, 293, 370, 309, 2067, 380, 257, 869], "temperature": 0.0, "avg_logprob": -0.07516446709632874, "compression_ratio": 1.625, "no_speech_prob": 6.806408055126667e-05}, {"id": 447, "seek": 409588, "start": 4104.12, "end": 4111.4800000000005, "text": " solution for a neural language modeling but it still had value so it didn't solve the problem", "tokens": [3827, 337, 257, 18161, 2856, 15983, 457, 309, 920, 632, 2158, 370, 309, 994, 380, 5039, 264, 1154], "temperature": 0.0, "avg_logprob": -0.07516446709632874, "compression_ratio": 1.625, "no_speech_prob": 6.806408055126667e-05}, {"id": 448, "seek": 409588, "start": 4111.4800000000005, "end": 4118.12, "text": " of allowing us to have bigger context to predict what words are going to come next it's in that way", "tokens": [295, 8293, 505, 281, 362, 3801, 4319, 281, 6069, 437, 2283, 366, 516, 281, 808, 958, 309, 311, 294, 300, 636], "temperature": 0.0, "avg_logprob": -0.07516446709632874, "compression_ratio": 1.625, "no_speech_prob": 6.806408055126667e-05}, {"id": 449, "seek": 411812, "start": 4118.12, "end": 4126.2, "text": " limited exactly like an end-gram language model is but it does have all the advantages of distributed", "tokens": [5567, 2293, 411, 364, 917, 12, 1342, 2856, 2316, 307, 457, 309, 775, 362, 439, 264, 14906, 295, 12631], "temperature": 0.0, "avg_logprob": -0.10620915262322676, "compression_ratio": 1.6797752808988764, "no_speech_prob": 4.261783033143729e-05}, {"id": 450, "seek": 411812, "start": 4126.2, "end": 4134.84, "text": " representations so rather than having these counts for words sequences that are very sparse and", "tokens": [33358, 370, 2831, 813, 1419, 613, 14893, 337, 2283, 22978, 300, 366, 588, 637, 11668, 293], "temperature": 0.0, "avg_logprob": -0.10620915262322676, "compression_ratio": 1.6797752808988764, "no_speech_prob": 4.261783033143729e-05}, {"id": 451, "seek": 411812, "start": 4134.84, "end": 4142.92, "text": " very crude we can use distributed representative representations of words which then make predictions", "tokens": [588, 30796, 321, 393, 764, 12631, 12424, 33358, 295, 2283, 597, 550, 652, 21264], "temperature": 0.0, "avg_logprob": -0.10620915262322676, "compression_ratio": 1.6797752808988764, "no_speech_prob": 4.261783033143729e-05}, {"id": 452, "seek": 414292, "start": 4142.92, "end": 4150.52, "text": " that semantically similar words should give similar probability distribution so the idea of that", "tokens": [300, 4361, 49505, 2531, 2283, 820, 976, 2531, 8482, 7316, 370, 264, 1558, 295, 300], "temperature": 0.0, "avg_logprob": -0.09302262663841247, "compression_ratio": 1.7579908675799087, "no_speech_prob": 4.395973519422114e-05}, {"id": 453, "seek": 414292, "start": 4150.52, "end": 4159.0, "text": " is if we use some other word here like maybe the pupils open there well maybe in our training data", "tokens": [307, 498, 321, 764, 512, 661, 1349, 510, 411, 1310, 264, 38404, 1269, 456, 731, 1310, 294, 527, 3097, 1412], "temperature": 0.0, "avg_logprob": -0.09302262663841247, "compression_ratio": 1.7579908675799087, "no_speech_prob": 4.395973519422114e-05}, {"id": 454, "seek": 414292, "start": 4159.0, "end": 4165.24, "text": " we'd seen sentences about students but we've never seen sentences about pupils an end-gram", "tokens": [321, 1116, 1612, 16579, 466, 1731, 457, 321, 600, 1128, 1612, 16579, 466, 38404, 364, 917, 12, 1342], "temperature": 0.0, "avg_logprob": -0.09302262663841247, "compression_ratio": 1.7579908675799087, "no_speech_prob": 4.395973519422114e-05}, {"id": 455, "seek": 414292, "start": 4165.24, "end": 4171.96, "text": " language model then would sort of have no idea what probabilities to use whereas a neural language", "tokens": [2856, 2316, 550, 576, 1333, 295, 362, 572, 1558, 437, 33783, 281, 764, 9735, 257, 18161, 2856], "temperature": 0.0, "avg_logprob": -0.09302262663841247, "compression_ratio": 1.7579908675799087, "no_speech_prob": 4.395973519422114e-05}, {"id": 456, "seek": 417196, "start": 4171.96, "end": 4177.24, "text": " model can say well pupils is kind of similar to students therefore I can predict similarly to", "tokens": [2316, 393, 584, 731, 38404, 307, 733, 295, 2531, 281, 1731, 4412, 286, 393, 6069, 14138, 281], "temperature": 0.0, "avg_logprob": -0.11361818453844856, "compression_ratio": 1.5923913043478262, "no_speech_prob": 3.06944566546008e-05}, {"id": 457, "seek": 417196, "start": 4177.24, "end": 4186.28, "text": " what I would have predicted for students okay so there's now no sparsity problem we don't need to", "tokens": [437, 286, 576, 362, 19147, 337, 1731, 1392, 370, 456, 311, 586, 572, 637, 685, 507, 1154, 321, 500, 380, 643, 281], "temperature": 0.0, "avg_logprob": -0.11361818453844856, "compression_ratio": 1.5923913043478262, "no_speech_prob": 3.06944566546008e-05}, {"id": 458, "seek": 417196, "start": 4187.4, "end": 4198.12, "text": " store billions of end-gram counts we simply need to store our word vectors and our W and new matrices", "tokens": [3531, 17375, 295, 917, 12, 1342, 14893, 321, 2935, 643, 281, 3531, 527, 1349, 18875, 293, 527, 343, 293, 777, 32284], "temperature": 0.0, "avg_logprob": -0.11361818453844856, "compression_ratio": 1.5923913043478262, "no_speech_prob": 3.06944566546008e-05}, {"id": 459, "seek": 419812, "start": 4198.12, "end": 4205.88, "text": " but we still have the remaining problems that our fixed windows too small we can try and make the", "tokens": [457, 321, 920, 362, 264, 8877, 2740, 300, 527, 6806, 9309, 886, 1359, 321, 393, 853, 293, 652, 264], "temperature": 0.0, "avg_logprob": -0.1061607654278095, "compression_ratio": 1.672514619883041, "no_speech_prob": 0.00017389337881468236}, {"id": 460, "seek": 419812, "start": 4205.88, "end": 4213.4, "text": " window larger if we do that W the W matrix gets bigger but that also points out another problem", "tokens": [4910, 4833, 498, 321, 360, 300, 343, 264, 343, 8141, 2170, 3801, 457, 300, 611, 2793, 484, 1071, 1154], "temperature": 0.0, "avg_logprob": -0.1061607654278095, "compression_ratio": 1.672514619883041, "no_speech_prob": 0.00017389337881468236}, {"id": 461, "seek": 419812, "start": 4213.4, "end": 4222.599999999999, "text": " with this model not only can the window never be large enough but W is just a trained matrix", "tokens": [365, 341, 2316, 406, 787, 393, 264, 4910, 1128, 312, 2416, 1547, 457, 343, 307, 445, 257, 8895, 8141], "temperature": 0.0, "avg_logprob": -0.1061607654278095, "compression_ratio": 1.672514619883041, "no_speech_prob": 0.00017389337881468236}, {"id": 462, "seek": 422260, "start": 4222.6, "end": 4229.8, "text": " and so therefore we're learning completely different weights for each position of context the", "tokens": [293, 370, 4412, 321, 434, 2539, 2584, 819, 17443, 337, 1184, 2535, 295, 4319, 264], "temperature": 0.0, "avg_logprob": -0.0944199938523142, "compression_ratio": 1.8872549019607843, "no_speech_prob": 9.160667104879394e-05}, {"id": 463, "seek": 422260, "start": 4229.8, "end": 4235.4800000000005, "text": " word minus one position the word minus two the word minus three and the word minus four so that", "tokens": [1349, 3175, 472, 2535, 264, 1349, 3175, 732, 264, 1349, 3175, 1045, 293, 264, 1349, 3175, 1451, 370, 300], "temperature": 0.0, "avg_logprob": -0.0944199938523142, "compression_ratio": 1.8872549019607843, "no_speech_prob": 9.160667104879394e-05}, {"id": 464, "seek": 422260, "start": 4235.4800000000005, "end": 4244.04, "text": " there's no sharing in the model as to how it treats words in different positions even though in", "tokens": [456, 311, 572, 5414, 294, 264, 2316, 382, 281, 577, 309, 19566, 2283, 294, 819, 8432, 754, 1673, 294], "temperature": 0.0, "avg_logprob": -0.0944199938523142, "compression_ratio": 1.8872549019607843, "no_speech_prob": 9.160667104879394e-05}, {"id": 465, "seek": 424404, "start": 4244.04, "end": 4252.68, "text": " some sense they will contribute semantic components that are at least somewhat position independent so", "tokens": [512, 2020, 436, 486, 10586, 47982, 6677, 300, 366, 412, 1935, 8344, 2535, 6695, 370], "temperature": 0.0, "avg_logprob": -0.10502963480742081, "compression_ratio": 1.7831858407079646, "no_speech_prob": 2.210954698966816e-05}, {"id": 466, "seek": 424404, "start": 4252.68, "end": 4259.56, "text": " again for those of if you sort of think back to either a naive based model or what we saw with the", "tokens": [797, 337, 729, 295, 498, 291, 1333, 295, 519, 646, 281, 2139, 257, 29052, 2361, 2316, 420, 437, 321, 1866, 365, 264], "temperature": 0.0, "avg_logprob": -0.10502963480742081, "compression_ratio": 1.7831858407079646, "no_speech_prob": 2.210954698966816e-05}, {"id": 467, "seek": 424404, "start": 4259.56, "end": 4265.72, "text": " word-to-vec model at the beginning the word-to-vec model or naive based model completely ignores word", "tokens": [1349, 12, 1353, 12, 303, 66, 2316, 412, 264, 2863, 264, 1349, 12, 1353, 12, 303, 66, 2316, 420, 29052, 2361, 2316, 2584, 5335, 2706, 1349], "temperature": 0.0, "avg_logprob": -0.10502963480742081, "compression_ratio": 1.7831858407079646, "no_speech_prob": 2.210954698966816e-05}, {"id": 468, "seek": 424404, "start": 4265.72, "end": 4271.96, "text": " order so it has one set of parameters regardless of what position things occur in that doesn't work", "tokens": [1668, 370, 309, 575, 472, 992, 295, 9834, 10060, 295, 437, 2535, 721, 5160, 294, 300, 1177, 380, 589], "temperature": 0.0, "avg_logprob": -0.10502963480742081, "compression_ratio": 1.7831858407079646, "no_speech_prob": 2.210954698966816e-05}, {"id": 469, "seek": 427196, "start": 4271.96, "end": 4277.4800000000005, "text": " well for language modeling because word order is really important in language modeling if the last", "tokens": [731, 337, 2856, 15983, 570, 1349, 1668, 307, 534, 1021, 294, 2856, 15983, 498, 264, 1036], "temperature": 0.0, "avg_logprob": -0.12317218099321638, "compression_ratio": 1.7897196261682242, "no_speech_prob": 6.587432289961725e-05}, {"id": 470, "seek": 427196, "start": 4277.4800000000005, "end": 4282.84, "text": " word is the that's a really good predictor of there being an adjective or noun following where", "tokens": [1349, 307, 264, 300, 311, 257, 534, 665, 6069, 284, 295, 456, 885, 364, 44129, 420, 23307, 3480, 689], "temperature": 0.0, "avg_logprob": -0.12317218099321638, "compression_ratio": 1.7897196261682242, "no_speech_prob": 6.587432289961725e-05}, {"id": 471, "seek": 427196, "start": 4282.84, "end": 4290.2, "text": " if the word four back is the it doesn't give you the same information so you do want to somewhat", "tokens": [498, 264, 1349, 1451, 646, 307, 264, 309, 1177, 380, 976, 291, 264, 912, 1589, 370, 291, 360, 528, 281, 8344], "temperature": 0.0, "avg_logprob": -0.12317218099321638, "compression_ratio": 1.7897196261682242, "no_speech_prob": 6.587432289961725e-05}, {"id": 472, "seek": 427196, "start": 4291.88, "end": 4298.6, "text": " make use of word order but this model is at the opposite extreme that each position is being", "tokens": [652, 764, 295, 1349, 1668, 457, 341, 2316, 307, 412, 264, 6182, 8084, 300, 1184, 2535, 307, 885], "temperature": 0.0, "avg_logprob": -0.12317218099321638, "compression_ratio": 1.7897196261682242, "no_speech_prob": 6.587432289961725e-05}, {"id": 473, "seek": 429860, "start": 4298.6, "end": 4307.0, "text": " modeled completely independently so what we'd like to have is a neural architecture that can process", "tokens": [37140, 2584, 21761, 370, 437, 321, 1116, 411, 281, 362, 307, 257, 18161, 9482, 300, 393, 1399], "temperature": 0.0, "avg_logprob": -0.051559104294073385, "compression_ratio": 1.5502645502645502, "no_speech_prob": 3.068665319005959e-05}, {"id": 474, "seek": 429860, "start": 4308.04, "end": 4316.280000000001, "text": " an arbitrary amount of context and have more sharing of the parameters while still be sensitive", "tokens": [364, 23211, 2372, 295, 4319, 293, 362, 544, 5414, 295, 264, 9834, 1339, 920, 312, 9477], "temperature": 0.0, "avg_logprob": -0.051559104294073385, "compression_ratio": 1.5502645502645502, "no_speech_prob": 3.068665319005959e-05}, {"id": 475, "seek": 429860, "start": 4316.280000000001, "end": 4323.88, "text": " to proximity and so that's the idea of recurrent neural networks and I'll say about five minutes", "tokens": [281, 27632, 293, 370, 300, 311, 264, 1558, 295, 18680, 1753, 18161, 9590, 293, 286, 603, 584, 466, 1732, 2077], "temperature": 0.0, "avg_logprob": -0.051559104294073385, "compression_ratio": 1.5502645502645502, "no_speech_prob": 3.068665319005959e-05}, {"id": 476, "seek": 432388, "start": 4323.88, "end": 4330.68, "text": " about these today and then next time we'll return and do more about neural of recurrent neural", "tokens": [466, 613, 965, 293, 550, 958, 565, 321, 603, 2736, 293, 360, 544, 466, 18161, 295, 18680, 1753, 18161], "temperature": 0.0, "avg_logprob": -0.06967649762592619, "compression_ratio": 1.8896103896103895, "no_speech_prob": 5.594575486611575e-05}, {"id": 477, "seek": 432388, "start": 4330.68, "end": 4340.04, "text": " networks so for the recurrent neural network rather than having a single hidden layer inside our", "tokens": [9590, 370, 337, 264, 18680, 1753, 18161, 3209, 2831, 813, 1419, 257, 2167, 7633, 4583, 1854, 527], "temperature": 0.0, "avg_logprob": -0.06967649762592619, "compression_ratio": 1.8896103896103895, "no_speech_prob": 5.594575486611575e-05}, {"id": 478, "seek": 432388, "start": 4340.04, "end": 4348.84, "text": " classifier here that we compute each time for the recurrent neural network we have the hidden layer", "tokens": [1508, 9902, 510, 300, 321, 14722, 1184, 565, 337, 264, 18680, 1753, 18161, 3209, 321, 362, 264, 7633, 4583], "temperature": 0.0, "avg_logprob": -0.06967649762592619, "compression_ratio": 1.8896103896103895, "no_speech_prob": 5.594575486611575e-05}, {"id": 479, "seek": 434884, "start": 4348.84, "end": 4356.4400000000005, "text": " which often was referred to as the hidden state but we maintain it over time and we feed it back", "tokens": [597, 2049, 390, 10839, 281, 382, 264, 7633, 1785, 457, 321, 6909, 309, 670, 565, 293, 321, 3154, 309, 646], "temperature": 0.0, "avg_logprob": -0.06827286819913495, "compression_ratio": 1.7017543859649122, "no_speech_prob": 3.936308712582104e-05}, {"id": 480, "seek": 434884, "start": 4356.4400000000005, "end": 4362.68, "text": " into itself so that's what the word recurrent as meaning that you're sort of feeding the hidden", "tokens": [666, 2564, 370, 300, 311, 437, 264, 1349, 18680, 1753, 382, 3620, 300, 291, 434, 1333, 295, 12919, 264, 7633], "temperature": 0.0, "avg_logprob": -0.06827286819913495, "compression_ratio": 1.7017543859649122, "no_speech_prob": 3.936308712582104e-05}, {"id": 481, "seek": 434884, "start": 4362.68, "end": 4373.400000000001, "text": " layer back into itself so what we do is based on the first word we compute a hidden representation", "tokens": [4583, 646, 666, 2564, 370, 437, 321, 360, 307, 2361, 322, 264, 700, 1349, 321, 14722, 257, 7633, 10290], "temperature": 0.0, "avg_logprob": -0.06827286819913495, "compression_ratio": 1.7017543859649122, "no_speech_prob": 3.936308712582104e-05}, {"id": 482, "seek": 437340, "start": 4373.4, "end": 4381.879999999999, "text": " kind of like before which can be used to predict the next word but then for when we want to", "tokens": [733, 295, 411, 949, 597, 393, 312, 1143, 281, 6069, 264, 958, 1349, 457, 550, 337, 562, 321, 528, 281], "temperature": 0.0, "avg_logprob": -0.03997474817129282, "compression_ratio": 1.9054054054054055, "no_speech_prob": 2.0761704945471138e-05}, {"id": 483, "seek": 437340, "start": 4381.879999999999, "end": 4389.5599999999995, "text": " predict what comes after the second word we not only feed in the second word we feed in the hidden", "tokens": [6069, 437, 1487, 934, 264, 1150, 1349, 321, 406, 787, 3154, 294, 264, 1150, 1349, 321, 3154, 294, 264, 7633], "temperature": 0.0, "avg_logprob": -0.03997474817129282, "compression_ratio": 1.9054054054054055, "no_speech_prob": 2.0761704945471138e-05}, {"id": 484, "seek": 437340, "start": 4390.5199999999995, "end": 4398.28, "text": " layer from the previous word to have it help predict the hidden layer above the second word", "tokens": [4583, 490, 264, 3894, 1349, 281, 362, 309, 854, 6069, 264, 7633, 4583, 3673, 264, 1150, 1349], "temperature": 0.0, "avg_logprob": -0.03997474817129282, "compression_ratio": 1.9054054054054055, "no_speech_prob": 2.0761704945471138e-05}, {"id": 485, "seek": 439828, "start": 4398.28, "end": 4404.84, "text": " and so formally the way we're doing that is we're taking the hidden layer above the first word", "tokens": [293, 370, 25983, 264, 636, 321, 434, 884, 300, 307, 321, 434, 1940, 264, 7633, 4583, 3673, 264, 700, 1349], "temperature": 0.0, "avg_logprob": -0.06120798621379154, "compression_ratio": 1.6477272727272727, "no_speech_prob": 1.8914781321655028e-05}, {"id": 486, "seek": 439828, "start": 4404.84, "end": 4413.32, "text": " multiplying it by a matrix w and then that's going to be going in together with x2 to generate", "tokens": [30955, 309, 538, 257, 8141, 261, 293, 550, 300, 311, 516, 281, 312, 516, 294, 1214, 365, 2031, 17, 281, 8460], "temperature": 0.0, "avg_logprob": -0.06120798621379154, "compression_ratio": 1.6477272727272727, "no_speech_prob": 1.8914781321655028e-05}, {"id": 487, "seek": 439828, "start": 4413.32, "end": 4420.84, "text": " the next hidden step and so we keep on doing that at each time step so that we are kind of repeating", "tokens": [264, 958, 7633, 1823, 293, 370, 321, 1066, 322, 884, 300, 412, 1184, 565, 1823, 370, 300, 321, 366, 733, 295, 18617], "temperature": 0.0, "avg_logprob": -0.06120798621379154, "compression_ratio": 1.6477272727272727, "no_speech_prob": 1.8914781321655028e-05}, {"id": 488, "seek": 442084, "start": 4420.84, "end": 4430.92, "text": " a pattern of creating a next hidden layer based on the next input word and the previous hidden state", "tokens": [257, 5102, 295, 4084, 257, 958, 7633, 4583, 2361, 322, 264, 958, 4846, 1349, 293, 264, 3894, 7633, 1785], "temperature": 0.0, "avg_logprob": -0.08488074345375175, "compression_ratio": 1.6089385474860336, "no_speech_prob": 1.6430711184511892e-05}, {"id": 489, "seek": 442084, "start": 4430.92, "end": 4436.68, "text": " by updating it by multiplying it by a matrix w okay so in my slide here I've still only got", "tokens": [538, 25113, 309, 538, 30955, 309, 538, 257, 8141, 261, 1392, 370, 294, 452, 4137, 510, 286, 600, 920, 787, 658], "temperature": 0.0, "avg_logprob": -0.08488074345375175, "compression_ratio": 1.6089385474860336, "no_speech_prob": 1.6430711184511892e-05}, {"id": 490, "seek": 442084, "start": 4436.68, "end": 4442.28, "text": " forwards of context because it's nice for my slide but you know in principle there could be you", "tokens": [30126, 295, 4319, 570, 309, 311, 1481, 337, 452, 4137, 457, 291, 458, 294, 8665, 456, 727, 312, 291], "temperature": 0.0, "avg_logprob": -0.08488074345375175, "compression_ratio": 1.6089385474860336, "no_speech_prob": 1.6430711184511892e-05}, {"id": 491, "seek": 444228, "start": 4442.28, "end": 4452.2, "text": " know any number of words of context now okay so what we're doing is so that we start off by having", "tokens": [458, 604, 1230, 295, 2283, 295, 4319, 586, 1392, 370, 437, 321, 434, 884, 307, 370, 300, 321, 722, 766, 538, 1419], "temperature": 0.0, "avg_logprob": -0.08735908402336968, "compression_ratio": 1.727810650887574, "no_speech_prob": 1.5435800378327258e-05}, {"id": 492, "seek": 444228, "start": 4452.2, "end": 4461.639999999999, "text": " input vectors which can be our word vectors that we've looked up for each word so sorry yeah so", "tokens": [4846, 18875, 597, 393, 312, 527, 1349, 18875, 300, 321, 600, 2956, 493, 337, 1184, 1349, 370, 2597, 1338, 370], "temperature": 0.0, "avg_logprob": -0.08735908402336968, "compression_ratio": 1.727810650887574, "no_speech_prob": 1.5435800378327258e-05}, {"id": 493, "seek": 444228, "start": 4461.639999999999, "end": 4467.5599999999995, "text": " we can have the one hot vectors for word identity we look up our word embedding so then we've got", "tokens": [321, 393, 362, 264, 472, 2368, 18875, 337, 1349, 6575, 321, 574, 493, 527, 1349, 12240, 3584, 370, 550, 321, 600, 658], "temperature": 0.0, "avg_logprob": -0.08735908402336968, "compression_ratio": 1.727810650887574, "no_speech_prob": 1.5435800378327258e-05}, {"id": 494, "seek": 446756, "start": 4467.56, "end": 4474.92, "text": " word embeddings for each word and then we want to compute hidden states so we need to start from", "tokens": [1349, 12240, 29432, 337, 1184, 1349, 293, 550, 321, 528, 281, 14722, 7633, 4368, 370, 321, 643, 281, 722, 490], "temperature": 0.0, "avg_logprob": -0.10742766206914728, "compression_ratio": 1.7396449704142012, "no_speech_prob": 1.4968100003898144e-05}, {"id": 495, "seek": 446756, "start": 4474.92, "end": 4482.92, "text": " somewhere h zero is the initial hidden state and h zero is normally taken as a zero vector so this", "tokens": [4079, 276, 4018, 307, 264, 5883, 7633, 1785, 293, 276, 4018, 307, 5646, 2726, 382, 257, 4018, 8062, 370, 341], "temperature": 0.0, "avg_logprob": -0.10742766206914728, "compression_ratio": 1.7396449704142012, "no_speech_prob": 1.4968100003898144e-05}, {"id": 496, "seek": 446756, "start": 4482.92, "end": 4490.76, "text": " is actually just initialized the zeros and so for working out the first hidden state we calculated", "tokens": [307, 767, 445, 5883, 1602, 264, 35193, 293, 370, 337, 1364, 484, 264, 700, 7633, 1785, 321, 15598], "temperature": 0.0, "avg_logprob": -0.10742766206914728, "compression_ratio": 1.7396449704142012, "no_speech_prob": 1.4968100003898144e-05}, {"id": 497, "seek": 449076, "start": 4490.76, "end": 4499.96, "text": " based on the first word embedding by multiplying this embedding by a matrix w e and that gives us", "tokens": [2361, 322, 264, 700, 1349, 12240, 3584, 538, 30955, 341, 12240, 3584, 538, 257, 8141, 261, 308, 293, 300, 2709, 505], "temperature": 0.0, "avg_logprob": -0.06883926533941012, "compression_ratio": 1.6839080459770115, "no_speech_prob": 1.2602427887031808e-05}, {"id": 498, "seek": 449076, "start": 4499.96, "end": 4509.64, "text": " the first hidden state but then you know as we go on we want to apply the same formula over again", "tokens": [264, 700, 7633, 1785, 457, 550, 291, 458, 382, 321, 352, 322, 321, 528, 281, 3079, 264, 912, 8513, 670, 797], "temperature": 0.0, "avg_logprob": -0.06883926533941012, "compression_ratio": 1.6839080459770115, "no_speech_prob": 1.2602427887031808e-05}, {"id": 499, "seek": 449076, "start": 4509.64, "end": 4518.92, "text": " so we have just two parameter matrices in the recurrent neural network one matrix for multiplying", "tokens": [370, 321, 362, 445, 732, 13075, 32284, 294, 264, 18680, 1753, 18161, 3209, 472, 8141, 337, 30955], "temperature": 0.0, "avg_logprob": -0.06883926533941012, "compression_ratio": 1.6839080459770115, "no_speech_prob": 1.2602427887031808e-05}, {"id": 500, "seek": 451892, "start": 4518.92, "end": 4525.96, "text": " input embeddings and one matrix for updating the hidden state of the network and so for the second", "tokens": [4846, 12240, 29432, 293, 472, 8141, 337, 25113, 264, 7633, 1785, 295, 264, 3209, 293, 370, 337, 264, 1150], "temperature": 0.0, "avg_logprob": -0.07165159497942243, "compression_ratio": 1.910828025477707, "no_speech_prob": 3.0228649848140776e-05}, {"id": 501, "seek": 451892, "start": 4525.96, "end": 4536.2, "text": " word from its word embedding we multiply it by the w e matrix we take the previous time steps hidden", "tokens": [1349, 490, 1080, 1349, 12240, 3584, 321, 12972, 309, 538, 264, 261, 308, 8141, 321, 747, 264, 3894, 565, 4439, 7633], "temperature": 0.0, "avg_logprob": -0.07165159497942243, "compression_ratio": 1.910828025477707, "no_speech_prob": 3.0228649848140776e-05}, {"id": 502, "seek": 451892, "start": 4536.2, "end": 4545.64, "text": " state and multiply it by the w h matrix and we use the two of those to generate the new hidden state", "tokens": [1785, 293, 12972, 309, 538, 264, 261, 276, 8141, 293, 321, 764, 264, 732, 295, 729, 281, 8460, 264, 777, 7633, 1785], "temperature": 0.0, "avg_logprob": -0.07165159497942243, "compression_ratio": 1.910828025477707, "no_speech_prob": 3.0228649848140776e-05}, {"id": 503, "seek": 454564, "start": 4545.64, "end": 4552.360000000001, "text": " and precisely how we generate the new hidden state is then by shown on this equation on the left", "tokens": [293, 13402, 577, 321, 8460, 264, 777, 7633, 1785, 307, 550, 538, 4898, 322, 341, 5367, 322, 264, 1411], "temperature": 0.0, "avg_logprob": -0.08245425157144036, "compression_ratio": 1.7668711656441718, "no_speech_prob": 4.193612767267041e-05}, {"id": 504, "seek": 454564, "start": 4552.360000000001, "end": 4559.56, "text": " so we take the previous hidden state multiply it by w h we take the input embedding multiply it by", "tokens": [370, 321, 747, 264, 3894, 7633, 1785, 12972, 309, 538, 261, 276, 321, 747, 264, 4846, 12240, 3584, 12972, 309, 538], "temperature": 0.0, "avg_logprob": -0.08245425157144036, "compression_ratio": 1.7668711656441718, "no_speech_prob": 4.193612767267041e-05}, {"id": 505, "seek": 454564, "start": 4559.56, "end": 4570.92, "text": " w e we sum those two we add on a learn bias rate and then we put that through a nonlinearity", "tokens": [261, 308, 321, 2408, 729, 732, 321, 909, 322, 257, 1466, 12577, 3314, 293, 550, 321, 829, 300, 807, 257, 2107, 1889, 17409], "temperature": 0.0, "avg_logprob": -0.08245425157144036, "compression_ratio": 1.7668711656441718, "no_speech_prob": 4.193612767267041e-05}, {"id": 506, "seek": 457092, "start": 4570.92, "end": 4577.64, "text": " and although on the slide that nonlinearity is written as sigma by far the most common nonlinearity", "tokens": [293, 4878, 322, 264, 4137, 300, 2107, 1889, 17409, 307, 3720, 382, 12771, 538, 1400, 264, 881, 2689, 2107, 1889, 17409], "temperature": 0.0, "avg_logprob": -0.07857894897460938, "compression_ratio": 1.625, "no_speech_prob": 1.592414264450781e-05}, {"id": 507, "seek": 457092, "start": 4577.64, "end": 4587.64, "text": " to use here actually is a tan h nonlinearity and so this is the core equation for a simple recurrent", "tokens": [281, 764, 510, 767, 307, 257, 7603, 276, 2107, 1889, 17409, 293, 370, 341, 307, 264, 4965, 5367, 337, 257, 2199, 18680, 1753], "temperature": 0.0, "avg_logprob": -0.07857894897460938, "compression_ratio": 1.625, "no_speech_prob": 1.592414264450781e-05}, {"id": 508, "seek": 457092, "start": 4587.64, "end": 4594.04, "text": " neural network and for each successive time step we're just going to keep on applying that to work", "tokens": [18161, 3209, 293, 337, 1184, 48043, 565, 1823, 321, 434, 445, 516, 281, 1066, 322, 9275, 300, 281, 589], "temperature": 0.0, "avg_logprob": -0.07857894897460938, "compression_ratio": 1.625, "no_speech_prob": 1.592414264450781e-05}, {"id": 509, "seek": 459404, "start": 4594.04, "end": 4601.72, "text": " out hidden states and then from those hidden states we can use them just like in our window", "tokens": [484, 7633, 4368, 293, 550, 490, 729, 7633, 4368, 321, 393, 764, 552, 445, 411, 294, 527, 4910], "temperature": 0.0, "avg_logprob": -0.07155452866152108, "compression_ratio": 1.724770642201835, "no_speech_prob": 2.752185355348047e-05}, {"id": 510, "seek": 459404, "start": 4601.72, "end": 4609.16, "text": " classifier to predict what would be the next word so at any position we can take this hidden vector", "tokens": [1508, 9902, 281, 6069, 437, 576, 312, 264, 958, 1349, 370, 412, 604, 2535, 321, 393, 747, 341, 7633, 8062], "temperature": 0.0, "avg_logprob": -0.07155452866152108, "compression_ratio": 1.724770642201835, "no_speech_prob": 2.752185355348047e-05}, {"id": 511, "seek": 459404, "start": 4610.6, "end": 4616.12, "text": " put it through a softmax layer which is multiplying by you matrix and adding on another bias", "tokens": [829, 309, 807, 257, 2787, 41167, 4583, 597, 307, 30955, 538, 291, 8141, 293, 5127, 322, 1071, 12577], "temperature": 0.0, "avg_logprob": -0.07155452866152108, "compression_ratio": 1.724770642201835, "no_speech_prob": 2.752185355348047e-05}, {"id": 512, "seek": 459404, "start": 4616.12, "end": 4620.76, "text": " and then making a softmax distribution out of that and that will then gives the probability", "tokens": [293, 550, 1455, 257, 2787, 41167, 7316, 484, 295, 300, 293, 300, 486, 550, 2709, 264, 8482], "temperature": 0.0, "avg_logprob": -0.07155452866152108, "compression_ratio": 1.724770642201835, "no_speech_prob": 2.752185355348047e-05}, {"id": 513, "seek": 462076, "start": 4620.76, "end": 4630.52, "text": " distribution over next words what we saw here right this is the entire math of a simple recurrent", "tokens": [7316, 670, 958, 2283, 437, 321, 1866, 510, 558, 341, 307, 264, 2302, 5221, 295, 257, 2199, 18680, 1753], "temperature": 0.0, "avg_logprob": -0.07659974738733093, "compression_ratio": 1.6494252873563218, "no_speech_prob": 5.554050949285738e-05}, {"id": 514, "seek": 462076, "start": 4630.52, "end": 4638.76, "text": " neural network and next time I'll come back and say more about them but this is the entirety of a", "tokens": [18161, 3209, 293, 958, 565, 286, 603, 808, 646, 293, 584, 544, 466, 552, 457, 341, 307, 264, 31557, 295, 257], "temperature": 0.0, "avg_logprob": -0.07659974738733093, "compression_ratio": 1.6494252873563218, "no_speech_prob": 5.554050949285738e-05}, {"id": 515, "seek": 462076, "start": 4638.76, "end": 4644.52, "text": " of what you need to know in some sense for the computation of the forward model of a simple", "tokens": [295, 437, 291, 643, 281, 458, 294, 512, 2020, 337, 264, 24903, 295, 264, 2128, 2316, 295, 257, 2199], "temperature": 0.0, "avg_logprob": -0.07659974738733093, "compression_ratio": 1.6494252873563218, "no_speech_prob": 5.554050949285738e-05}, {"id": 516, "seek": 464452, "start": 4644.52, "end": 4652.76, "text": " or a current neural network so the advantages we have now is it can process a text import of any length", "tokens": [420, 257, 2190, 18161, 3209, 370, 264, 14906, 321, 362, 586, 307, 309, 393, 1399, 257, 2487, 974, 295, 604, 4641], "temperature": 0.0, "avg_logprob": -0.14751597606774533, "compression_ratio": 1.5454545454545454, "no_speech_prob": 5.0592941988725215e-05}, {"id": 517, "seek": 464452, "start": 4654.360000000001, "end": 4660.280000000001, "text": " in theory at least it can use information from any number of steps back we'll talk more about", "tokens": [294, 5261, 412, 1935, 309, 393, 764, 1589, 490, 604, 1230, 295, 4439, 646, 321, 603, 751, 544, 466], "temperature": 0.0, "avg_logprob": -0.14751597606774533, "compression_ratio": 1.5454545454545454, "no_speech_prob": 5.0592941988725215e-05}, {"id": 518, "seek": 464452, "start": 4660.280000000001, "end": 4666.76, "text": " in practice how well that actually works the model size is fixed it doesn't matter how much", "tokens": [294, 3124, 577, 731, 300, 767, 1985, 264, 2316, 2744, 307, 6806, 309, 1177, 380, 1871, 577, 709], "temperature": 0.0, "avg_logprob": -0.14751597606774533, "compression_ratio": 1.5454545454545454, "no_speech_prob": 5.0592941988725215e-05}, {"id": 519, "seek": 466676, "start": 4666.76, "end": 4675.400000000001, "text": " of a past context there is all we have is our WH and W e parameters and at each time step", "tokens": [295, 257, 1791, 4319, 456, 307, 439, 321, 362, 307, 527, 8183, 293, 343, 308, 9834, 293, 412, 1184, 565, 1823], "temperature": 0.0, "avg_logprob": -0.21162204181446748, "compression_ratio": 1.548913043478261, "no_speech_prob": 3.997185922344215e-05}, {"id": 520, "seek": 466676, "start": 4675.400000000001, "end": 4683.400000000001, "text": " we use exactly the same weights to update our hidden state so there's a symmetry in how different", "tokens": [321, 764, 2293, 264, 912, 17443, 281, 5623, 527, 7633, 1785, 370, 456, 311, 257, 25440, 294, 577, 819], "temperature": 0.0, "avg_logprob": -0.21162204181446748, "compression_ratio": 1.548913043478261, "no_speech_prob": 3.997185922344215e-05}, {"id": 521, "seek": 466676, "start": 4683.400000000001, "end": 4691.400000000001, "text": " inputs are processed in producing our predictions our NNs in practice though or these simple RNNs", "tokens": [15743, 366, 18846, 294, 10501, 527, 21264, 527, 426, 45, 82, 294, 3124, 1673, 420, 613, 2199, 45702, 45, 82], "temperature": 0.0, "avg_logprob": -0.21162204181446748, "compression_ratio": 1.548913043478261, "no_speech_prob": 3.997185922344215e-05}, {"id": 522, "seek": 469140, "start": 4691.4, "end": 4698.44, "text": " and practice aren't perfect so a disadvantage is that they're actually kind of slow because with", "tokens": [293, 3124, 3212, 380, 2176, 370, 257, 24292, 307, 300, 436, 434, 767, 733, 295, 2964, 570, 365], "temperature": 0.0, "avg_logprob": -0.10943185199390758, "compression_ratio": 1.641025641025641, "no_speech_prob": 8.462792175123468e-05}, {"id": 523, "seek": 469140, "start": 4698.44, "end": 4704.92, "text": " this recurrent computation in some sense we are sort of stuck with having to have on the outside", "tokens": [341, 18680, 1753, 24903, 294, 512, 2020, 321, 366, 1333, 295, 5541, 365, 1419, 281, 362, 322, 264, 2380], "temperature": 0.0, "avg_logprob": -0.10943185199390758, "compression_ratio": 1.641025641025641, "no_speech_prob": 8.462792175123468e-05}, {"id": 524, "seek": 469140, "start": 4704.92, "end": 4711.96, "text": " of for loop so we can do vector matrix multiplies on the inside here but really we have to do", "tokens": [295, 337, 6367, 370, 321, 393, 360, 8062, 8141, 12788, 530, 322, 264, 1854, 510, 457, 534, 321, 362, 281, 360], "temperature": 0.0, "avg_logprob": -0.10943185199390758, "compression_ratio": 1.641025641025641, "no_speech_prob": 8.462792175123468e-05}, {"id": 525, "seek": 469140, "start": 4711.96, "end": 4720.44, "text": " for time to stay up equals one to N calculate these successive hidden states and so that's not a", "tokens": [337, 565, 281, 1754, 493, 6915, 472, 281, 426, 8873, 613, 48043, 7633, 4368, 293, 370, 300, 311, 406, 257], "temperature": 0.0, "avg_logprob": -0.10943185199390758, "compression_ratio": 1.641025641025641, "no_speech_prob": 8.462792175123468e-05}, {"id": 526, "seek": 472044, "start": 4720.44, "end": 4729.0, "text": " perfect neural net architecture and we'll discuss alternatives to that later and although in theory", "tokens": [2176, 18161, 2533, 9482, 293, 321, 603, 2248, 20478, 281, 300, 1780, 293, 4878, 294, 5261], "temperature": 0.0, "avg_logprob": -0.07785769609304574, "compression_ratio": 1.6844444444444444, "no_speech_prob": 7.58891474106349e-05}, {"id": 527, "seek": 472044, "start": 4729.0, "end": 4735.639999999999, "text": " this model can access information any number of steps back in practice we find that it's", "tokens": [341, 2316, 393, 2105, 1589, 604, 1230, 295, 4439, 646, 294, 3124, 321, 915, 300, 309, 311], "temperature": 0.0, "avg_logprob": -0.07785769609304574, "compression_ratio": 1.6844444444444444, "no_speech_prob": 7.58891474106349e-05}, {"id": 528, "seek": 472044, "start": 4735.639999999999, "end": 4741.799999999999, "text": " pretty imperfect at doing that and that will then lead to more advanced forms of a current neural", "tokens": [1238, 26714, 412, 884, 300, 293, 300, 486, 550, 1477, 281, 544, 7339, 6422, 295, 257, 2190, 18161], "temperature": 0.0, "avg_logprob": -0.07785769609304574, "compression_ratio": 1.6844444444444444, "no_speech_prob": 7.58891474106349e-05}, {"id": 529, "seek": 472044, "start": 4741.799999999999, "end": 4749.0, "text": " network that I'll talk about next time that are able to more effectively access past context", "tokens": [3209, 300, 286, 603, 751, 466, 958, 565, 300, 366, 1075, 281, 544, 8659, 2105, 1791, 4319], "temperature": 0.0, "avg_logprob": -0.07785769609304574, "compression_ratio": 1.6844444444444444, "no_speech_prob": 7.58891474106349e-05}, {"id": 530, "seek": 474900, "start": 4749.0, "end": 4751.8, "text": " okay I think I'll stop there for the day", "tokens": [50364, 1392, 286, 519, 286, 603, 1590, 456, 337, 264, 786, 50504], "temperature": 0.0, "avg_logprob": -0.35706010231604945, "compression_ratio": 0.9090909090909091, "no_speech_prob": 0.0010804323246702552}], "language": "en"}